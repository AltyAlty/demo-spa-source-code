/*
Этот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер, касающиеся аутентификации и
связанных с ней процессов, чтобы компоненты не создавали "side effects" такого типа. Этот файл отвечает за
"DAL" - "Data Access Layer".
*/

import {instance, ResultCodeEnum, ResultCodeForCaptchaEnum, ResponseWithDataType} from './api'; /*Импортируем "instance"
для более быстрого создания запросов. Также импортируем "ResultCodeEnum" -  список кодов ответа от сервера, которые
используются в TC "getAuthUserData" и в TC "login" в "auth-reducer.ts", для осуществления типизации. Так же для
типизации импортируем "ResultCodeForCaptchaEnum" - список кодов ответа от сервера, которые используются в TC "login"
в "auth-reducer.ts". В добавок импортируем общий тип "ResponseWithDataType" для некоторых ответов от сервера со схожей
структурой ответа.*/


type MeResponseDataType = { /*Создали отдельный тип для "data" для запроса "me" из "authAPI". Используется для
уточнения в типе "ResponseType". Этот объект "data" должен содержать информацию о залогиненном пользователе.*/
        id: number /*"ID" залогиненного пользователя, которое должно быть числом.*/
        email: string /*"Email" залогиненного пользователя, который должен быть строкой.*/
        login: string /*"Login" залогиненного пользователя, который должен быть строкой.*/
};

type LoginResponseDataType = { /*Создали отдельный тип для "data" для запроса "login" из "authAPI". Используется для
уточнения в типе "ResponseType".Этот объект "data" должен содержать следующие свойства с указанными типами.*/
    userId: number /*"ID" залогиненного пользователя, которое должно быть числом.*/
};

type LogoutResponseDataType = { /*Создали отдельный тип для "data" для запроса "logout" из "authAPI". Используется для
уточнения в типе "ResponseType".Этот объект "data" должен содержать следующие свойства с указанными типами.*/
    [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/
};


export const authAPI = { /*"usersAPI" содержит запросы, связанные с аутентификацией.*/
    me() { /*Эта функция является запросом на запрос информации для залогинивания через наше приложение.
    Перед этим необходимо либо залогиниться на API сайта, чтобы создались "Cookie", чтобы при запросе сервер мог нас
    идентифицировать, или же ввести данные для залогинивания в нашем приложении.*/
        return (
            instance.get<ResponseWithDataType<MeResponseDataType>>(`auth/me`) /*Делаем GET-запрос для залогинивания
            в нашем приложении на адрес как указано в API сайта. Указали, что этот запрос "GET" возвращает промис с
            типом "ResponseType<MeResponseDataType>".*/
                .then(response => response.data) /*"then" создает "promise". Какие-то данные придут от сервера и
                выполниться стрелочная функция "response". Данные, которые конкретно будут нужны нам, будут находиться
                внутри "response.data". Это "data" создается самим запросом и туда помещается информация от сервера.
                Сама же структура данных в "data" определяется сервером. Согласно API сервера там находятся:
                    - еще один объект "data", который в свою очередь содержит "id" ("ID" залогиненного пользователя),
                    "email" ("email" залогиненного пользователя) и"login" ("login" залогиненного пользователя).
                    - "resultCode" - код ответа сервера ("0" - все хорошо, "1" - какая-то ошибка).
                    - "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                    время залогинивания).
                Затем получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш
                "state" при помощи TC "getAuthUserData" в "auth-reducer.ts".*/
        );
    },

    login(email: string, password: string, rememberMe = false, captcha: null | string = null) { /*Эта функция
    является запросом на залогинивание через наше приложение. Перед этим не нужно залогиниваться на API сайта, чтобы
    создались "Cookie". Нужно просто ввести свои данные для залогинивания в нашем приложении. На сервер отправится
    запрос вместе с объектом данных, которые включают в себя почту (должна быть строкой), пароль (должен быть строкой),
    флаг "Запомнить?" (должен быть булева типа) и введенная капча (должна быть строкой или "null", то есть
    быть пустым), если таковая была.*/
        return (
            instance.post<ResponseWithDataType<LoginResponseDataType, ResultCodeEnum | ResultCodeForCaptchaEnum>>
            (`auth/login`, {email, password, rememberMe, captcha})
            /*Делаем POST-запрос для залогинивания в нашем приложении на адрес как указано в API сайта. В результате
            сервер создаст куки. Указали, что этот запрос "POST" возвращает промис с типом
            "ResponseType<LoginResponseDataType, ResultCodeEnum | ResultCodeForCaptchaEnum>".*/
                .then(response => response.data) /*"then" создает "promise". Какие-то данные придут от сервера и
                выполниться стрелочная функция "response". Данные, которые конкретно будут нужны нам, будут находиться
                внутри "response.data". Эта "data" создается самим запросом и туда помещается информация от сервера.
                Сама же структура данных в "data" определяется сервером. Согласно API сервера там находятся
                    - "resultCode" - код, означающий успешно ли мы залогинились или нет ("0" - все хорошо,
                    "10" - нужно ввести капчу).
                    - "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                    время залогинивания).
                    - "data" - объект, содержащий свойство "userId" с "ID" залогиненного пользователя.
                Получив ответ от сервера в виде нужных данных, возвращаем их далее,
                чтобы осуществить логинизацию пользователя при помощи TC "login" в "auth-reducer.ts".*/
        );
    },

    logout() { /*Эта функция является запросом на разлогинивание через наше приложение. Перед этим нужно быть уже
    залогинен, чтобы создались "Cookie".*/
        return (
            instance.delete<ResponseWithDataType<LogoutResponseDataType>>(`auth/login`) /*Делаем DELETE-запрос для
            разлогинивания в нашем приложении на адрес как указано в API сайта. В результате сервер удалит куки.
            Указали, что этот запрос "DELETE" возвращает промис с типом "ResponseType<LogoutResponseDataType>".*/
                .then(response => response.data)/*"then" создает "promise". Какие-то данные придут от сервера, которые
                будут находиться внутри "response". Внутри "response" будет "data". Эта "data" создается самим запросом
                и туда помещается информация от сервера. Сама же структура данных в "data" определяется сервером.
                Согласно API сервера там находятся:
                    - "resultCode" - код, означающий успешно ли мы залогинились или нет ("0" - все хорошо,
                    другие номера - какая-то ошибка).
                    - "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                    время разлогинивания).
                    - "data" - пустой объект, потенциально может содержать какую-то дополнительную информацию.
                    Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить разлогинивание
                    пользователя при помощи TC "logout" в "auth-reducer.ts".*/
        );
    }
};