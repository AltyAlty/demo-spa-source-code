/*
Этот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер,
чтобы компоненты не создавали "side effects" такого типа. Этот файл отвечает за "DAL" - "Data Access Layer". Правда
в дальнейшем сами запросы мы перенесли в отдельные файлы по категориям.
"Cookie" - это файл, который цепляется ко всем запросам на сервер.
"Cookie" связаны с идентификацией пользователя.
Сервер при подтверждении пользователя записывает идентификатор пользователя в "Cookie" и
отправляет в закодированном виде (в нашем случае - нет) пользователю.
Далее эти "Cookie" записываются браузером до тех пор, пока не истечет срок их жизни, который
в них установлен. Галочка "Запомнить меня?" - это про срок жизни "Cookie".
В дальнейшем при общении с сервером в "Cookie" будет использоваться идентификатор пользователя.
Таким образом, сервер может определять пользователя. Кодировать или декодировать идентификатор может только сервер.
Для каждого домена создаются отдельные "Cookie".
Запрещено делать кросс-доменные запросы, за исключением если домен дал на это разрешение.
Это важно поскольку наше приложение находится на локальном хосте и мы делаем запросы на другой домен из нашего
приложения.
Чтобы залогиниться в нашем приложении нужно сначала залогиниться на API сайта.
Настройки в POST-запросе передаются третьим параметром.
Настройки в DELETE-запросе и GET-запросе передаются вторым параметром.
Все запросы, кроме GET-запросов, требуют обязательно ключа доступа, который генерируется на сайте API в нашем случае.
Такие коды указываются в параметрах запросов в свойстве "headers".
При осуществлении запросов в нашем приложении можно получить ошибку "429", которая означает, что превышен лимит
запросов.
Для снятия этого ограничения нужно купить Premium-аккаунт на сайте API.
При кроссдоменных запросах, перед основным запросом, браузер отправляет OPTIONS-запрос для получения разрешения от
сервера на осуществление кроссдоменных запросов. Это часть "CORS" - политики безопасности браузера.
GET-запросы и DELETE-запросы ничего не могут передать на сервер, кроме адресной строки самого URL-адреса.
POST-запросы и PUT-запросы могут отправлять на сервер разные данные, некий "payload" (например, фото или текст).
*/

import axios from 'axios';
/*
Библиотека "axios" нужна для работы с запросами на сервер.
Запросы осуществляются на "endpoints", которые представляют из себя URL.
Наш API сервера находится здесь: "https://social-network.samuraijs.com/docs".
У каждого API сервера есть базовый URL, в нашем случае это "https://social-network.samuraijs.com/api/1.0/".
К базовому URL дописываются определенные элементы (например, "/users"), чтобы получить какую-то категорию данных.
В запросе "GET" мы не можем передавать какую-либо информацию, кроме URL.
В нашем случае мы получаем ответы в формате JSON.
Существует подход "API first": сначала создается API, а потом уже front-end и back-end.
В библиотеке "axios" любой запрос "GET", "POST" или "PUT" являются "generic" и возвращают промис, который можно уточнить
при помощи "TypeScript".
*/


export const instance = axios.create({ /*Создаем "instance". "axios.create" позволяет создавать экземпляры "axios". Этот
экземпляр будет содержать необходимые параметры для наших запросов.*/
    withCredentials: true, /*Указываем, чтобы к запросам были прикреплены "Cookie".*/
    baseURL: `https://social-network.samuraijs.com/api/1.0/`, /*Указываем базовый URL. Используем обратные
    кавычки "``", чтобы можно было использовать спецсимволы.*/
    headers: { /*Указываем обязательный ключ доступа, который сгенерирован на сайте API.*/
        'API-KEY': 'd418a1c2-23eb-4c24-817d-5fabace62f03'
    }
});


/*"enum" в JS перечисляют строки или числа. При помощи "enum" создали список кодов ответа от сервера, которые
используются в TC "getAuthUserData" и в TC "login" в "auth-reducer.ts".*/
export enum ResultCodeEnum {
    Success = 0,
    Error = 1
};

/*"enum" в JS перечисляют строки или числа. При помощи "enum" создали список кодов ответа от сервера, которые
используются в TC "login" в "auth-reducer.ts".*/
export enum ResultCodeForCaptchaEnum {
    CaptchaIsRequired = 10
};


export type ResponseWithItemsType<T> = { /*Сделали общий тип для ответов от сервера, где ответ имеет следующую
структуру:
- items: массив каких-то элементов;
- totalCount: количество этих элементов;
- error: какое-то информационное сообщение об ошибке.
Этот тип используется в типе "GetUsersType" в "users-api.ts".*/
    items: Array<T>
    totalCount: number
    error: string | null
};

export type ResponseWithDataType<D = {}, RC = ResultCodeEnum> = { /*Сделали общий тип для ответов от сервера, где ответ
имеет следующую структуру:
- data: объект, содержащий какие-то данные;
- resultCode: код какой-то ошибки;
- messages: массив с какими-то информационными сообщениями об ошибке, например:
    1. при какой-либо ошибке во время залогинивания в запросах "me" и "login" из "auth-api.ts";
    2. при какой-либо ошибке во время разлогинивания в запросе "logout" из "auth-api.ts";
    3. при какой-либо ошибке во время фолловинга/анфолловинга пользователя в запросах "follow" и "unfollow" из
    "users-api.ts";
    4. при какой-либо ошибке во время обновления статуса пользователя в запросе "updateUserStatus" из "profile-api.ts";
    5. при какой-либо ошибке во время сохранения фото пользователя в запросе "saveUserPhoto" из "profile-api.ts";
    6. при какой-либо ошибке во время сохранения данных профиля в запросе "saveProfile" из "profile-api.ts".
Данный тип является "generic", в котором мы уточняем "D" - наша "data" (по умолчанию это пустой объект) и "RC" - наш
"resultCode" (по умолчанию список "ResultCodeEnum").
Этот тип используется в запросах:
- "GET" в "me" из "auth-api.ts";
- "POST" в "login" из "auth-api.ts";
- "DELETE" в "logout" из "auth-api.ts";
- "POST" в "follow" из "users-api.ts";
- "DELETE" в "unfollow" из "users-api.ts";
- "PUT" в "updateUserStatus" из "profile-api.ts";
- "PUT" в "saveUserPhoto" из "profile-api.ts";
- "PUT" в "saveProfile" из "profile-api.ts".
*/
    data: D
    resultCode: RC
    messages: Array<string>
};