/*
Этот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер,
чтобы компоненты не создавали "side effects" такого типа. Этот файл отвечает за "DAL" - "Data Access Layer".
"Cookie" - это файл, который цепляется ко всем запросам на сервер.
"Cookie" связаны с идентификацией пользователя.
Сервер при подтверждении пользователя записывает идентификатор пользователя в "Cookie" и
отправляетв закодированном виде (в нашем случае - нет) пользователю.
Далее эти "Cookie" записываются браузером до тех пор, пока не истечет срок их жизни, который
в них установлен. Галочка "Запомнить меня?" - это про срок жизни "Cookie".
В дальнейшем при общении с сервером в "Cookie" будет использоваться идентификатор пользователя.
Таким образом, сервер может определять пользователя. Кодировать или декодировать идентификатор может только сервер.
Для каждого домена создаются отдельные "Cookie".
Запрещено делать кросс-доменные запросы, за исключением если домен дал на это разрешение.
Это важно поскольку наше приложение находится на локальном хосте и мы делаем запросы на другой домен из нашего
приложения.
Чтобы залогиниться в нашем приложении нужно сначала залогиниться на API сайта.
Настройки в POST-запросе передаются третьим параметром.
Настройки в DELETE-запросе и GET-запросе передаются вторым параметром.
Все запросы, кроме GET-запросов, требуют обязательно ключа доступа, который генерируется на сайте API в нашем случае.
Такие коды указываются в параметрах запросов в свойстве "headers".
При осуществлении запросов в нашем приложении можно получить ошибку "429", которая означает, что превышен лимит
запросов.
Для снятия этого ограничения нужно купить Premium-аккаунт на сайте API.
При кроссдоменных запросах, перед основным запросом, браузер отправляет OPTIONS-запрос для получения разрешения от
сервера на осуществление кроссдоменных запросов. Это часть "CORS" - политики безопасности браузера.
GET-запросы и DELETE-запросы ничего не могут передать на сервер, кроме адресной строки самого URL-адреса.
POST-запросы и PUT-запросы могут отправлять на сервер разные данные, некий "payload" (например, фото или текст).
*/

import axios from 'axios';
/*
Библиотека axios нужна для работы с запросами на сервер.
Запросы осуществляются на "endpoints", которые представляют из себя URL.
Наш API сервера находится здесь: "https://social-network.samuraijs.com/docs".
У каждого API сервера есть базовый URL, в нашем случае это "https://social-network.samuraijs.com/api/1.0".
К базовому URL дописываются определенные элементы (например, "/users"), чтобы получить какую-то категорию данных.
В запросе "GET" мы не можем передавать какую-либо информацию, кроме URL.
В нашем случае мы получаем ответы в формате JSON.
Существует подход "API first": сначала создается API, а потом уже front-end и back-end.
В библиотеке "axios" любой запрос "GET", "POST" или "PUT" являются "generic" и возвращают промис, который можно уточнить
при помощи "TypeScript".
*/

import {ProfileType, PhotosType, UserType} from '../types/types'; /*Импортируем типы.*/


const instance = axios.create({ /*Создаем "instance". "axios.create" позволяет создавать экземпляры "axios". Этот
экземпляр будет содержать необходимые параметры для наших запросов.*/
    withCredentials: true, /*Указываем, чтобы к запросам были прикреплены "Cookie".*/
    baseURL: `https://social-network.samuraijs.com/api/1.0/`, /*Указываем базовый URL. Используем обратные
    кавычки "``", чтобы можно было использовать спецсимволы.*/
    headers: { /*Указываем обязательный ключ доступа, который сгенерирован на сайте API.*/
        'API-KEY': 'd418a1c2-23eb-4c24-817d-5fabace62f03'
    }
});

/*
Далее идут объекты, которые содержат вспомогательные запросы на сервер. Эти объекты можно представить в виде категорий.
*/
export const usersAPI = { /*"usersAPI" содержит запросы, связанные со страницей с постраничным выводом пользователей.*/
    getUsers(currentPage: number, pageSize: number) { /*Эта функция является запросом на получение данных пользователей
    в постраничном выводе. Эти данные на сервере структурированы по страницам, поэтому данная функция принимает два
    параметра: текущая страница для отображения (1 "default") и количество пользователей на этой
    странице (от 10 ("default") до 100). Эти два параметра должны быть .*/
        return (
            instance.get<getUsersType>(`users?page=${currentPage}&count=${pageSize}`) /*Указываем, что добавляем к
            базовому URL, указанному в "instance", "users", чтобы получить данные пользователей. Знак "?" означает, что
            дальше идут параметры GET-запроса, знак "&" используется для перечисления таких параметров. Названия этих
            параметров и ограничения их значений описываются в API сервера. Указали, что этот запрос "GET" возвращает
            промис с типом "getUsersType".*/
                .then(response => { /*"then" создает "promise".
                Эти данные придут от сервера и выполниться стрелочная функция "response".
                Данные, которые конкретно будут нужны нам, будут находиться внутри "response.data".
                Это "data" создается самим запросом и туда помещается информация от сервера. Сама же структура данных
                в "data" определяется сервером. Согласно API сервера там находятся:
                - "items" - массив с объектами, которые содержат данные по пользователям.
                Каждый такой объект содержит следуюющее:
                    - "name" - имя пользователя.
                    - "id" - "ID" пользователя.
                    - "photos": - объект с путями к фото пользователя.
                        - "small" - уменьшенное фото.
                        - "large" - увеличенное фото.
                    - "status" - статус пользователя.
                    - "followed" - говорит фолловим ли мы пользователя или нет.
                - "totalCount" - количество всех пользователей.
                - "error" - содержит сообщение об ошибке, если была.*/
                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,
                чтобы установить их в наш "state" при помощи TC "requestUsers" в "users-reducer.ts".*/
                })
        );
    },

    unfollow(id: number) { /*Эта функция является запросом на анфолловинг какого-либо пользователя. Оба запроса на
    анфолловинг и фолловинг идут на один и тот же "endpoint", только для анфолловинга нужно делать DELETE-запрос,
    а для фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать "ID" пользователя, которого
    анфолловим или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи "Cookie" сервер
    будет определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/
        return (
            instance.delete<unfollowFollowType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,
            указанному в "instance", "follow" и "ID" пользователя, которого анфолловим, чтобы сформировать запрос на
            анфолловинг. Указали, что этот запрос "DELETE" возвращает промис с типом "unfollowFollowType".*/
                .then(response => { /*"then" создает "promise".
                Какие-то данные придут от сервера и выполниться стрелочная функция "response".
                Данные, которые конкретно будут нужны нам, будут находиться внутри "response.data".
                Эта "data" создается самим запросом и туда помещается информация от сервера. Сама же структура данных
                в "data" определяется сервером. Согласно API сервера там находятся:
                - "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя, "0" - все хорошо,
                "1" - какая-то ошибка.
                - "messages" - информационное сообщение от сервера (например, при какой-либо ошибке во время обновления
                статуса пользователя).
                - "data" - какие-то дополнительные данные (в данный момент не используется).*/
                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,
                чтобы осуществить анфолловинг пользователя при помощи TC "unfollow" в "users-reducer.ts".*/
                })
        );
    },

    follow(id: number) { /*Эта функция является запросом на фолловинг какого-либо пользователя. Оба запроса на
    анфолловинг и фолловинг идут на один и тот же "endpoint", только для анфолловинга нужно делать DELETE-запрос, а для
    фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать "ID" пользователя, которого анфолловим
    или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи "Cookie" сервер будет
    определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/
        return (
            instance.post<unfollowFollowType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,
            указанному в "instance", "follow" и "ID" пользователя, которого фолловим, чтобы сформировать запрос на
            фолловинг. Указали, что этот запрос "POST" возвращает промис с типом "unfollowFollowType".*/
                .then(response => { /*"then" создает "promise".
                Какие-то данные придут от сервера и выполниться стрелочная функция "response".
                Данные, которые конкретно будут нужны нам, будут находиться внутри "response.data".
                Эта "data" создается самим запросом и туда помещается информация от сервера. Сама же структура данных
                в "data" определяется сервером. Согласно API сервера там находятся:
                - "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя, "0" - все хорошо,
                "1" - какая-то ошибка.
                - "messages" - информационное сообщение от сервера (например, при какой-либо ошибке во время обновления
                статуса пользователя).
                - "data" - какие-то дополнительные данные (в данный момент не используется).*/
                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,
                чтобы осуществить фолловинг пользователя при помощи TC "follow" в "users-reducer.ts".*/
                })
        );
    },

    getUserProfile(userID: number) { /*Это устаревший запрос на получение данных профиля пользователя для страницы
    профиля в виде функции, которая принимает один параметр в виде "ID" пользователя, который должен быть числом. Сейчас
    просто вызывает актуальный запрос "getUserProfile" из "profileAPI". То есть мы здесь делегировали управление
    из "userAPI" в "profileAPI". При вызове же этого устаревшего метода появится информационное сообщение. В дальнейшем
    лучше избавиться от этого устаревшего метода.*/
        console.warn('Obsolete method. Use profileAPI object')
        return (
            profileAPI.getUserProfile(userID)
        );
    }
};

export const profileAPI = { /*"usersAPI" содержит запросы, связанные со страницей профиля пользователя.*/
    getUserProfile(userID: number) { /*Эта функция является запросом на получение данных профиля пользователя для
    страницы профиля. Данная функция принимает один параметр в виде "ID" пользователя, который должен быть числом.*/
        return (
            instance.get<ProfileType>(`profile/${userID}`) /*Указываем, что добавляем к базовому URL, указанному в
            "instance", чтобы получить данные профиля пользователя. Указали, что этот запрос "GET" возвращает промис с
            типом "ProfileType", который был создан нами и импортирован сюда.
            Данные придут от сервера и будут находиться внутри "response.data". Это "data" создается самим запросом и
            туда помещается информация от сервера. Сама же структура данных в "data" определяется сервером. Согласно
            API сервера там находятся:
            "aboutMe" - информация "обо мне" (на сайте API этого нет, но на самом деле на сервере это поле имеется).
            "contacts": - контакты.
                "github"
                "vk"
                "facebook"
                "instagram"
                "twitter"
                "website"
                "youtube"
                "mainLink".
            "fullName" - полное имя.
            "lookingForAJob" - ищет ли работу.
            "lookingForAJobDescription" - какую ищет работу.
            "photos": - фото.
                "small"
                "large".
            "userId" - "ID" пользователя.
            Здесь в отличии от "getUsers" мы не используем ".then(response => {...}", и не вытаскиваем блок с нужными
            данными из всего ответа от сервера. Это мы делаем уже в TC "getUserProfile" в "profile-reducer.ts", но
            такое лучше не указывать в BLL, поэтому мы там используем "async/await" как аналог ".then".*/
        );
    },

    getUserStatus(userID: number) { /*Эта функция является запросом на получение данных статуса пользователя для
    страницы профиля. Данная функция принимает один параметр в виде "ID" пользователя, который должен быть числом.*/
        return (
            instance.get<string>(`profile/status/${userID}`) /*Указываем, что добавляем к базовому URL, указанному
            в "instance", чтобы получить данные статуса пользователя. Указали, что этот запрос "GET" возвращает промис
            с типом строки.
            Данные придут от сервера и будут находиться внутри "response.data". Это "data" создается самим запросом и
            туда помещается информация от сервера. Сама же структура данных в "data" определяется сервером.
            Согласно API сервера там находится текст статуса пользователя (хотя было бы лучше, чтобы данные приходили
            в формате JSON, то есть в данном случае не возвращается объект со свойствами, как это происходит в других
            запросах).
            Здесь в отличии от "getUsers" мы не используем ".then(response => {...}", и не вытаскиваем блок с нужными
            данными из всего ответа от сервера. Это мы делаем уже в TC "getUserStatus" в "profile-reducer.ts", но такое
            лучше не указывать в BLL, поэтому мы там используем "async/await" как аналог ".then".*/
        );
    },

    updateUserStatus(status: string) { /*Эта функция является запросом на изменение данных статуса пользователя для
    страницы профиля на сервере. Данная функция принимает один параметр в виде строки с информацией из статуса.
    Согласно API сервера максимальная длинна статуса 300 символов в формате JSON.*/
        return (
            instance.put<updateUserStatusType>(`profile/status`, {status: status}) /*Указываем, что добавляем
            к базовому URL, указанному в "instance", чтобы отправить на сервер новые данные статуса пользователя.
            А также указываем объект с этими данными. Указали, что этот запрос "PUT" возвращает промис с типом
            "updateUserStatusType".
            В ответ на этот запрос к нам придут данные, которые будут находиться внутри "response.data". Эта "data"
            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в "data"
            определяется сервером. Согласно API сервера там находятся:
            - "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя, "0" - все хорошо,
            "1" - какая-то ошибка.
            - "messages" - информационное сообщение от сервера (например, при какой-либо ошибке во время обновления
            статуса пользователя).
            - "data" - какие-то дополнительные данные (в данный момент не используется).
            Здесь в отличии от "getUsers" мы не используем ".then(response => {...}", и не вытаскиваем блок с нужными
            данными из всего ответа от сервера. Это мы делаем уже в TC "updateUserStatus" в "profile-reducer.ts", но
            такое лучше не указывать в BLL, поэтому мы там используем "async/await" как аналог ".then".*/
        );
    },

    saveUserPhoto(photoFile: any) { /*Эта функция является запросом на загрузку фото пользователя на сервер. Данная
    функция принимает один параметр в виде файла. Тип этого файла указан как "any", так как мы пока не знаем какого
    именно типа он будет.*/
        const formData = new FormData();
        formData.append("image", photoFile); /*Поскольку здесь мы передаем не просто JSON-данные, а изображение,
        то поэтому формируем специальный объект при помощи "FormData()". При помощи метода "append" добавляем в этот
        объект файл с фото. "image" - так указывается согласно API сервера. Третьим параметром отправляется объект
        со специфическими заголовками, но в данном случае и без них все работает.*/

        return (
            instance.put<saveUserPhotoType>(`profile/photo`, formData/*, {headers: {'Content-Type': 'multipart/form-data'}}*/)
            /*Указываем, что добавляем к базовому URL, указанному в "instance", чтобы отправить на сервер
            фото пользователя. А также указываем объект с этим фото. Указали, что этот запрос "PUT" возвращает промис
            с типом "saveUserPhotoType".
            В ответ на этот запрос к нам придут данные, которые будут находиться внутри "response.data". Эта "data"
            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в "data"
            определяется сервером. Согласно API сервера там находятся:
            - "resultCode" - код, означающий успешно ли прошла загрузка фото пользователя, "0" - все хорошо,
            другие числа - какая-то ошибка.
            - "messages" - информационное сообщение от сервера (например, при какой-либо ошибке во время загрузки фото).
            - "data" - дополнительные данные, в которых содержится еще один объект "photos", который в свою очередь
            имеет еще два свойства:
            1) "small" - URL фото в маленьком размере, если отсутствует, то будет "NULL".
            2) "large" - URL фото в большом размере, если отсутствует, то будет "NULL".
            Помимо наличия объекта "photos", "data" имеет также свои свойства "small" и "large", копирующие аналогичные
            свойства у объекта "photos". Предположительно это ошибочно добавили на сервере.
            Здесь в отличии от "getUsers" мы не используем ".then(response => {...}", и не вытаскиваем блок с нужными
            данными из всего ответа от сервера. Это мы делаем уже в TC "saveUserPhoto" в "profile-reducer.ts", но
            такое лучше не указывать в BLL, поэтому мы там используем "async/await" как аналог ".then".*/
        );
    },

    saveProfile(profile: ProfileType) { /*Эта функция является запросом на отправку новых данных профиля пользователя
    на сервер. Данная функция принимает один параметр в виде объекта с данными типа "ProfileType", который создан был
    нами и импортирован сюда. Согласно API сервера в этом объекте должно находится следующее:
            "aboutMe" - информация "обо мне" (на сайте API этого нет, но на самом деле на сервере это поле имеется).
            "contacts": - контакты.
                "github"
                "vk"
                "facebook"
                "instagram"
                "twitter"
                "website"
                "youtube"
                "mainLink".
            "fullName" - полное имя.
            "lookingForAJob" - ищет ли работу.
            "lookingForAJobDescription" - какую ищет работу.
            "photos": - фото.
                "small"
                "large".
            "userId" - "ID" пользователя.*/
        return (
            instance.put<saveProfileType>(`profile`, profile) /*Указываем, что добавляем к базовому URL, указанному
            в "instance", чтобы отправить на сервер новые данные профиля пользователя. А также указываем объект с этими
            данными. Указали, что этот запрос "PUT" возвращает промис с типом "saveProfileType".
            В ответ на этот запрос к нам придут данные, которые будут находиться внутри "response.data". Эта "data"
            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в "data"
            определяется сервером. Согласно API сервера там находятся:
            - "resultCode" - код, означающий успешно ли прошла отправка новых данных профиля пользователя, "0" - все
            хорошо, другие числа - какая-то ошибка.
            - "messages" - информационное сообщение от сервера (например, при какой-либо ошибке во время отправки
            новых данных профиля пользователя).
            - "data" - какие-то дополнительные данные (в данный момент не используется).
            Здесь в отличии от "getUsers" мы не используем ".then(response => {...}", и не вытаскиваем блок с нужными
            данными из всего ответа от сервера. Это мы делаем уже в TC "saveProfile" в "profile-reducer.ts"., но
            такое лучше не указывать в BLL, поэтому мы там используем "async/await" как аналог ".then"*/
        );
    }
};

export const authAPI = { /*"usersAPI" содержит запросы, связанные с аутентификацией.*/
    me() { /*Эта функция является запросом на запрос информации для залогинивания через наше приложение.
    Перед этим необходимо либо залогиниться на API сайта, чтобы создались "Cookie", чтобы при запросе сервер мог нас
    идентифицировать, или же ввести данные для залогинивания в нашем приложении.*/
        return (
            instance.get<MeResponseType>(`auth/me`) /*Делаем GET-запрос для залогинивания в нашем приложении на
            адрес как указано в API сайта. Указали, что этот запрос "GET" возвращает промис с типом "MeResponseType".*/
                .then(response => response.data) /*"then" создает "promise".
                Эти данные придут от сервера и выполниться стрелочная функция "response".
                Данные, которые конкретно будут нужны нам, будут находиться внутри "response.data".
                Это "data" создается самим запросом и туда помещается информация от сервера. Сама же структура данных
                в "data" определяется сервером. Согласно API сервера там находятся:
                - еще один объект "data", который в свою очередь содержит "id" ("ID" залогиненного пользователя),
                "email" ("email" залогиненного пользователя) и"login" ("login" залогиненного пользователя).
                - "resultCode" - код ответа сервера ("0" - все хорошо, "1" - какая-то ошибка).
                - "messages" - информационное сообщение от сервера (например, при какой-либо ошибке во время
                залогинивания).
                Затем получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш
                "state" при помощи TC "getAuthUserData" в "auth-reducer.ts".*/
        );
    },

    login(email: string, password: string, rememberMe = false, captcha: null | string = null) { /*Эта функция
    является запросом на залогинивание через наше приложение. Перед этим не нужно залогиниваться на API сайта, чтобы
    создались "Cookie". Нужно просто ввести свои данные для залогинивания в нашем приложении. На сервер отправится
    запрос вместе с объектом данных, которые включают в себя почту (должна быть строкой), пароль (должен быть строкой),
    флаг "Запомнить?" (должен быть булева типа) и введенная капча (должна быть строкой или "null", то есть
    быть пустым), если таковая была.*/
        return (
            instance.post<LoginResponseType>(`auth/login`, {email, password, rememberMe, captcha}) /*Делаем
            POST-запрос для залогинивания в нашем приложении на адрес как указано в API сайта. В результате сервер
            создаст куки. Указали, что этот запрос "POST" возвращает промис с типом "LoginResponseType".*/
                .then(response => response.data) /*"then" создает "promise".
                Какие-то данные придут от сервера и выполниться стрелочная функция "response".
                Данные, которые конкретно будут нужны нам, будут находиться внутри "response.data".
                Эта "data" создается самим запросом и туда помещается информация от сервера. Сама же структура данных
                в "data" определяется сервером. Согласно API сервера там находятся
                - "resultCode" - код, означающий успешно ли мы залогинились или нет ("0" - все хорошо,
                "10" - нужно ввести капчу).
                - "messages" - массив, содержащий какие-то информационные сообщения от сервера, если они есть.
                - "data" - объект, содержащий свойство "userId" с "ID" залогиненного пользователя.
                Получив ответ от сервера в виде нужных данных, возвращаем их далее,
                чтобы осуществить логинизацию пользователя при помощи TC "login" в "auth-reducer.ts".*/
        );
    },

    logout() { /*Эта функция является запросом на разлогинивание через наше приложение. Перед этим нужно быть уже
    залогинен, чтобы создались "Cookie".*/
        return (
            instance.delete<LogoutResponseType>(`auth/login`) /*Делаем DELETE-запрос для разлогинивания в нашем
            приложении на адрес как указано в API сайта. В результате сервер удалит куки. Указали, что этот запрос
            "DELETE" возвращает промис с типом "LogoutResponseType".
            Также какие-то данные придут от сервера, которые будут находиться внутри "response". Внутри "response"
            будет "data".
            Эта "data" создается самим запросом и туда помещается информация от сервера. Сама же структура данных
            в "data" определяется сервером. Согласно API сервера там находятся
            - "resultCode" - код, означающий успешно ли мы залогинились или нет ("0" - все хорошо,
            другие номера - какая-то ошибка).
            - "messages" - массив, содержащий какие-то информационные сообщения от сервера, если они есть.
            - "data" - пустой объект, потенциально может содержать какую-то дополнительную информацию.
            Получив ответ от сервера в виде нужных данных, возвращаем их (весь "response" в отличие от "login",
            вытаскиваем "data" в самом TC) далее, чтобы осуществить разлогинивание пользователя при помощи TC "logout"
            в "auth-reducer.ts", но такое лучше не указывать в BLL, поэтому мы там используем "async/await" как
            аналог ".then".*/
        );
    }
};

export const securityAPI = { /*"usersAPI" содержит запросы, связанные с безопасностью.*/
    getCaptchaURL() { /*Если нашему серверу необходимо, чтобы мы ввели капчу после нескольких неудачных попыток
    залогиниться, то он сообщит браузеру, что тот должен сделать запрос на специальный "endpoint" и в ответ получить
    картинку с капчей (в виде объекта, содержащего URL). Эта функция является запросом на получение капчи.*/
        return (
            instance.get<getCaptchaURLResponseType>(`security/get-captcha-url`) /*Указываем, что добавляем к
            базовому URL, указанному в "instance", чтобы отправить запрос на сервер для получения капчи. Указали, что
            этот запрос "GET" возвращает промис с типом "getCaptchaURLResponseType".
            В ответ на этот запрос к нам придут  данные, которые будут находиться внутри "response.data". Эта "data"
            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в "data"
            определяется сервером. Согласно API сервера там находится строковой элемент "url", в котором указан URL
            капчи.
            Здесь в отличии от "getUsers" мы не используем ".then(response => {...}", и не вытаскиваем блок с нужными
            данными из всего ответа от сервера. Это мы делаем уже в TC "getCaptchaURL" в "auth-reducer.ts", но такое
            лучше не указывать в BLL, поэтому мы там используем "async/await" как аналог ".then".*/
        );
    }
};


/*"enum" в JS перечисляют строки или числа. При помощи "enum" создали список кодов ответа от сервера, которые
используются в TC "getAuthUserData" и в TC "login" в "auth-reducer.ts".*/
export enum ResultCodeEnum {
    Success = 0,
    Error = 1
};

/*"enum" в JS перечисляют строки или числа. При помощи "enum" создали список кодов ответа от сервера, которые
используются в TC "login" в "auth-reducer.ts".*/
export enum ResultCodeForCaptchaEnum {
    CaptchaIsRequired = 10
};


/*Создаем типы промисов, который возвращаются в запросах в этом API.*/
/*Создаем типы для промисов запросов из "usersAPI"*/
/*Создаем тип для промиса, который будет возвращаться из запроса "GET" в "getUsers" из "usersAPI".*/
type getUsersType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными
типами.*/
    items: Array<UserType> /*Там должна содержаться информация по пользователям в виде массива объектов с типом
    "UserType", который был создан нами и импортирован сюда.*/
    totalCount: number /*Количество всех пользователей должно быть числом.*/
    error: string | null /*Сообщение с ошибкой от сервера (например, при какой-либо ошибке во время получения данных
    по пользователям) должно быть строкой или "null", то есть быть пустым.*/
};

/*Создаем тип для промисов, которые будут возвращаться из запроса "DELETE" в "unfollow" и из запроса "POST" в "follow"
из "usersAPI".*/
type unfollowFollowType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными
типами.*/
    data: { /*Там должен быть объект "data", который потенциально может содержать дополнительную информацию.*/
        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/
    }
    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа "ResultCodeEnum", который мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    анфолловинга пользователя) должно быть массивом с элементами типа строк.*/
};

/*Создаем типы для промисов запросов из "profileAPI"*/
/*Создаем тип для промиса, который будет возвращаться из запроса "PUT" в "updateUserStatus" из "profileAPI".*/
type updateUserStatusType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными
типами.*/
    data: { /*Там должен быть объект "data", который потенциально может содержать дополнительную информацию.*/
        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/
    }
    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа "ResultCodeEnum", который мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    обновления статуса пользователя) должно быть массивом с элементами типа строк.*/
};

/*Создаем тип для промиса, который будет возвращаться из запроса "PUT" в "saveUserPhoto" из "profileAPI".*/
type saveUserPhotoType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными
типами.*/
    data: { /*Там должен быть объект "data", содержащий информацию о залогиненном пользователе.*/
        photos: PhotosType /*Объект с фото пользователя должно быть типа "PhotosType", который мы создали ниже.*/
        small: string | null /*Путь к уменьшенной версии фото пользователя должен быть строкой или "null" (то есть
        быть пустым). Это свойство видимо добавлено на сервере ошибочно, так как дублирует часть объекта "photos".*/
        large: string | null /*Путь к увеличенной версии фото пользователя должен быть строкой или "null" (то есть
        быть пустым). Это свойство видимо добавлено на сервере ошибочно, так как дублирует часть объекта "photos".*/
    }
    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа "ResultCodeEnum", который мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    сохранения фото пользователя) должно быть массивом с элементами типа строк.*/
};

/*Создаем тип для промиса, который будет возвращаться из запроса "PUT" в "saveProfile" из "profileAPI".*/
type saveProfileType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/
    data: { /*Там должен быть объект "data", который потенциально может содержать дополнительную информацию.*/
        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/
    }
    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа "ResultCodeEnum", который мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    сохранения данных профиля) должно быть массивом с элементами типа строк.*/
};

/*Создаем типы для промисов запросов из "authAPI"*/
/*Создаем тип для промиса, который будет возвращаться из запроса "GET" в "me" из "authAPI".*/
type MeResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/
    data: { /*Там должен быть объект "data", содержащий информацию о залогиненном пользователе.*/
        id: number /*"ID" залогиненного пользователя, которое должно быть числом.*/
        email: string /*"Email" залогиненного пользователя, который должен быть строкой.*/
        login: string /*"Login" залогиненного пользователя, который должен быть строкой.*/
    }
    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа "ResultCodeEnum", который мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    залогинивания) должно быть массивом с элементами типа строк.*/
};

/*Создаем тип для промиса, который будет возвращаться из запроса "POST" в "login" из "authAPI".*/
type LoginResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/
    data: { /*Там должен быть объект "data", содержащий информацию о залогиненном пользователе.*/
        userId: number /*"ID" залогиненного пользователя, которое должно быть числом.*/
    }
    resultCode: ResultCodeEnum | ResultCodeForCaptchaEnum /*Код ответа сервера должен быть либо типа "ResultCodeEnum",
    либо типа "ResultCodeForCaptchaEnum", которые мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    залогинивания) должно быть массивом с элементами типа строк.*/
};

/*Создаем тип для промиса, который будет возвращаться из запроса "DELETE" в "logout" из "authAPI".*/
type LogoutResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/
    data: { /*Там должен быть объект "data", который потенциально может содержать дополнительную информацию.*/
        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/
    }
    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа "ResultCodeEnum", который мы создали выше.*/
    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время
    разлогинивания) должно быть массивом с элементами типа строк.*/
};

/*Создаем типы для промисов запросов из "securityAPI"*/
/*Создаем тип для промиса, который будет возвращаться из запроса "GET" в "getCaptchaURL" из "securityAPI".*/
type getCaptchaURLResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными
типами.*/
    url: string /*Информация о пути к изображению с капчей должна быть строкой.*/
};