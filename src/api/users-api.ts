/*Импортируем два общих типа "ResponseWithDataType" и "ResponseWithItemsType" для некоторых ответов от сервера со схожей
структурой ответа.*/
import {instance, ResponseWithDataType, ResponseWithItemsType} from './api';
/*Импортируем тип "UserType".*/
import {UserType} from '../types/types';

/*Объект "usersAPI" содержит запросы, связанные со страницей с постраничным выводом пользователей.*/
export const usersAPI = {
    /*Эта функция является запросом на получение данных пользователей в постраничном выводе. Эти данные на сервере
    структурированы по страницам, поэтому данная функция принимает четыре параметра:
    1. "currentPage" - текущая страница для отображения (1 по умолчанию), должно быть числом.
    2. "pageSize" - количество пользователей на этой странице (от 10 по умолчанию до 100), должно быть числом.
    3. "term" - фильтр в виде строкового значения, которое сервер будет получать и искать наличие этого значения в
    именах всех пользователей, чтобы в итоге вывести только таких пользователей (по умолчанию указана пустая строка).
    4. "friend" - еще один фильтр булева типа или типа null, если указать в нем true, то сервер выберет только тех
    пользователей, которых мы фолловим, если указать false - только тех, кого мы не фолловим, если указать null или
    вообще не указывать, то выберет всех пользователей (по умолчанию указано null).*/
    getUsers(currentPage: number, pageSize: number, term: string = '', friend: null | boolean = null) {
        return (
            /*Указываем что добавляется к базовому URL внутри "instance", чтобы получить данные пользователей. Знак "?"
            означает, что дальше идут параметры GET-запроса. Знак "&" используется для перечисления таких параметров.
            Названия этих параметров и ограничения их значений описываются в API сервера.

            "+ (friend === null ? '' : `&friend=${friend}`" - здесь мы склеиваем строку с пустой строкой, если параметр
            "friend" равен null, иначе склеиваем со строками `&friend=true` или `&friend=false`, если в параметре
            "friend" указали true или false соответственно.

            Также указываем, что этот GET-запрос возвращает промис с типом "ResponseWithItemsType<UserType>".*/
            instance.get<ResponseWithItemsType<UserType>>(
                `users?page=${currentPage}&count=${pageSize}&term=${term}` + (friend === null ? '' : `&friend=${friend}`
                ))
                /*Метод "then()" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c
                объектом "response". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства
                "response.data". Это свойство "data" создается самим запросом и туда помещается информация от сервера.

                Сама же структура данных в свойстве "data" определяется сервером. Согласно API сервера там находятся:
                1. "items" - массив с объектами, которые содержат данные по пользователям. Каждый такой объект содержит
                следующее:
                  1) "name" - имя пользователя.
                  2) "id" - ID пользователя.
                  3) "photos": - объект с путями к фото пользователя.
                    a. "small" - уменьшенное фото.
                    b. "large" - увеличенное фото.
                  3) "status" - статус пользователя.
                  4) "followed" - говорит фолловим ли мы пользователя или нет.
                3. "totalCount" - количество всех пользователей.
                4. "error" - содержит сообщение об ошибке, если была.

                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при
                помощи TC "requestUsers()".*/
                .then(response => { return response.data })
        );
    },

    /*Эта функция является запросом на анфолловинг какого-либо пользователя. Оба запроса на анфолловинг и фолловинг идут
    на один и тот же endpoint, только для анфолловинга нужно делать DELETE-запрос, а для фолловинга нужно делать
    POST-запрос. Также в обоих случаях нужно указывать ID пользователя, которого анфолловим или фолловим. Этот параметр
    должен быть числом. Все это указано в API сервера. При помощи cookie-файлов сервер будет определять нас и знать для
    какого пользователя сделать фолловинг или анфолловинг.*/
    unfollow(id: number) {
        return (
            /*Указываем что добавляется к базовому URL внутри "instance", чтобы сформировать запрос на анфолловинг.
            Указываем, что этот DELETE-запрос возвращает промис с типом "ResponseWithDataType".*/
            instance.delete<ResponseWithDataType>(`follow/${id}`)
                /*Метод "then()" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c
                объектом "response". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства
                "response.data". Это свойство "data" создается самим запросом и туда помещается информация от сервера.

                Сама же структура данных в свойстве "data" определяется сервером. Согласно API сервера там находятся:
                1. "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя (0 - все хорошо, 1 -
                какая-то ошибка).
                2. "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                время анфолловинга пользователя).
                3. "data" - какие-то дополнительные данные (в данный момент не используется).

                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить анфолловинг
                пользователя при помощи TC "unfollow()".*/
                .then(response => { return response.data })
        );
    },

    /*Эта функция является запросом на фолловинг какого-либо пользователя. Оба запроса на анфолловинг и фолловинг идут
    на один и тот же endpoint, только для анфолловинга нужно делать DELETE-запрос, а для фолловинга нужно делать
    POST-запрос. Также в обоих случаях нужно указывать ID пользователя, которого анфолловим или фолловим. Этот параметр
    должен быть числом. Все это указано в API сервера. При помощи cookie-файлов сервер будет определять нас и знать для
    какого пользователя сделать фолловинг или анфолловинг.*/
    follow(id: number) {
        return (
            /*Указываем что добавляется к базовому URL внутри "instance", чтобы сформировать запрос на фолловинг.
            Указываем, что этот POST-запрос возвращает промис с типом "ResponseWithDataType".*/
            instance.post<ResponseWithDataType>(`follow/${id}`)
                /*Метод "then()" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c
                объектом "response". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства
                "response.data". Это свойство "data" создается самим запросом и туда помещается информация от сервера.

                Сама же структура данных в свойстве "data" определяется сервером. Согласно API сервера там находятся:
                1. "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя (0 - все хорошо, 1 -
                какая-то ошибка).
                2. "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                время фолловинга пользователя).
                3. "data" - какие-то дополнительные данные (в данный момент не используется).

                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить фолловинг
                пользователя при помощи TC "follow()".*/
                .then(response => {
                    return response.data;
                })
        );
    }
};