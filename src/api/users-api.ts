/*
Этот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер, касающиеся страницы постраничного
вывода пользователей, чтобы компоненты не создавали "side effects" такого типа. Этот файл отвечает за "DAL" -
"Data Access Layer".
*/

import {instance, ResponseWithDataType, ResponseWithItemsType} from './api'; /*Импортируем "instance" для более быстрого
создания запросов. В добавок импортируем два общих типа "ResponseWithDataType" и "ResponseWithItemsType" для некоторых
ответов от сервера со схожей структурой ответа.*/

import {UserType} from '../types/types'; /*Подключаем типы.*/


export const usersAPI = { /*"usersAPI" содержит запросы, связанные со страницей с постраничным выводом пользователей.*/
    getUsers(currentPage: number, pageSize: number, term: string =  '', friend: null | boolean = null) { /*Эта функция
    является запросом на получение данных пользователей в постраничном выводе. Эти данные на сервере структурированы по
    страницам, поэтому данная функция принимает четыре параметра:
    - "currentPage" - текущая страница для отображения (1 "default"), должно быть числом;
    - "pageSize" - количество пользователей на этой странице (от 10 ("default") до 100), должно быть числом;
    - "term" - фильтр в виде строкового значения, которое будет получать сервер и искать наличие этого значения в именах
    всех пользователей, чтобы в итоге вывести только таких пользователей, по умолчанию указана пустая строка;
    - "friend" - еще один фильтр булева типа или типа "null", если указать в нем "true", то сервер выберет только тех
    пользователей, которых мы фолловим, если указать "false" - только тех, кого мы не фолловим, если указать "null" или
    вообще не указывать, то выберет всех пользователей, по умолчанию указано "null".*/
        return (
            instance.get<ResponseWithItemsType<UserType>>
            (`users?page=${currentPage}&count=${pageSize}&term=${term}` + (friend === null ? '' : `&friend=${friend}`))
            /*Указываем, что добавляем к базовому URL, указанному в "instance", "users", чтобы получить данные
            пользователей. Знак "?" означает, что дальше идут параметры GET-запроса, знак "&" используется для
            перечисления таких параметров. Названия этих параметров и ограничения их значений описываются в API сервера.
            "+ (friend === null ? '' : `&friend=${friend}`" - здесь мы склеиваем строку с пустой строкой, если параметр
            "friend" равен "null", иначе склеиваем со строками `&friend=true` или `&friend=false`, если в параметре
            "friend" указали "true" или "false" соответственно. Также указали, что этот запрос "GET" возвращает промис с
            типом "GetItemsType<UserType>".*/
                .then(response => { /*"then" создает "promise". Какие-то данные придут от сервера и выполниться
                стрелочная функция "response". Данные, которые конкретно будут нужны нам, будут находиться внутри
                "response.data". Это "data" создается самим запросом и туда помещается информация от сервера. Сама же
                структура данных в "data" определяется сервером. Согласно API сервера там находятся:
                - "items" - массив с объектами, которые содержат данные по пользователям.
                Каждый такой объект содержит следуюющее:
                    - "name" - имя пользователя.
                    - "id" - "ID" пользователя.
                    - "photos": - объект с путями к фото пользователя.
                        - "small" - уменьшенное фото.
                        - "large" - увеличенное фото.
                    - "status" - статус пользователя.
                    - "followed" - говорит фолловим ли мы пользователя или нет.
                - "totalCount" - количество всех пользователей.
                - "error" - содержит сообщение об ошибке, если была.*/
                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,
                    чтобы установить их в наш "state" при помощи TC "requestUsers" в "users-reducer.ts".*/
                })
        );
    },

    unfollow(id: number) { /*Эта функция является запросом на анфолловинг какого-либо пользователя. Оба запроса на
    анфолловинг и фолловинг идут на один и тот же "endpoint", только для анфолловинга нужно делать DELETE-запрос,
    а для фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать "ID" пользователя, которого
    анфолловим или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи "Cookie" сервер
    будет определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/
        return (
            instance.delete<ResponseWithDataType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,
            указанному в "instance", "follow" и "ID" пользователя, которого анфолловим, чтобы сформировать запрос на
            анфолловинг. Указали, что этот запрос "DELETE" возвращает промис с типом "ResponseType".*/
                .then(response => { /*"then" создает "promise". Какие-то данные придут от сервера и выполниться
                стрелочная функция "response". Данные, которые конкретно будут нужны нам, будут находиться внутри
                "response.data". Эта "data" создается самим запросом и туда помещается информация от сервера. Сама же
                структура данных в "data" определяется сервером. Согласно API сервера там находятся:
                    - "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя, "0" - все хорошо,
                    "1" - какая-то ошибка.
                    - "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                    время анфолловинга пользователя).
                    - "data" - какие-то дополнительные данные (в данный момент не используется).*/
                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,
                    чтобы осуществить анфолловинг пользователя при помощи TC "unfollow" в "users-reducer.ts".*/
                })
        );
    },

    follow(id: number) { /*Эта функция является запросом на фолловинг какого-либо пользователя. Оба запроса на
    анфолловинг и фолловинг идут на один и тот же "endpoint", только для анфолловинга нужно делать DELETE-запрос, а для
    фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать "ID" пользователя, которого анфолловим
    или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи "Cookie" сервер будет
    определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/
        return (
            instance.post<ResponseWithDataType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,
            указанному в "instance", "follow" и "ID" пользователя, которого фолловим, чтобы сформировать запрос на
            фолловинг. Указали, что этот запрос "POST" возвращает промис с типом "ResponseType".*/
                .then(response => { /*"then" создает "promise". Какие-то данные придут от сервера и выполниться
                стрелочная функция "response". Данные, которые конкретно будут нужны нам, будут находиться внутри
                "response.data". Эта "data" создается самим запросом и туда помещается информация от сервера. Сама же
                структура данных в "data" определяется сервером. Согласно API сервера там находятся:
                    - "resultCode" - код, означающий успешно ли прошло изменение статуса пользователя, "0" - все хорошо,
                    "1" - какая-то ошибка.
                    - "messages" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во
                    время фолловинга пользователя).
                    - "data" - какие-то дополнительные данные (в данный момент не используется).*/
                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,
                    чтобы осуществить фолловинг пользователя при помощи TC "follow" в "users-reducer.ts".*/
                })
        );
    }
};