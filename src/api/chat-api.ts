/*
Это файл, содержащий API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем приложении.
Выносим этот API в отдельный файл для реализации уровня DAL.
*/

import {ChatMessageType} from '../types/types'; /*Подключаем типы.*/


export type SubscriberType = (chatMessages: ChatMessageType[]) => void; /*Создали тип для callback-функции, которая
передается в метод "subscribe" в объекте "chatAPI" ниже. Эта callback-функция ничего не возвращает, но на входе
принимает массив элементов с типом "ChatMessageType", массив с сообщениями из чата.*/


let ws: WebSocket | null = null; /*Объявляем переменную "ws", которая может быть типа "WebSocket" или "null" (то есть
отсутствовать), и которая в дальнейшем будет использоваться для хранения WebSocket-канала.*/

const closeEventHandler = () => { /*Объявляем функцию "closeEventHandler", которая будет вызываться при подписке на
событие "close" в WebSocket-канале, и вызывать функцию "createWSChannel" каждые 3 секунды с целью пересоздания
WebSocket-канала.*/
    setTimeout(createWSChannel, 3000);
};

const messageEventHandler = (e: MessageEvent) => { /*Объявляем функцию "messageEventHandler", которая будет вызываться
при подписке на событие "message" в WebSocket-канале, на входе получать информацию из WebSocket-канала, которая внутри
себя содержит информацию о сообщениях из чата, парсить ее в формат "JSON" при помощи "JSON.parse()", чтобы в дальнейшем
можно было сохранить эту информацию в массиве "newChatMessages" под элементами в виде объектов, после этого сохранять
эту информацию о сообщениях из чата в массиве "newChatMessages". Далее мы пробегаемся по каждому подписчику, то есть по
каждой callback-функции в массиве "subscribers", вызываем каждого подписчика и передаем каждому из них информацию о
сообщениях из чата, чтобы в дальнейшем они установили эту информацию в наш "store".*/
    const newChatMessages = JSON.parse(e.data);

    subscribers.forEach(s => s(newChatMessages));
};

function createWSChannel() { /*Объявляем функцию "createWSChannel".*/
    ws?.removeEventListener('close', closeEventHandler); /*Если имеется WebSocket-канал, то с целью очистки памяти мы
    отписываемся в нем от события "close". Для отписки должны указать ту же функцию, что и указывали при подписке на
    это событие (подписка ниже).*/

    ws?.close(); /*Далее мы вызываем функцию "close()" у WebSocket-канала (если таковой имеется) с целью полного
    закрытия этого WebSocket-канала.*/

    ws = new WebSocket('wss://social-network.samuraijs.com/handlers/ChatHandler.ashx'); /*Далее таким образом
    создаем WebSocket-канал, указав адрес согласно API сервера. Согласно API сервера в ответ мы будем получать объекты,
    которые содержат следующие свойства:
    - "userId" - "ID" пользователя, который отправил сообщение в чат;
    - "userName" - имя пользователя, который отправил сообщение в чат;
    - "photo" - фото пользователя, который отправил сообщение в чат;
    - "message" - сообщение пользователя, которое было отправлено в чат.
    По стандартному HTTP-протоколу клиент делает запросы на сервер, а сервер отправляет ответы клиенту. Чтобы делать
    наоборот нужно применять дополнительные механизмы, например, такие как "SSE" или "WebSocket". "WebSocket" - это в
    каком-то смысле альтернатива протокола "HTTP" (прикладной уровень). "WSS" - это безопасная версия протокола
    "WebSocket", по аналогии с "HTTPS". По протоколу "WebSocket" можно передавать два типа данных: текстовой и бинарный.
    Также нужно помнить, что в браузерах в средствах разработчика нельзя замедлить скорость WebSocket-каналов.*/

    ws.addEventListener('close', closeEventHandler); /*Далее подписываемся на событие "close", при срабатывании
    которого будет вызываться функция "closeEventHandler".*/

    ws.addEventListener('message', messageEventHandler); /*Далее подписываемся на событие "message", при
    срабатывании которого будет вызываться функция "messageEventHandler".*/
};

let subscribers = [] as SubscriberType[]; /*Создаем специальный массив "subscribers", который будет содержать функции
типа "SubscriberType", которые как бы будут подписываться на какие-то изменения и что-то получать при каждом таком
изменении. В нашем случае там будут callback-функции, которые будут подписываться на получение новых сообщений для чата
из WebSocket-канала. Соотвественно после подписки при каждом новом сообщении для чата эти callback-функции будут
вызываться и получать эти новые сообщения, что в дальнейшем мы можем использовать для сохранения этих сообщений на
уровне BLL, то есть в нашем "store". Таким образом реализуется работа между уровнями DAL (WebSocket-канал) и BLL (наш
"store").*/

export const chatAPI = { /*Создаем API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем
приложении.*/
    startWSChannel() { /*Создаем метод "startWSChannel", который будет вызывать функцию "createWSChannel", объявленную
    выше. Этот метод будет использоваться для инициализации WebSocket-канала.*/
        createWSChannel();
    },

    stopWSChannel() { /*Создаем метод "stopWSChannel" для отключения WebSocket-канала (если таковой имеется). При вызове
    этого метода мы очищаем наш массив подписчиков на сообщения из чата, то есть массив "subscribers". Также с целью
    очистки памяти мы отписываемся от событий "close" и "message" в WebSocket-канале (для отписки должны указать ту же
    функцию, что и указывали при подписке на это событие). И в конце мы вызываем функцию "close()" у WebSocket-канала с
    целью полного закрытия этого WebSocket-канала.*/
        subscribers = [];
        ws?.removeEventListener('close', closeEventHandler);
        ws?.removeEventListener('message', messageEventHandler);
        ws?.close();
    },

    subscribe(callback: SubscriberType) { /*При получении сообщения для чата по WebSocket-каналу нам необходимо
    уведомлять об этом уровень BLL, то есть наш "store", чтобы мы могли сохранять эти новые сообщения в нашем "store".
    Для этого здесь мы создаем метод "subscribe", который при вызове будет получать callback-функцию типа
    "SubscriberType". Эта callback-функция должна будет вызываться каждый раз, когда мы получаем новое сообщение для
    чата, и устанавливать это сообщение в "store". При получении такой callback-функции мы добавляем ее в массив
    "subscribers", таким образом как бы подписывая ее на получение новых сообщений для чата из WebSocket-канала.*/
        subscribers.push(callback);

        return () => { /*Также метод "subscribe" возвращает функцию, которую если вызвать снаружи произойдет отписка
        всех подписчиков, то есть в массиве "subscribers" останутся только те элементы, которые не равны подписанной
        callback-функции. В итоге эта callback-функция перестанет реагировать на получения сообщений для чата. Это одна
        из реализаций метода отписки. Но ниже мы создали для этого отдельный метод "unsubscribe".*/
             subscribers = subscribers.filter(s => s !== callback);
        };
    },

    unsubscribe(callback: SubscriberType) { /*Создаем метод "unsubscribe" для отписки подписчиков, то есть
    callback-функций в массиве "subscribers". При вызове этого метода в массиве "subscribers" остануться только те
    элементы, которые не равны подписанной callback-функции. В итоге эта callback-функция перестанет реагировать на
    получения сообщений для чата.*/
        subscribers = subscribers.filter(s => s !== callback);
    },

    sendChatMessage(chatMessage: string) { /*Создаем метод "sendChatMessage", при вызове который получает введенное нами
    сообщения для чата, вызывает функцию "send()" у WebSocket-канала (если таковой имеется) и передает в нее наше
    сообщение для отправки этого сообщения по WebSocket-каналу.*/
        ws?.send(chatMessage);
    }
};