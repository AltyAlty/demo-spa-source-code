/*
Чтобы избавиться от повторяющегося кода в "users-reducer.ts" в "reducer" в "FOLLOW" и "UNFOLLOW", мы создали
этот файл, который содержит общую логику для "FOLLOW" и "UNFOLLOW". При помощи этой логики можно перебирать
элемента (объекты) в любом массиве и менять какое-либо свойство при срабатывании условия у какого-то
элемента (объекта) в этом массиве.
*/


/*
Убрали в этой функции стрелочный синтаксис и типизировали ее следующим образом. Эта функция имеет три уточняющих тип
параметра "T", "K" и "P".

Уточняющий тип параметр "T" указывает какой тип имеют элементы в массиве элементов первого параметра "items" этой
функции. В случае использования этой функции в рамках фолловинга/анфолловинга пользователей это должен быть тип
"UserType", так как первым параметром мы передаем в эту функцию массив объектов с типом "UserType", где каждый объект
представляет из себя информацию о каком-то пользователе. Следовательно, на этот параметр "T" установлено ограничение,
что этот тип должен быть похож на какой-либо объект.

Вторым уточняющим тип параметром "K" мы должны указывать тип ключа из объектов массива из первого уточняющего тип
параметра "T", так как третьим параметром в эту функцию мы передаем "objPropName" - имя свойства в объектах, по которому
идет проверка сравнением, в случае фолловинга/анфолловинга пользователей это строковое значение 'id'. Чтобы получить
ключи объектов с типом "T" мы используем "keyof T". Это выдаст все ключи, например, того же типа "UserType": "name",
"id", "photos", "status", "followed". И опять же, в случае фолловинга/анфолловинга пользователей мы передаем третьим
параметром строковое значение 'id', что будет совпадать с одним из этих полученных ключей. Следовательно, на параметр
"K" установлено ограничение, что это тип должен быть ключами первого параметра "T", то есть "keyof T", и в случае
фолловинга/анфолловинга пользователей мы укажем "keyof UserType".

Вторым параметром в эту функцию мы передаем "itemID" - значение для сравнения при поиске нужного объекта в массив,
в случае фолловинга/анфолловинга пользователей это "ID" пользователя для фолловинга/анфолловинга. Следовательно, его тип
указан как "T[K]", так как опять же в случае фолловинга/анфолловинга пользователей это будет выглядеть как
"UserType['id']", что равно "UserType.id", то есть мы получим значение свойства "id" в объекте с типом "UserType",
который содержит информацию по пользователю, которого мы пытаемся зафолловить или перестать фолловить.

Третьим уточняющим тип параметром "P" мы должны указывать тип объекта (который мы передаем в эту функцию четвертым
параметром "newObjProps") со свойствами и их значениями, который нужно подменить на место старого в найденном объекте, в
случае фолловинга/анфолловинга пользователей мы должны поменять "{followed: false}" на "{followed: true}" для фолловинга
и "{followed: true}" на "{followed: false}" для анфолловинга в найденном объекте с типом "UserType", который содержит
информацию по пользователю, которого мы пытаемся зафолловить или перестать фолловить. Следовательно, четвертый параметр
"newObjProps" в этой функции, опять же, в случае фолловинга/анфолловинга пользователей должен быть одним из свойств
объекта с типом "UserType" - свойством "followed", поэтому на уточняющий тип параметр "P" уставлено ограничение, что он
частично или полностью должен копировать первый уточняющий параметр "T", то есть в случае фолловинга/анфолловинга
пользователей тип "UserType", который как раз содержит свойство "followed". Это мы делаем при помощи "Partial" из
"TypeScript" - "P extends Partial<T>", и в случае фолловинга/анфолловинга пользователей мы укажем "Partial<UserType>".

Также в этой функции указано, что на выходе мы возвращаем массив объектов с типом "T", так как суть этой функции взять
массив каких-то объектов с определенным типом, найти какой-то интересующий нас объект среди этих объектов, у этого
объекта поменять значение какого-то свойство или значения нескольких каких-то свойств, и вернуть снова массив каких-то
объектов с тем же типом, в котором мы изменили какой-то один объект. То есть, в случае фолловинга/анфолловинга
пользователей на входе мы даем "Array<UserType>" и на выходе должны получить "Array<UserType>".
*/
export function updateObjectInArray<T extends {}, K extends keyof T, P extends Partial<T>>
(items: Array<T>, itemID: T[K], objPropName: K, newObjProps: P): Array<T> {
    /*
    "items" - будет получать массив объектов (информация о пользователях для постраничного вывода из "state"
    для "FOLLOW" и "UNFOLLOW").
    "itemID" - значение для сравнения при поиске нужного объекта в массиве ("ID" пользователя для
    фолловинга/анфолловинга из объекта "action" для "FOLLOW" и "UNFOLLOW").
    "objPropName" - имя свойства в объектах, по которому идет проверка сравнением ('id' для "FOLLOW" и "UNFOLLOW").
    "newObjProps" - объект со свойствами и их значениями, который нужно подменить на место старого в найденном объекте
    ("{followed: true}" для фолловинга и "{followed: false}" для анфолловинга для "FOLLOW" и "UNFOLLOW").
    */
    return items.map(u => { /*Мапим полученный массив объектов. "u" - это каждый элемент массива. Метод "map" возвращает
    новый массив в итоге на основе полученного массива.*/
        if (u[objPropName] === itemID) { /*(Вспомним, что "u.id" и "u["id"]" это одно и тоже) Если у какого-либо
        элемента (объекта, содержащего информацию о пользователе для постраничного вывода в случае для "FOLLOW" и
        "UNFOLLOW") массива указанное свойство "objPropName" ("u.id", то есть "ID" пользователя в случае для "FOLLOW" и
        "UNFOLLOW") равно значению для сравнения "itemID" (из объекта "action" там будет "ID" пользователя для
        фолловинга/анфолловинга для "FOLLOW" и "UNFOLLOW"),*/
            return {...u, ...newObjProps} /*то делаем деструктуризацию этого элемента (объекта, содержащего информацию о
            пользователе для постраничного вывода в случае для "FOLLOW" и "UNFOLLOW") и подменяем ему указанное свойство
            со значением в "newObjProps" за место старого значения этого свойства ("{followed: true}" для фолловинга и
            "{followed: false}" для анфолловинга для "FOLLOW" и "UNFOLLOW").*/
        };

        return u; /*Если же условие выше не срабатывает, то "map" вернет элемент массива как есть.*/
    }); /*В итоге "map" соберет новый массив с теми же объектами, где у одного из них измениться значение одного из
    свойств ("{followed: true}" для фолловинга и "{followed: true}" для анфолловинга для "FOLLOW" и "UNFOLLOW")*/
};