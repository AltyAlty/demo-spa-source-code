import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Это прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC (ХОК) - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/

import MyPosts from './MyPosts'; /*Подключаем компонент "MyPosts".*/

import {profileAC} from '../../../redux/profile-reducer'; /*Подключаем объект "profileAC", что использовать оттуда АC
"addPostActionCreator" из "profile-reducer".*/


/*
"MyPostsContainer" это не классовый компонент и не функциональный компонент.
"MyPostsContainer" является только контейнерным компонентом для компонента "MyPosts".
В отличии от классового компонента, этот компонент не имеет методов жизненного цикла.
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.js") из библиотеки "react-redux".
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
Этот компонент подключается в компоненте "App".
В этом компоненте мы просто создаем "mapStateToProps" и "mapDispatchToProps", тем самым формируя "props"
для презентационной компоненты "MyPosts". Поэтому нам не нужно создавать классовый компонент для этого.
Таким же образом созданы контейнерные компоненты "NavbarContainer", "DialogsContainer".
*/

const mapStateToProps = (state) => { /*Здесь указываются данные из "state", которые необходимо передать
в компонент "MyPosts". Эта функция возвращает указанные данные в виде объекта.*/
    return {
        postsData: state.profilePage.postsData /*Данные о постах на странице пользователя.*/
    }
};

const mapDispatchToProps = (dispatch) => { /*Здесь указываются данные (callbacks - "AC" или "TC") "dispatch",
которые необходимо передать в компонент "MyPosts". Эта функция возвращает указанные данные в виде объекта.
Функция "mapDispatchToProps" работает следующим образом:
1) Компонент вызывает через callback функцию "addPost".
2) Компонент передает этой функции параметр "newPostText".
3) Далее этот параметр передается в AC "addPostActionCreator".
4) Этот AC вызывается.
5) Создается объект "action".
6) Этот объект "action" диспатчится в "dialogsReducer" в "profile-reducer.js".*/
    return {
        addPost: (newPostText) => {
            dispatch(profileAC.addPostActionCreator(newPostText));
        }
    }
};

export default connect(mapStateToProps, mapDispatchToProps)(MyPosts);
/*
При помощи метода "connect" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL
компоненту "MyPosts". Экспортируем получившийся в итоге компонент, который будет использоваться под именем
"MyPostsContainer", по default, экспорт необходим для импорта.
*/