import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Это прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/

import MyPosts from './MyPosts'; /*Подключаем компонент "MyPosts".*/

import {profileAC} from '../../../redux/profile-reducer';/*Подключаем объект "profileAC", что использовать оттуда АC
"addPostActionCreator" из "profile-reducer".*/

import {PostType} from '../../../types/types'; /*Подключаем типы.*/
import {AppStateType} from '../../../redux/redux-store'; /*Подключаем типы.*/


/*Создаем тип для "MapStateToProps". "MapStateToProps" в этом компоненте должен обязательно содержать следующие поля с
указанными типами.*/
type MapStateToPropsType = {
    postsData: Array<PostType> /*Данные о постах на странице пользователя должны быть массивом с элементами с типом
    "PostType". Тип "PostType" был создан нами и импортирован сюда.*/
};

/*Создаем тип для "MapDispatchToProps". "MapDispatchToProps" в этом компоненте должен обязательно содержать следующие
поля с указанными типами.*/
type MapDispatchToPropsType = {
    addPost: (newMessageText: string) => void /*AC для добавления нового поста на странице профиля, который принимает
    строковой параметр и ничего не возвращает.*/
};


/*
"MyPostsContainer" это не классовый компонент и не функциональный компонент.
"MyPostsContainer" является только контейнерным компонентом для компонента "MyPosts".
В отличии от классового компонента, этот компонент не имеет методов жизненного цикла.
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.tsx") из библиотеки "react-redux".
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
Этот компонент подключается в компоненте "App".
В этом компоненте мы просто создаем "mapStateToProps" и "mapDispatchToProps", тем самым формируя "props"
для презентационной компоненты "MyPosts". Поэтому нам не нужно создавать классовый компонент для этого.
Таким же образом созданы контейнерные компоненты "NavbarContainer", "DialogsContainer".
*/


const mapStateToProps = (state: AppStateType): MapStateToPropsType => { /*Здесь указываются данные из "state", которые
необходимо передать в компонент "MyPosts". Эта функция возвращает указанные данные в виде объекта. На входе
"mapStateToProps" принимает "state" с типом "AppStateType", который мы создали и импортировали сюда, а на выходе выдает
данные с типом "MapStateToPropsType".*/
    return {
        postsData: state.profilePage.postsData /*Данные о постах на странице пользователя.*/
    }
};


export default connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps,
    {addPost: profileAC.addPost} /*При помощи метода "connect" создаем контейнерный
        компонент, и тем самым передаем нужные данные BLL и DAL компоненту "MyPosts". Поскольку метод "connect"
        является "generic", то его можно уточнить: первым в "<>" указан тип для "MapStateToProps", вторым для
        "MapDispatchToProps", третьим для "собственных props" компонента, четвертым для "state". Эти параметры мы узнали
        перейдя в файл декларации метода "connect", "Ctrl+click" в "WebStorm".*/
)(MyPosts);
/*При помощи метода "connect" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL компоненту
"MyPosts". Экспортируем получившийся в итоге компонент, который будет использоваться в нашем проекте под именем
"MyPostsContainer", по default, экспорт необходим для импорта.*/