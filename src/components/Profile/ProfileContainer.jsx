import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Это прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC (ХОК) - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/
import {compose} from 'redux';
/*
Функция "compose" из функционального программирования. Эта функция создает композицию обработчиков.
Библиотека "redux" содержит свою реализацию "compose". При помощи функции "compose" можно объеденять, например,
несколько обверток вокруг компонента и ХОКи.
Обвертки и ХОКи указываются снизу вверх. Функция "compose" вызывается дважды и работает схожим образом, как и метод
"connect" из библиотеки "react-redux".
*/
import {withRouter} from 'react-router-dom';
/*
Библиотека "react-router-dom" необходима для создания роутинга и маршрутов в приложении.
Функция "withRouter" это HOC.
HOC (ХОК) - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Поскольку URL тоже является источником данных, то компоненту иногда могут понадобиться эти данные.
Чтобы их получить, можно воспользоваться "withRouter".
HOC "withRouter" принимает в качестве параметра компонент и передает ему через "props" данные из URL, чтобы компонент
знал где он находиться - т.е. какой у него маршрут.
Если подключить на самом высоком уровне дерева компонентов этот HOC, например, в "App.js", то данные URL будут доступны
и в дочерних компонентах.
То есть здесь можно было и не указывать HOC "withRouter".
При использовании "connect" роутинг сбивается. Чтобы решить эту проблемы мы обварачиваем "connect" при помощи
"withRouter". Но сейчас вроде и без этого все работает.
*/

import Profile from './Profile'; /*Подключаем компонент "Profile".*/

import {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC "withAuthRedirect"
для добавления редиректа. В данный момент не используется.*/

import {
    getUserProfile, /*Подключаем TC "getUserProfile" из "profile-reducer".*/
    getUserStatus, /*Подключаем TC "getUserStatus" из "profile-reducer".*/
    saveProfile, /*Подключаем TC "saveProfile" из "profile-reducer".*/
    saveUserPhoto, /*Подключаем TC "saveUserPhoto" из "profile-reducer".*/
    updateUserStatus /*Подключаем TC "updateUserStatus" из "profile-reducer".*/
} from '../../redux/profile-reducer';


/*
"ProfileContainer" это классовый компонент.
Классы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать
концепцию ООП.
React определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать
с этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно
взаимодействует.
Например, у него можно постоянно запрашивать JSX.
В React при создании класса мы наследуем и расширяем некий базовый класс "React.Component" при помощи "extends".
Компонент это функция, которая возвращает JSX.
Классовые компоненты могут содержать "side effects". Для этого используются методы жизненного цикла.
У классового компонента всегда есть метод render(){...}, который возвращает JSX.
При переходе по разным "Route" экземпляры классовых компонентов удаляются из памяти.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileContainer" является контейнерным компонентом для компонента "Profile".
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.js") из библиотеки "react-redux".
Этот компонент подключается в компоненте "App".
*/
class ProfileContainer extends React.Component {
    refreshProfile() { /*Создаем специальный метод, который содержит необходимый функционал для обновления
    страницы профиля.*/
        let userID = this.props.match.params.userID; /*Получаем "ID" пользователя. HOC "withRouter" хранит некий объект,
        к которому можно обратиться как к "match.params.userID", чтобы получить значения
        дополнения ":userID" к пути "/profile/", как это указано у нас в компоненте "App".*/

        if (!userID) { /*Если не удалось получить "ID" пользователя, то*/
            userID = this.props.authUserID; /*пытаемся его получить от пользователя, под которым залогинены,*/
            if (!userID) { /*а если же и после этого не удалось получить "ID" пользователя, то*/
                this.props.history.push("/login/") /*нас перенаправляет на страницу логирования.*/
            }
        }

        /*Если же мы все-таки получили "ID" пользователя, то делаем следующее:*/
        this.props.getUserProfile(userID); /*вызываем TC "getUserProfile" для получения данных профиля пользователя и
        их установки на странице профиля.*/
        this.props.getUserStatus(userID); /*вызываем TC "getUserStatus" для получения данных статуса пользователя и
        их установки на странице профиля.*/
    };

    componentDidMount() { /*Это метод жизненного цикла классового компонента. Он вызывается в момент первой
    отрисовки (монтирования) компонента.*/
        this.refreshProfile(); /*Вызываем метод "refreshProfile".*/
    };

    componentDidUpdate(prevProps, prevState, snapshot) { /*Это метод жизненного цикла
    классового компонента. Он вызывается в момент обновления (изменения "props" или "state") компонента.*/
        if (this.props.match.params.userID !== prevProps.match.params.userID) { /*Проверяем изменился ли "ID"
        пользователя в "props". Эта проверка нужна, чтобы избежать бесконечный цикл запроса новых "props" методом
        "refreshProfile": изначально срабатывает метод "refreshProfile" из "componentDidMount", получает новые "props",
        в свою очередь это триггерит метод "refreshProfile" из "componentDidUpdate", снова получаем новые "props" и
        снова триггерим метод "refreshProfile" из "componentDidUpdate" и так до бесконечности.*/
            this.refreshProfile(); /*Если изменился, то вызываем метод "refreshProfile".*/
        }
    };

    render() {
        /*
        Здесь после return в компоненте начинается HTML разметка.
        Нужно помнить, что в этой разметке должен быть только один корневой элемент.
        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
        */
        return (
            <Profile {...this.props} /*Отрисовываем компонент "Profile" и передаем ему через "props" необходимые для
            него данные. Этот элемент "Profile" и есть наш корневой элемент. Здесь используется spread-оператор "...",
            который из всех "props" создает атрибуты для компонента.*/
                     isOwner={!this.props.match.params.userID} /*Свойство, которое показывает является ли залогиненный
                     пользователь владельцем профиля, который в данный момент отображается на странице профиля. Будет
                     равно "TRUE", если в данных URL не было найдено значения дополнения ":userID" к пути "/profile/",
                     как это указано у нас в компоненте "App", т.е. пользователь совершил переход просто на "/profile/",
                     желая попасть на свою страницу, а не на чью-то другую. Это свойство нужно, чтобы интерфейс для
                     редактирования информации в профиле появлялся только на собственной странице пользователя. Хотя
                     тут есть проблема, когда мы переходим на свой профиль при помощи своего "ID" и не имеем
                     упомянутого интерфейса. Далее передается в компонент "ProfileInfo".*/
            />
        )
    }
};

const mapStateToProps = (state) => ({ /*Здесь указываются данные из "state", которые необходимо передать
в компонент "ProfileContainer". Эта функция возвращает указанные данные в виде объекта.*/
    profile: state.profilePage.profile, /*Данные профиля пользователя для страницы профиля. Далее передается в
    компонент "ProfileInfo".*/
    status: state.profilePage.status, /*Данные статуса пользователя для страницы профиля. Далее передается в
    компонент "ProfileInfo".*/
    authUserID: state.auth.id, /*"ID" залогиненного пользователя.*/
});

export default compose( /*При помощи функции "compose" объеденяем ХОКи "withRouter", "withAuthRedirect" и "connect",
возвращая итоговый компонент "AppContainer".*/
    connect(mapStateToProps, {/*При помощи метода "connect"
    создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL в другой контейнерный
    компонент "ProfileContainer" из этого файла.*/
        getUserProfile, /*TC для получения данных профиля пользователя и их установки на странице профиля.*/
        getUserStatus, /*TC для получения данных статуса пользователя и их установки на странице профиля.*/
        updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/
        saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем
        приложении.*/
        saveProfile}), /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их
        отображения в нашем приложении.*/
    withRouter, /*Так же при помощи метода "withRouter" передаем в этот контейнерный компонент данные из URL.*/
    //withAuthRedirect /*При помощи ХОКа "withAuthRedirect" добавляем логику по редиректу в компонент.*/
)(ProfileContainer);
/*
Получившийся в итоге компонент экспортируем, который будет использоваться под именем "ProfileContainer", по default,
экспорт необходим для импорта.
*/