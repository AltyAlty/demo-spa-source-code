import React, {ChangeEvent} from 'react';

type PropsType = {
    /*Данные статуса пользователя, полученные с сервера, должны быть строкой.*/
    status: string
    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент
    отображается на странице профиля, должно быть булева типа.*/
    isOwner: boolean
    /*TC для изменения данных по статусу пользователя на странице профиля должен быть функцией, которая принимает
    строковой параметр и ничего не возвращает.*/
    updateUserStatus: (status: string) => void
};

/*Создаем тип для локального state.*/
type StateType = {
    /*Значение, которое определяет включен ли режим редактирования статуса пользователя или нет, должно быть булева
    типа.*/
    editMode: boolean
    /*Данные статуса пользователя, установленные в локальном state, должны быть строкой.*/
    status: string
};

/*"ProfileStatus" это классовый компонент. "ProfileStatus" является компонентом, который предоставляет реализацию
статуса пользователя на странице пользователя. Статус пользователя представляет собой поле статуса как в ВК, на который
можно нажать и активировать поле для ввода статуса, а если убрать фокус с этого поля, то будет просто текст.

Компонент "ProfileStatus" импортируется в файле "ProfileInfo.tsx".*/
export class ProfileStatus extends React.Component<PropsType, StateType> {
    /*Локальный state это дополнение к глобальному state. Такой state может использоваться для данных, которые
    необходимы для работы приложения, но не относятся к бизнес-данным (например, временные данные или UI-данные). Любой
    компонент может определить свой локальный state. Работать такой компонент будет по знакомому способу: если компонент
    что-то изменит в локальном state, то он перерисуется. Для этого нужно использовать классовый компонент, поскольку
    React при работе с таким компонентом создает объект, в котором можно хранить локальный state.*/
    state = {
        /*Значение, которое определяет включен ли режим редактирования статуса пользователя или нет.*/
        editMode: false,
        /*Значение, которое будет хранить информацию о статусе пользователя, полученную с сервера. Берется из props.*/
        status: this.props.status
    };

    /*Создаем метод, при вызове которого будет активироваться режим редактирования статуса пользователя. Этот метод
    будет использоваться в обработчике событий как callback-функция.*/
    activateEditMode = () => {
        /*При помощи метода "setState()" из React работаем с локальным state. Вместо этого метода можно было
        использовать метод "forceUpdate()" для того, чтобы заставить React перерисовать компонент, но так делать
        нежелательно. Метод "setState()" асинхронный. В метод "setState()" нужно передать объект, свойства которого
        перезапишут свойства в локальном state, он не удалит все свойства локального state, а только заменит указанные.
        Ранее нужно было использовать классический способ создания метода: "activateEditMode () {...};", так как при
        использовании стрелочной функции debugger не видел контекста this, а также приходилось использовать метод
        "bind()" для привязки этого контекста, но на данный момент эта проблема решена в React.*/
        this.setState({
            /*Указываем, что включили режим редактирования статуса пользователя.*/
            editMode: true,
            /*Получаем информацию о статусе пользователя из props.*/
            status: this.props.status
        });
    };

    /*Создаем метод, при вызове которого будет деактивироваться режим редактирования статуса пользователя. Этот метод
    будет использоваться в обработчике событий как callback-функция.*/
    deactivateEditMode = () => {
        /*Указываем, что выключили режим редактирования статуса пользователя.*/
        this.setState({editMode: false});
        /*При помощи TC "updateUserStatus()" для изменения статуса пользователя на странице профиля, полученного из
        props, обновляем значение статуса пользователя в глобальном state (но не в локальный state, для этого мы создали
        метод "onUserStatusChange()" ниже).*/
        this.props.updateUserStatus(this.state.status);
    };

    /*Создаем метод "onUserStatusChange()", который будет вызываться при изменении поля "input", брать текущее значение
    содержимого этого поля и сохранять его в локальный state. Для события "event" указываем тип
    "ChangeEvent<HTMLInputElement>".*/
    onUserStatusChange = (event: ChangeEvent<HTMLInputElement>) => {
        this.setState({status: event.currentTarget.value});
    };

    /*Это метод жизненного цикла классового компонента. Он вызывается в момент обновления (изменения props или state)
    классового компонента. Указываем, что предыдущие props в этом классовом компоненте имеют тип "PropsType", а
    предыдущий state имеет тип "StateType".*/
    componentDidUpdate(prevProps: PropsType, prevState: StateType) {
        /*Если значение статуса из новых props не равно значению статуса из предыдущих props, то только в этом случае
        обновляем значение статуса в локальном state. Эта проверка нужна для избежания бесконечного цикла: после прихода
        новых props будут сразу обновляться данные локального state, что заставит перерисоваться компонент, а при
        перерисовке снова сработает метод жизненного цикла классового компонента "componentDidUpdate()" и локальный
        state снова изменится, что снова заставит перерисоваться компонент. В итоге весь этот код помогает нам
        синхронизировать глобальный state и локальный state, чтобы не было таких случаев, когда если сразу после
        загрузки страницы профиля перейти в режим редактирования статуса и получить пустое поле (но у меня не было по
        какой-то причине этой проблемы изначально).*/
        if (prevProps.status !== this.props.status) {
            this.setState({status: this.props.status});
        }
    };

    /*Создаем специальный метод "handleFocus()" для автоматического выделения текста в поле статуса пользователя. Для
    события "event" указываем тип "ChangeEvent<HTMLInputElement>".*/
    handleFocus = (event: ChangeEvent<HTMLInputElement>) => { event.target.select() };

    render() {
        return (
            <>
                {/*Если режим редактирования статуса пользователя отключен и мы являемся владельцем страницы, то
                отрисуется элемент "div", внутри которого будет элемент "span", содержащий обработчик события
                "onDoubleClick" - двойного нажатия по элементу. При срабатывании этого события активируется метод
                "activateEditMode()" как callback-функция, чтобы активировать режим редактирования статуса пользователя.
                Внутри элемента "span" будет отображаться текущее значение статуса пользователя из props, а при его
                отсутствии будет надпись "Enter your status". Если мы же не являемся владельцем профиля, то мы не сможем
                перейти в режим редактирования, только увидеть сам статус. Здесь есть небольшая проблема - после ввода
                нового статуса какое-то время будет отображен старый статус, пока не завершится запрос на сервер на
                изменение этого статуса. Одним из вариантов решений этой проблемы может быть добавление
                компонента-заглушки "Preloader" на время пока идет запрос.*/}
                {!this.state.editMode &&
                    <div>
                        {this.props.isOwner
                            ? <div><b>Status</b>: <span
                                onDoubleClick={this.activateEditMode}>{this.props.status || 'Enter your status'}
                            </span>
                            </div>
                            : <span>{this.props.status || ''}</span>
                        }
                    </div>
                }

                {/*Если режим редактирования статуса пользователя включен, то отрисуется элемент "div", внутри которого
                будет элемент "input", содержащий обработчик события "onBlur" - потери фокуса с элемента . При
                срабатывании этого события активируется метод "deactivateEditMode()" как callback-функция, чтобы
                деактивировать режим редактирования статуса пользователя и сохранить новый статус в глобальном state.
                Также у элемента "input" указан атрибут "autoFocus" для автоматического фокуса на элементе. Внутри
                элемента "input" благодаря атрибуту "value" из локального state будет отображаться текущее значение
                статуса пользователя. Также внутри элемента "input" содержится обработчик события "onFocus" - появления
                фокуса на элементе, при срабатывании которого активируется метод "handleFocus()" как callback-функция,
                чтобы автоматически выделить текст статуса пользователя. Еще внутри элемента "input" содержится
                обработчик события "onChange" - изменения поля "input", при срабатывании которого активируется метод
                "onUserStatusChange()" как callback-функция, чтобы брать текущее значение содержимого этого поля и
                сохранять его в локальный state.*/}
                {this.state.editMode &&
                    <div>
                        <input onChange={this.onUserStatusChange}
                               onFocus={this.handleFocus}
                               autoFocus={true}
                               onBlur={this.deactivateEditMode}
                               value={this.state.status}/>
                    </div>
                }
            </>
        );
    };
};