import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {reduxForm} from 'redux-form';
/*
Библиотека "redux-form" нужна для работы с формами.
Эта библиотека добавляет в "store", то есть в глобальный "state" свой "reducer" и
обрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы
организации данных форм в "state".
Эта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,
является общаться со своей частью в "reducer".
Эта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, "react-final-form",
который работыет на хуках. Так же может подойти "formik".
Эта библиотека, добавляя свою часть в глобальный "state", обязуется заниматься круговоротом данных (FLEX) со всеми
формами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть "state", которую создает эта библиотека,
не является по сути данными, относящимися к BLL, но при этом находятся в глобальном "state".
Также эта библиотека упрощает создание валидации форм, так как в ее "state" есть полезные для этого данные (поля и
свойства).
Так же стоит помнить, что дефолтное поведение кнопки при "submit" это отправка данных на сервер,
что является индикатором для перерисовки в React.
После создания части в глобальном "state", нужно необходимые формы обварачивать в HOC "reduxForm" из библиотеки
"redux-form" (как и метод "connect", метод "reduxForm" не совсем является HOC, он вызывается дважды, сначала мы
вызываем функцию "reduxForm" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания
мы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет
диспатчить и общаться с глобальным "state").
Каждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой "redux-form".
Вместо "input" необходимо использовать "Field" из библиотеки "redux-form". Указывая в нем атрибут "component", мы
указываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо
указывать атрибут "name", чтобы дать имя отправляемым через этот "input" данным. Библиотека "redux-form" будет
реагировать на эти атрибуты "name" и осуществлять круговорот данных.

Для получения данных при "submit" есть особый callback "handleSubmit" в "props", который создается при обворачивании
"reduxForm". В форме в событии "onSubmit" нужно указывать этот callback. В этом callback отключено дефолтное поведение
по перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается
"props.onSubmit()" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот
объект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,
срабатывающий при событии "onSubmit". Этот некий метод будет использоваться для передачи данных формы во внешний мир,
то есть в глобальный "state".

То есть в нашем случае происходит следующее:
- callback "handleSubmit" указан в компоненте "ProfileDataForm".
- обворачиваем компонент "ProfileDataForm" HOC-ом "reduxForm" в компоненте "ProfileDataFormReduxForm", тем самым
предоставляя callback "handleSubmit" для компонента "ProfileDataForm".
- компонент "ProfileDataFormReduxForm" указывается в компоненте "ProfileInfo" в файле "ProfileInfo.jsx", куда в
событие "onSubmit" будет попадать объект с данными, сформированный в событии "onSubmit" при помощи
callback "handleSubmit" в компоненте "ProfileDataForm".

То есть при срабатывании события "onSubmit" сначала вызывается callback "handleSubmit" в компоненте "ProfileDataForm",
который собирает все данные из формы и помещает их в объект, потом внутри callback "handleSubmit" вызывается нами
созданный callback "onSubmit" (доступен из контейнерного компонента "ProfileDataFormReduxForm") из компонента
"ProfileInfo" в файле "ProfileInfo.jsx", в который передается указанный объект с данными и собираются в одном месте,
потом эти данные передаются в компонент "ProfileDataFormReduxForm", из которого перенаправляются в глобальный "state"
в виде объекта под именем "editProfile".

То есть общая логика при работе с библиотекой "redux-form" такова:
- вынести саму форму в отдельный компонент;
- повесить callback "handleSubmit" в качестве обработчика события "onSubmit" в этой форме;
- в этой форме вместо элементов "input" и прочего используем элемент "Field";
- обворачиваем эту форму HOC-ом "reduxForm".
*/

import {createField, Input, Textarea} from '../../common/FormsControls/FormsControls'; /*Подключаем созданный нами
компонент "Textarea" для создания элемента "textarea" с возможностью указывать валидацию. Также подключаем созданный
нами компонент "Input" для создания элемента "input" с возможностью указывать валидацию. Также импортируем функцию
"createField", которая принимает параметры и создает элементы формы. Мы ее используем для создания формы
в компоненте "ProfileDataForm".*/

import style from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/
import styles from '../../common/FormsControls/FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/


/*
"ProfileDataForm" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileDataForm" является компонентом, который представляет из себя форму для редактирования профиля пользователя
на странице профиля в виде заготовки для обворачивания ее в HOC "reduxForm".
Этот компонент подключается в компоненте "ProfileDataFormReduxForm" и обварачивается там в HOC "reduxForm", тем самым
получая callback "handleSubmit".
*/
const ProfileDataForm = ({ /*Указываем какие именно "props" мы получаем, чтобы не писать далее "props.handleSubmit",
"props.profile" и так далее. Такое мы делаем только в функциональных компонентах.*/
                             handleSubmit, /*Callback для сабмита данных.*/
                             profile, /*Данные профиля пользователя для страницы профиля.*/
                             error /*Свойство, содержащее текст ошибки (если была). Свойство "error" будет в объекте
                             "props" благодаря библиотеке "redux-form", в него подцепится значение из TC "saveProfile"
                             из "profile-reducer.ts".*/
}) => {
    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <form onSubmit={handleSubmit}> {/*Здесь в элементе "form "в событии "onSubmit" указывает
        callback "handleSubmit". Этот элемент "form" и есть наш корневой элемент"*/}
            <div> {/*Создаем специальный элемент "div", внутри которого будет находится элемент "button", который будет
            использоваться как кнопка для сабмита данных введенных в форму.*/}
                <button>save</button>
            </div>

            {error && <div className={styles.formSummaryError}>{error}</div>} {/*Если произошла какая-то ошибка, то
            выведем ее в отдельном элементе "div". Свойство "error" будет в объекте "props" благодаря
            библиотеке "redux-form", в него подцепится значение из TC "saveProfile" из "profile-reducer.ts".*/}

            <div> {/*Этот элемент "div" содержит поле для ввода полного имени пользователя.*/}
                <b>1. Full Name</b>:
                {createField("Full Name", "fullName", Input, [])}
                {/*Создали поле для ввода полного имени пользователя на основе импортированной функции "createField".*/}
            </div>

            <div> {/*Этот элемент "div" содержит поле для ввода информации о пользователе "Обо мне".*/}
                <b>2. About Me</b>:
                {createField("About Me", "aboutMe", Input, [])}
                {/*Создали поле для ввода информации о пользователе "Обо мне" на основе импортированной
                функции "createField".*/}
            </div>

            <div> {/*Этот элемент "div" содержит поля для ввода контактов пользователя. Создаются эти поля
            следующим образом (аналогично как и в компоненте "ProfileData" из файла "ProfileInfo.jsx"):*/}
                <b>3. Contacts</b>: {Object.keys(profile.contacts).map(key => { /*При помощи метода "keys" глобального
                объекта "Object" мы можем проитерироваться по ключам переданного объекта "profile.contacts". Возьмутся
                все ключи "key" и завернутся в массив строк. А далее мы мапим этот массив, чтобы отрисовать JSX с
                однотипным полями контактов при помощи небольшого куска JSX (в компоненте "ProfileData" из
                файла "ProfileInfo.jsx" для такого JSX мы создавали вспомогательную компоненту "Contact").*/
                return (
                    <div key={key} className={style.contact}> {/*Отрисовываем элемент "div", который представляет
                    из себя типовое поле для указания контакта. При использовании метода "map" нужно указывать
                    атрибут "key" для избежания ошибок.*/}
                        <b>{key}: {createField(key, "contacts." + key, Input, [])}</b>
                        {/*Внутри этот элемент "div" будет из себя представлять следующее:
                         "Текст заголовка поля контакта": "Текст со значение самого контакта". Первое будет браться
                         из ключа "key". Второе будет создаваться на основе импортированной функции "createField".
                         "name" во втором будет получаться так: к тексту "contacts." будет прибавляться текст ключа
                         (например, "github"), что в итоге будет давать правильную структуру контактов (например,
                         "contacts.github") для составления объекта с контактами, который сможет понять сервер
                         при получении объекта с данным по профилю пользователя.*/}
                    </div>
                )
            })}
            </div>

            <div> {/*Этот элемент "div" содержит поле для указания ищет ли в данный момент работу пользователь.*/}
                <b>4. Is looking for a job?</b>
                {createField("", "lookingForAJob", Input, [], {type: "checkbox"})}
                {/*Создали поле для указания ищет ли в данный момент работу пользователь на основе импортированной
                функции "createField".*/}
            </div>

            <div> {/*Этот элемент "div" содержит поле для ввода работы, которую ищет пользователь.*/}
                <b>Which one?</b>
                {createField("Which one?", "lookingForAJobDescription", Textarea, [])}
                {/*Создали поле для ввода работы, которую ищет пользователь, на основе импортированной
                функции "createField".*/}
            </div>
        </form>
    )
};

/*Это отдельный контейнерный компонент, цель которого обвернуть компонент "ProfileDataForm" в HOC "reduxForm", чтобы
предоставить callback "handleSubmit". Именно компонент "ProfileDataFormReduxForm" будет заниматься общением
с глобальным "state". Далее этот компонент используется в компоненте "ProfileInfo" в файле "ProfileInfo.jsx" */
const ProfileDataFormReduxForm = reduxForm({
    form: 'editProfile' /*Это то самое уникальное имя для данных этой формы, которые будут попадать
    в глобальный "state".*/
})(ProfileDataForm);

export default ProfileDataFormReduxForm; /*Экспортируем компонент "ProfileDataFormReduxForm" по default, экспорт
необходим для импорта.*/