import React, {ChangeEvent, useState} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".

Классовый компонент позволяет реализовать локальный "state" (смотри "ProfileStatus") и методы
жизненного цикла ("componentDidMount" и т.д.), а функциональный компонент этого не может делать.
Такие возможности классового компонента были созданы благодаря тому, что "React" на основе класса
создает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может
хранить такие вещи как "state" и методы. Функция же просто вызывается и возвращает "JSX", постоянное
общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала
и удалилась. Для решения этой проблемы в функциональных компонентах были созданы "Hooks" (хуки).
"Hook" - это функция, которая может делать side effects.
"React" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и
этой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента
"React" запоминает эту информацию где-то на своей стороне, а не внутри объекта.
Хуки нельзя писать в условиях и циклах, так как это нарушает порядок хуков, который является важным.
Можно писать свои кастомные хуки.

Подключаем хук "useState", который возвращает массив с двуми элементами. Первый элемент - это значение,
которое хранится в "state". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя
первый элемент мы заставляем "React" перерисовывать функциональный компонент.
Хук "useState" работает асинхронно, то есть если мы изменяем какое-либо значение при помощи этого хука, то мы говорим,
чтобы "ReactJS" изменил это значение как только сможет, не обращая внимание на порядок соседних инструкций рядом с
кодом, где мы меняем какое-то значение из локального "state".
Нужно помнить, что если наш JSX в компоненте не зависит от хука "useState", то нежелательно хранить какие-то данные в
таком хуке "useState".
При вызове нескольких вторых элементов из нескольких хуков "useState" в асинхронных операциях (например, в запросах на
сервер), нужно обращать внимание на порядок этих вторых элементов из нескольких хуков "useState".

"ChangeEvent" импортировали для типизации событий.
*/

import styles from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/
import userPhoto from '../../../assets/images/user.png'; /*Импортируем из ассетов аватар на случай, если у пользователя
нет фото.*/
import profileLogoSource from '../../../assets/images/profilelogo.jpg'; /*Импортируем из ассетов лого для страницы
профиля.*/

import {Preloader} from '../../common/Preloader/Preloader'; /*Подключаем компонент "Preloader".*/
import ProfileStatus from './ProfileStatus'; /*Подключаем компонент "ProfileStatus", но в данный момент
не используется (аналог компонента "ProfileStatusWithHooks", но без хуков).*/
import ProfileStatusWithHooks from './ProfileStatusWithHooks'; /*Подключаем компонент "ProfileStatusWithHooks".*/
import ProfileDataReduxForm, {ProfileDataFormValuesType} from './ProfileDataForm'; /*Подключаем компонент
"ProfileDataFormReduxForm". Так же импортируем оттуда тип "ProfileDataFormValuesType".*/

import {ContactsType, ProfileType} from '../../../types/types'; /*Подключаем типы.*/


/*Создаем общий тип для всех "props" компонента "ProfileInfo". Все это нужно для указания типа "props" в функциональном
компоненте "ProfileInfo".*/
type ProfileInfoPropsType = {
    profile:ProfileType | null /*Информация о профиле пользователя, полученная с сервера должна быть типа "PostType"
    или иметь тип "null", то есть быть пустой. Тип "PostType" был создан нами и импортирован сюда.*/
    status: string | null /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип "null",
    то есть быть пустыми.*/
    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в
    данный момент отображается на странице профиля, должно быть булева типа.*/
    updateUserStatus: (status: string) => void /*TC для изменения данных по статусу пользователя на странице профиля
    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/
    saveUserPhoto: (photoFile: File) => void /*TC для загрузки фото пользователя на странице профиля и дальнейшего его
    отображения в нашем приложении должен быть функцией, которая принимает объект с фото пользователя, которое типа
    "File" из "TypeScript" и ничего не возвращает.*/
    saveProfile: (profile: ProfileType) => Promise<any> /*TC для отправки новых данных профиля пользователя на странице
    профиля и дальнейшего их отображения в нашем приложении должен быть функцией, которая принимает объект типа
    "ProfileType" и возвращает какой-либо промис, так как мы здесь используем "then." вместе с этим TC.*/
};

/*Создаем тип для "props" компонента "ProfileData".*/
type ProfileDataPropsType = {
    profile:ProfileType /*Информация о профиле пользователя, полученная с сервера должна быть типа "PostType"
    или иметь тип "null", то есть быть пустой. Тип "PostType" был создан нами и импортирован сюда.*/
    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в
    данный момент отображается на странице профиля, должно быть булева типа.*/
    activateEditMode: () => void /*Функция, которая при вызове активирует режим редактирования профиля пользователя,
    должна быть функцией, которая ничего не принимает и не возвращает. Это функция создается в компоненте "ProfileInfo"
    и передается в компонент "ProfileData".*/
};

/*Создаем тип для "props" компонента "ContactPropsType".*/
type ContactPropsType = {
    contactTitle: string /*Текст заголовка контакта должен быть строкой.*/
    contactValue: string /*Значение контакта должен быть строкой.*/
};


/*
"ProfileInfo" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function ProfileInfo(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileInfo" является компонентом, который содержит информацию о пользователе.
Этот компонент подключается в компоненте "Profile".
Внутри компонента "Profile" подключаются компоненты:
- "Preloader", который является компонентом-заглушкой, который используется, чтобы показать анимацию загрузки в других
компонентах, когда идет какой-то процесс в них (например, AJAX-запрос);
- "ProfileStatusWithHooks", который отвечает за отображение и редактирование статуса пользователя на странице профиля
(сделан на хуках);
- "ProfileStatus", который отвечает за отображение и редактирование статуса пользователя на странице профиля (в данный
момент не используется);
- "ProfileDataFormReduxForm", который ;
- "ProfileData", который является внутренним вспомогательным компонентом для компонента "ProfileInfo", который содержит
данные профиля пользователя и интерфейс для перехода в режим редактирования этой информации.
*/
const ProfileInfo: React.FC<ProfileInfoPropsType> = ({/*Указали при помощи "React.FC<>", что "props" в этом
функциональном компоненте имеют тип "ProfileInfoPropsType", созданный нами выше. Также указываем какие именно "props"
мы получаем, чтобы не писать далее "props.isOwner", "props.profile" и так далее. Такое мы делаем только в функциональных
компонентах.*/
                         isOwner, /*Свойство, которое показывает является ли залогиненный пользователь
                         владельцем профиля, который в данный момент отображается на странице профиля.*/
                         profile, /*Данные профиля пользователя для страницы профиля.*/
                         status, /*Данные статуся пользователя для страницы профиля.*/
                         updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/
                         saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его
                         отображения в нашем приложении.*/
                         saveProfile /*TC для отправки новых данных профиля пользователя на странице профиля и
                         дальнейшего их отображения в нашем приложении.*/
}) => {
    let [editMode, setEditMode] = useState(false); /*При помощи деструктуризирующего присваивания создали
    две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент будет означать
    включен или выключен режим редактирования профиля пользователя (изначально "false"). Вторая переменная будет
    хранить функцию из хука "useState", которая будет изменять первый элемент (то есть включать или выключать режим
    редактирования профиля пользователя).*/

    const activateEditMode = () => { /*Создали функцию, которая при вызове активирует режим редактирования
    профиля пользователя.*/
        setEditMode(true);
    };

    if (!profile) { /*Если данные профиля пользователя отсутствуют, то отрисовываем компонент-заглушку "Preloader".*/
        return <Preloader/>
    };

    const onUserPhotoSelected = (event: ChangeEvent<HTMLInputElement>) => { /*Создали функцию, которая при вызове
    сначала проверяет, что массив файлов с фото пользователя не пустой, и если он не пустой, то потом отправляет первый
    файл из этого массива в TC "saveUserPhoto" для загрузки фото пользователя на сервер и дальнейшего его отображения в
    нашем приложении. Эта функция будет срабатывать как callback, когда пользователь выбирает изображение. Для события
    "event" указали тип "ChangeEvent<HTMLInputElement>".*/
        if (event.target.files?.length) { /*Здесь указали "?", чтобы не было ошибки связанной с типизацией, поскольку
        "files" может не быть. Вместо этого можно было написать так:
        "if (event.target.files && event.target.files.length)", такая бы проверка тоже удовлетворила "TypeScript".*/
            saveUserPhoto(event.target.files[0]);
        };
    };

    const onSubmit = (formData: ProfileDataFormValuesType) => { /*Создали callback функцию, которая при вызове совершает
    сабмит данных, то есть собирает данные формы и вызывает TC "saveProfile" для отправки новых данных профиля
    пользователя на странице профиля и дальнейшего их отображения в нашем приложении, передав ему эти данные. Далее
    будет ожидание промиса. При успешном выполнении промиса деактивируется режим редактирования профиля пользователя.
    Если от сервера придет ошибка, то промис будет отклонен и режим редактирования профиля пользователя не будет
    деактивирован (так работает этот TC "saveProfile"). Если здесь использовать "async/await" вместо ".then", то
    работать не будет. Этот callback получает указанные данные на входе в объекте "formData" с типом
    "ProfileDataFormValuesType". Стоит здесь также отметить, что такое использование ".then" в компонентах не
    желательно, поэтому в дальнейшем нужно найти другое решение.*/
        saveProfile(formData).then(
            () => {
                setEditMode(false);
            }
        );
    };

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            <div className={styles.profileImage}> {/*Этот элемент "div" содержит изображение из шапки страницы
            профиля.*/}
                <img src={profileLogoSource} alt=''/> {/*Отрисовываем элемент "img", который содержит изображение
                из шапки страницы профиля.*/}
            </div>

            <div className={styles.descriptionBlock}> {/*Этот элемент "div" содержит данные профиля пользователя
            на странице профиля.*/}
                <img src={profile.photos.large || userPhoto} className={styles.userPhoto} alt=''/> {/*Отрисовываем
                элемент "img", в котором будет отображаться фото пользователя, а если данных по фото пользователя от
                сервера получено не было, то отобразится аватар из ассетов проекта.*/}

                {isOwner && <input type={'file'} onChange={onUserPhotoSelected}/>} {/*Если пользователь является
                владельцем открытого в данным момент профиля, то отрисуется элемент "input" с "type" равным "file"
                (т.е. можно загрузить файл) с событием при изменении "onUserPhotoSelected" для загрузки
                фото пользователя.*/}

                {/*Отрисовываем компонент "ProfileStatusWithHooks" и передаем ему через "props" необходимые для
                него данные.*/}
                <ProfileStatusWithHooks status={status} /*Данные статуся пользователя для страницы профиля.*/
                               updateUserStatus={updateUserStatus} /*TC для изменения статуса пользователя
                               на странице профиля.*/
                               isOwner={isOwner} /*Свойство, которое показывает является ли залогиненный пользователь
                               владельцем профиля, который в данный момент отображается на странице профиля.*/
                />

                {editMode /*Если режим редактирования включен, то отрисуется компонент "ProfileDataReduxForm", получив
                стартовые значения "initialValues" (взято из библиотеки "redux-form") для полей формы, данные
                автоматически раскидаются по полям в зависимости от их имен, чтобы при переходе в режим редактирования
                профиля поля не были пустыми, если она уже имели какую-то информацию. При подтверждении формы в этом
                компоненте сработает callback "onSubmit" для сабмита данных. Также передаем в компонент
                "ProfileDataFormReduxForm" объект с данными профиля пользователя "profile" для его маппинга и создания
                полей для редактирования контактов пользователя (смотри реализацию самого компонента).

                Если же режим редактирования выключен, то отрисуется компонент "ProfileData" для отображения профиля
                пользователя. В него мы передаем объект с данными профиля пользователя "profile", и свойство "isOwner",
                так как нам нужно знать является ли пользователь владельцем открытого в данный момент профиля, поскольку
                только владелец своего профиля должен иметь право его редактировать. Также в этот компонент мы передаем
                callback "activateEditMode" для активации режима редактирования профиля пользователя.

                Здесь есть проблема, когда мы быстро переключаемся с чужого профиля на свой профиль - в этот момент
                сразу же появляется кнопка для редактирования профиля, и если ее сразу нажать, то в полях будут данные
                чужого профиля, а не своего, так как данные нашего профиля не успели еще подгрузиться.*/
                    ? <ProfileDataReduxForm initialValues={profile} onSubmit={onSubmit} profile={profile}/>
                    : <ProfileData profile={profile} isOwner={isOwner} activateEditMode={activateEditMode}/>
                }
            </div>
        </div>
    );
};


/*
"ProfileData" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileData" является внутренним вспомогательным компонентом для компонента "ProfileInfo", который содержит данные
профиля пользователя и интерфейс для перехода в режим редактирования этой информации.
Этот компонент подключается в компоненте "ProfileInfo".
*/
const ProfileData: React.FC<ProfileDataPropsType> = ({profile, isOwner, activateEditMode}) => {
    /*Указали при помощи "React.FC<>", что "props" в этом функциональном компоненте имеют тип "ProfileDataPropsType",
    созданный нами выше. Также указываем какие именно "props" мы получаем, чтобы не писать далее "props.profile",
    "props.isOwner" и так далее:
    - "profile" - данные профиля пользователя для страницы профиля;
    - "isOwner" - свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в
    данный момент отображается на странице профиля;
    - "activateEditMode" - функция, которая при вызове активирует режим редактирования профиля пользователя.
    Такое мы делаем только в функциональных компонентах.*/

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            {isOwner && <div> {/*Если пользователь является владельцем открытого профиля, то отображаем
            элемент "div",*/}
                <button onClick={activateEditMode}>Edit</button> {/*внутри которого есть элемент "button", для
                отображения кнопки перехода в режим редактирования данных профиля, для чего указано событие
                при нажатии "activateEditMode".*/}
            </div>}

            <div><b>1. Full Name</b>: {profile.fullName}</div> {/*Этот элемент "div" содержит полное имя пользователя,
            которое берется из "props".*/}

            <div><b>2. About Me</b>: {profile.aboutMe}</div> {/*Этот элемент "div" содержит информацию о пользователе
            "Обо мне", которая берется из "props".*/}

            <div> {/*Этот элемент "div" содержит контакты пользователя, которые берутся из "props". Создаются
            следующим образом:*/}
                <b>3. Contacts</b>: {Object
                    .keys(profile.contacts)
                    .map(key => { /*При помощи метода "keys" глобального объекта "Object" мы можем проитерироваться по
                    ключам переданного объекта "profile.contacts". Возьмутся все ключи "key" и завернутся в массив
                    строк. А далее мы мапим этот массив, чтобы отрисовать однотипный JSX с полями контактов при помощи
                    компонента "Contact".*/
                return <Contact key={key} /*При использовании метода "map" нужно указывать атрибут "key"
                                для избежания ошибок.*/
                                contactTitle={key} /*Заголовок поля контакта.*/
                                contactValue={profile.contacts[key as keyof ContactsType]} /*Значение поля контакта в
                                соответствии с заголовком. Здесь указали "as keyof ContactsType", чтобы "TypeScript"
                                понял, что это данные из свойств типа "ContactsType".*/
                />
            })}
            </div>

            <div><b>4. Is looking for a job?</b> {profile.lookingForAJob ? <span>Yes</span> : <span>No</span>}</div>
            {/*Этот элемент "div" содержит информацию ищет ли в данный момент работу пользователь. Если свойство
            "lookingForAJob", которое берется из "props", является "TRUE", то отрисуется элемент "span" с текстом "Yes",
            иначе отрисуется элемент "span" с текстом "No".*/}

            {profile.lookingForAJob && <div><b>Which one?</b> {profile.lookingForAJobDescription}</div>} {/*Если
            свойство "lookingForAJob", которое берется из "props", является "TRUE", то отрисуется элемент "div"
            с текстом из "lookingForAJobDescription", который означает работу, которую ищет пользователь.*/}
        </div>
    )
};


/*
"Contact" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function Contact(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"Contact" является внутренним вспомогательным компонентом для компонента "ProfileData", который содержит заготовку
для полей контактов пользователя, который используется в маппинге для отрисовки однотипного JSX.
Этот компонент подключается в компоненте "ProfileData".
*/
const Contact: React.FC<ContactPropsType> = ({contactTitle, contactValue}) => { /*Указали при помощи
"React.FC<>", что "props" в этом функциональном компоненте имеют тип "ContactPropsType", созданный нами выше. Также
указываем какие именно "props" мы получаем, чтобы не писать далее "props.contactTitle" и так далее:
- "contactTitle" - текст заголовка контакта;
- "contactValue" - значение контакта.*/

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return <div className={styles.contact}><b>{contactTitle}</b>: {contactValue}</div>
    {/*Этот элемент "div" и есть наш корневой элемент. Внутри он будет из себя представлять следующее:
    "Текст заголовка поля контакта": "Текст со значение самого контакта".*/}
};


export default ProfileInfo; /*Экспортируем компонент "ProfileInfo" по default и будем его использовать в нашем проекте
под именем "ProfileInfo", экспорт необходим для импорта.*/