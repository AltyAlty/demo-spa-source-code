import styles from './ProfileInfo.module.css';
/*Импортируем из ассетов аватар на случай, если у пользователя нет фото.*/
import userPhoto from '../../../assets/images/user.png';
/*Импортируем из ассетов лого для страницы профиля.*/
import profileLogoSource from '../../../assets/images/profilelogo.jpg';
/*Импортируем компонент "Preloader".*/
import {Preloader} from '../../common/Preloader/Preloader';
/*Импортируем компонент "ProfileStatusWithHooks". Является аналогом компонента "ProfileStatus", сделанного без хуков.*/
import {ProfileStatusWithHooks} from './ProfileStatus/ProfileStatusWithHooks';
/*Импортируем компонент "ProfileStatus". Является аналогом компонента "ProfileStatusWithHooks", сделанного на хуках. На
данный момент компонент "ProfileStatus" не работает корректно.*/
import {ProfileStatus} from './ProfileStatus/ProfileStatus';
/*Импортируем компонент "ProfileDataReduxEditForm" и тип "ProfileDataFormValuesType".*/
import {
    ProfileDataEditFormValuesType,
    ProfileDataReduxEditForm
} from './ProfileDataReduxEditForm/ProfileDataReduxEditForm';
/*Импортируем компонент "ProfileData".*/
import {ProfileData} from './ProfileData/ProfileData';
/*Импортируем "ChangeEvent" для типизации событий.*/
import React, {ChangeEvent, useState} from 'react';
/*Импортируем тип "ProfileType".*/
import {ProfileType} from '../../../types/types';

/*Создаем общий тип для всех props компонента "ProfileInfo". Все это нужно для указания типа props в функциональном
компоненте "ProfileInfo".*/
type ProfileInfoPropsType = {
    /*Информация о профиле пользователя, полученная с сервера должна быть типа "ProfileType" или иметь тип null, то есть
    быть пустой.*/
    profile: ProfileType | null
    /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип null, то есть быть пустыми.*/
    status: string | null
    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент
    отображается на странице профиля, должно быть булева типа.*/
    isOwner: boolean
    /*TC для изменения данных по статусу пользователя на странице профиля должен быть функцией, которая принимает
    строковой параметр и ничего не возвращает.*/
    updateUserStatus: (status: string) => void
    /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении должен быть
    функцией, принимающей объект с фото пользователя, которое имеет тип "File" из Typescript и ничего не возвращает.*/
    saveUserPhoto: (photoFile: File) => void
    /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем
    приложении должен быть функцией, которая принимает объект типа "ProfileType" и возвращает какой-либо промис, так как
    мы здесь используем метод "then()" вместе с этим TC.*/
    saveProfile: (profile: ProfileType) => Promise<any>
};

/*"ProfileInfo" это функциональный компонент, который создан в виде стрелочной функции. "ProfileInfo" является
компонентом, который содержит информацию о пользователе.

Внутри компонента "ProfileInfo" используются следующие компоненты:
1. "Preloader" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,
пока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.
2. "ProfileStatusWithHooks" - компонент, который предоставляет реализацию статуса пользователя на странице пользователя.
Работает на хуках. Импортирован.
3. "ProfileStatus" - компонент, который предоставляет реализацию статуса пользователя на странице пользователя. Работает
не на хуках. На данный момент не работает корректно и не используется (используем компонент "ProfileStatusWithHooks").
Импортирован.
4. "ProfileDataReduxEditForm" - контейнерный компонентом, цель которого обернуть компонент "ProfileDataEditForm" в файле
"ProfileDataReduxEditForm.tsx" функцией "reduxForm()", чтобы предоставить callback-функцию "handleSubmit()".
Импортирован.
5. "ProfileData" - компонент, который занимается отображением данных профиля пользователя и содержит интерфейс для
перехода в режим редактирования этой информации. Импортирован.

Компонент "ProfileInfo" импортируется в файле "Profile.tsx".

При помощи деструктуризации props указываем какие именно props мы получаем:
1. "isOwner" - свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент
отображается на странице профиля.
2. "profile" - данные профиля пользователя для страницы профиля.
3. "status" - данные статуса пользователя для страницы профиля.
4. "updateUserStatus" - TC для изменения статуса пользователя на странице профиля.
5. "saveUserPhoto" - TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем
приложении.
6. "saveProfile" - TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в
нашем приложении.*/
export const ProfileInfo: React.FC<ProfileInfoPropsType> = ({
                                                                isOwner,
                                                                profile,
                                                                status,
                                                                updateUserStatus,
                                                                saveUserPhoto,
                                                                saveProfile
                                                            }) => {
    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый
    элемент из хука "useState()", этот элемент будет означать включен или выключен режим редактирования профиля
    пользователя (изначально false). Вторая переменная будет хранить функцию из хука "useState()", которая будет
    изменять первый элемент (то есть включать или выключать режим редактирования профиля пользователя).*/
    const [editMode, setEditMode] = useState(false);
    /*Создаем функцию, которая при вызове активирует режим редактирования профиля пользователя.*/
    const activateEditMode = () => { setEditMode(true) };
    /*Если данные профиля пользователя отсутствуют, то отрисовываем компонент-заглушку "Preloader".*/
    if (!profile) return <Preloader/>;
    /*Создаем функцию, которая при вызове сначала проверяет, что массив файлов с фото пользователя не пустой, и если он
    не пустой, то потом отправляет первый файл из этого массива в TC "saveUserPhoto()" для загрузки фото пользователя на
    сервер и дальнейшего его отображения в нашем приложении. Эта функция будет срабатывать как callback-функция, когда
    пользователь выбирает изображение. Для события "event" указали тип "ChangeEvent<HTMLInputElement>".*/
    const onUserPhotoSelected = (event: ChangeEvent<HTMLInputElement>) => {
        /*Здесь указали "?", чтобы не было ошибки связанной с типизацией, поскольку "files" может не быть. Вместо этого
        можно было написать так "if (event.target.files && event.target.files.length)", такая проверка тоже бы
        удовлетворила Typescript.*/
        if (event.target.files?.length) saveUserPhoto(event.target.files[0]);
    };

    /*Создаем callback-функцию, которая при вызове совершает сабмит данных, то есть собирает данные формы и вызывает TC
    "saveProfile()" для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в
    нашем приложении, передав ему эти данные. Далее идет ожидание промиса. При успешном выполнении промиса
    деактивируется режим редактирования профиля пользователя. Если от сервера придет ошибка, то промис будет отклонен и
    режим редактирования профиля пользователя не будет деактивирован (так работает этот TC "saveProfile()"). Если здесь
    использовать ключевые слова async/await вместо ключевого then, то работать не будет.

    Эта callback-функция получает указанные данные на входе в объекте "formData" с типом "ProfileDataFormValuesType".
    Стоит здесь также отметить, что такое использование ключевого слова then в компонентах не желательно, поэтому в
    дальнейшем нужно найти другое решение.*/
    const onSubmit = (formData: ProfileDataEditFormValuesType) => {
        saveProfile(formData).then(() => { setEditMode(false) });
    };

    return (
        <div>
            {/*Этот элемент "div" содержит изображение из шапки страницы профиля.*/}
            <div className={styles.profileImage}>
                {/*Отрисовываем элемент "img", который содержит изображение из шапки страницы профиля.*/}
                <img src={profileLogoSource} alt=''/>
            </div>

            {/*Этот элемент "div" содержит данные профиля пользователя на странице профиля.*/}
            <div className={styles.descriptionBlock}>
                {/*Отрисовываем элемент "img", в котором будет отображаться фото пользователя, а если данных по фото
                пользователя от сервера получено не было, то отобразится аватар из ассетов проекта.*/}
                <img src={profile.photos.large || userPhoto} className={styles.userPhoto} alt=''/>

                {/*Если пользователь является владельцем открытого в данным момент профиля, то отрисуется элемент
                "input" с атрибутом "type" равным "file", что позволит загрузить файл. Так этот элемент "input" будет
                содержать callback-функцию "onUserPhotoSelected()", которая будет срабатывать при событии "onChange",
                которая будет загружать фото пользователя.*/}
                {isOwner && <input type={'file'} onChange={onUserPhotoSelected}/>}

                {/*Отрисовываем компонент "ProfileStatusWithHooks" и передаем ему через props необходимые для его работы
                данные.*/}
                <ProfileStatusWithHooks
                    /*Данные статуса пользователя для страницы профиля.*/
                    status={status}
                    /*TC для изменения статуса пользователя на странице профиля.*/
                    updateUserStatus={updateUserStatus}
                    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный
                    момент отображается на странице профиля.*/
                    isOwner={isOwner}
                />

                {/*Если режим редактирования включен, то отрисуется компонент "ProfileDataReduxEditForm", получив
                стартовые значения "initialValues" (взято из библиотеки Redux Form) для полей формы. Эти данные
                автоматически раскидаются по полям в зависимости от их имен, чтобы при переходе в режим редактирования
                профиля поля не были пустыми, если они уже имели какую-то информацию. При подтверждении формы в
                компоненте "ProfileDataReduxEditForm" сработает callback-функция "onSubmit()" для сабмита данных. Также
                передаем в компонент "ProfileDataReduxEditForm" объект с данными профиля пользователя "profile" для
                маппинга этого объекта и создания полей для редактирования контактов пользователя.

                Если же режим редактирования выключен, то отрисуется компонент "ProfileData" для отображения профиля
                пользователя. В него мы передаем объект с данными профиля пользователя "profile", и свойство "isOwner",
                так как нам нужно знать является ли пользователь владельцем открытого в данный момент профиля, поскольку
                только владелец своего профиля должен иметь право его редактировать. Также в этот компонент мы передаем
                callback-функцию "activateEditMode()" для активации режима редактирования профиля пользователя.

                Здесь есть проблема, когда мы быстро переключаемся с чужого профиля на свой профиль - в этот момент
                сразу же появляется кнопка для редактирования профиля, и если ее сразу нажать, то в полях будут данные
                чужого профиля, а не своего, так как данные нашего профиля не успели еще подгрузиться.*/}
                {editMode
                    ? <ProfileDataReduxEditForm initialValues={profile} onSubmit={onSubmit} profile={profile}/>
                    : <ProfileData profile={profile} isOwner={isOwner} activateEditMode={activateEditMode}/>
                }
            </div>
        </div>
    );
};