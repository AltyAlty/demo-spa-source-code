import React, {useState} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
Классовый компонент позволяет реализовать локальный "state" (смотри "ProfileStatus") и методы
жизненного цикла ("componentDidMount" и т.д.), а функциональный компонент этого не может делать.
Такие возможности классового компонента были созданы благодаря тому, что "React" на основе класса
создает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может
хранить такие вещи как "state" и методы. Функция же просто вызывается и возвращает "JSX", постоянное
общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала
и удалилась. Для решения этой проблемы в функциональных компонентах были созданы "Hooks" (хуки).
"Hook" - это функция, которая может делать side effects.
"React" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и
этой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента
"React" запоминает эту информацию где-то на своей стороне, а не внутри объекта.
Хуки нельзя писать в условиях и циклах.
Можно писать свои кастомные хуки.
Подключаем хук "useState", который возвращает массив с двуми элементами. Первый элемент - это значение,
которое хранится в "state". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя
первый элемент мы заставляем "React" перерисовывать функциональный компонент.
*/

import styles from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/
import userPhoto from '../../../assets/images/user.png'; /*Импортируем из ассетов аватар на случай, если у пользователя
нет фото.*/
import profileLogoSource from '../../../assets/images/profilelogo.jpg'; /*Импортируем из ассетов лого для страницы
профиля.*/

import Preloader from '../../common/Preloader/Preloader'; /*Подключаем компонент "Preloader".*/
import ProfileStatus from './ProfileStatus'; /*Подключаем компонент "ProfileStatus", но в данный момент
не используется (аналог компонента "ProfileStatusWithHooks", но без хуков).*/
import ProfileStatusWithHooks from './ProfileStatusWithHooks'; /*Подключаем компонент "ProfileStatusWithHooks".*/
import ProfileDataFormReduxForm from './ProfileDataForm'; /*Подключаем компонент "ProfileDataFormReduxForm".*/


/*
"ProfileInfo" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function ProfileInfo(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileInfo" является компонентом, который содержит информацию о пользователе.
Этот компонент подключается в компоненте "Profile".
Внутри компонента "Profile" подключаются компоненты:
- "Preloader", который является компонентом-заглушкой, который используется, чтобы показать анимацию загрузки в других
компонентах, когда идет какой-то процесс в них (например, AJAX-запрос);
- "ProfileStatusWithHooks", который отвечает за отображение и редактирование статуса пользователя на странице профиля
(сделан на хуках);
- "ProfileStatus", который отвечает за отображение и редактирование статуса пользователя на странице профиля (в данный
момент не используется);
- "ProfileDataFormReduxForm", который ;
- "ProfileData", который является внутренним вспомогательным компонентом для компонента "ProfileInfo", который содержит
данные профиля пользователя и интерфейс для перехода в режим редактирования этой информации.
*/
const ProfileInfo = ({/*Указываем какие именно "props" мы получаем, чтобы не писать далее "props.isOwner",
"props.profile" и так далее. Такое мы делаем только в функциональных компонентах.*/
                         isOwner, /*Свойство, которое показывает является ли залогиненный пользователь владельцем
                         профиля, который в данный момент отображается на странице профиля.*/
                         profile, /*Данные профиля пользователя для страницы профиля.*/
                         status, /*Данные статуся пользователя для страницы профиля.*/
                         updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/
                         saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его
                         отображения в нашем приложении.*/
                         saveProfile /*TC для отправки новых данных профиля пользователя на странице профиля и
                         дальнейшего их отображения в нашем приложении.*/
}) => {
    let [editMode, setEditMode] = useState(false); /*При помощи деструктуризирующего присваивания создали
    две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент будет означать
    включен или выключен режим редактирования профиля пользователя (изначально "false"). Вторая переменная будет
    хранить функцию из хука "useState", которая будет изменять первый элемент (то есть включать или выключать режим
    редактирования профиля пользователя).*/

    const activateEditMode = () => { /*Создали функцию, которая при вызове активирует режим редактирования
    профиля пользователя.*/
        setEditMode(true);
    };

    if (!profile) { /*Если данные профиля пользователя отсутствуют, то отрисовываем компонент-заглушку "Preloader".*/
        return <Preloader/>
    }

    const onUserPhotoSelected = (e) => { /*Создали функцию, которая при вызове сначала проверяет, что массив файлов с
    фото пользователя не пустой, и если он не пустой, то потом отправляет первый файл из этого массива в
    TC "saveUserPhoto" для загрузки фото пользователя на сервер и дальнейшего его отображения в нашем приложении. Эта
    функция будет срабатывать как callback, когда пользователь выбирает изображение.*/
        if (e.target.files.length) {
            saveUserPhoto(e.target.files[0]);
        }
    };

    const onSubmit = (formData) => { /*Создали функцию, которая при вызове совершает сабмит данных, то есть собирает
    данные формы и вызывает TC "saveProfile" для отправки новых данных профиля пользователя на странице профиля и
    дальнейшего их отображения в нашем приложении, передав ему эти данные. Далее будет ожидание промиса. При успешном
    выполнении промиса деактивируется режим редактирования профиля пользователя. Если от сервера придет ошибка, то
    промис будет отклонен и режим редактирования профиля пользователя не будет деактивирован (так работает этот TC
    "saveProfile"). Если здесь использовать "async/await" вместо ".then", то работать не будет.*/
        saveProfile(formData).then(
            () => {
                setEditMode(false);
            }
        );
    };

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            <div className={styles.profileImage}> {/*Этот элемент "div" содержит изображение из шапки страницы
            профиля.*/}
                <img src={profileLogoSource} alt=''/> {/*Отрисовываем элемент "img", который содержит изображение
                из шапки страницы профиля.*/}
            </div>

            <div className={styles.descriptionBlock}> {/*Этот элемент "div" содержит данные профиля пользователя
            на странице профиля.*/}
                <img src={profile.photos.large || userPhoto} className={styles.userPhoto} alt=''/> {/*Отрисовываем
                элемент "img", в котором будет отображаться фото пользователя, а если данных по фото пользователя от
                сервера получено не было, то отобразится аватар из ассетов проекта.*/}

                {isOwner && <input type={'file'} onChange={onUserPhotoSelected}/>} {/*Если пользователь является
                владельцем открытого в данным момент профиля, то отрисуется элемент "input" с "type" равным "file"
                (т.е. можно загрузить файл) с событием при изменении "onUserPhotoSelected" для загрузки
                фото пользователя.*/}

                {/*Отрисовываем компонент "ProfileStatusWithHooks" и передаем ему через "props" необходимые для
                него данные.*/}
                <ProfileStatusWithHooks status={status} /*Данные статуся пользователя для страницы профиля.*/
                               updateUserStatus={updateUserStatus} /*TC для изменения статуса пользователя
                               на странице профиля.*/
                               isOwner={isOwner} /*Свойство, которое показывает является ли залогиненный пользователь
                               владельцем профиля, который в данный момент отображается на странице профиля.*/
                />

                {editMode /*Если режим редактирования включен, то отрисуется компонент "ProfileDataFormReduxForm",
                получив стартовые значения "initialValues" (взято из библиотеки "redux-form") для полей формы, данные
                автоматически раскидаются по полям в зависимости от их имен, чтобы при переходе в режим редактирования
                профиля поля не были пустыми, если она уже имели какую-то информацию. При подтверждении формы в этом
                компоненте сработает callback "onSubmit" для сабмита данных. Также передаем в компонент
                "ProfileDataFormReduxForm" объект с данными профиля пользователя "profile" для его маппинга и создания
                полей для редактирования контактов пользователя (смотри реализацию самого компонента).

                Если же режим редактирования выключен, то отрисуется компонент "ProfileData" для отображения профиля
                пользователя. В него мы передаем объект с данными профиля пользователя "profile", и свойство "isOwner",
                так как нам нужно знать является ли пользователь владельцем открытого в данный момент профиля, поскольку
                только владелец своего профиля должен иметь право его редактировать. Также в этот компонент мы передаем
                callback "activateEditMode" для активации режима редактирования профиля пользователя.*/
                    ? <ProfileDataFormReduxForm initialValues={profile} onSubmit={onSubmit} profile={profile}/>
                    : <ProfileData profile={profile} isOwner={isOwner} activateEditMode={activateEditMode}/>
                }
            </div>
        </div>
    );
};

/*
"ProfileData" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileData" является внутренним вспомогательным компонентом для компонента "ProfileInfo", который содержит данные
профиля пользователя и интерфейс для перехода в режим редактирования этой информации.
Этот компонент подключается в компоненте "ProfileInfo".
*/
const ProfileData = ({profile, isOwner, activateEditMode}) => {
    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            {isOwner && <div> {/*Если пользователь является владельцем открытого профиля, то отображаем
            элемент "div",*/}
                <button onClick={activateEditMode}>edit</button> {/*внутри которого есть элемент "button", для
                отображения кнопки перехода в режим редактирования данных профиля, для чего указано событие
                при нажатии "activateEditMode".*/}
            </div>}

            <div><b>1. Full Name</b>: {profile.fullName}</div> {/*Этот элемент "div" содержит полное имя пользователя,
            которое берется из "props".*/}

            <div><b>2. About Me</b>: {profile.aboutMe}</div> {/*Этот элемент "div" содержит информацию о пользователе
            "Обо мне", которая берется из "props".*/}

            <div> {/*Этот элемент "div" содержит контакты пользователя, которые берутся из "props". Создаются
            следующим образом:*/}
                <b>3. Contacts</b>: {Object.keys(profile.contacts).map(key => { /*При помощи метода "keys" глобального
                объекта "Object" мы можем проитерироваться по ключам переданного объекта "profile.contacts". Возьмутся
                все ключи "key" и завернутся в массив строк. А далее мы мапим этот массив, чтобы отрисовать однотипный
                JSX с полями контактов при помощи компонента "Contact".*/
                return <Contact key={key} /*При использовании метода "map" нужно указывать атрибут "key"
                                для избежания ошибок.*/
                                contactTitle={key} /*Заголовок поля контакта.*/
                                contactValue={profile.contacts[key]} /*Значение поля контакта в соответствии
                                с заголовком.*/
                />
            })}
            </div>

            <div><b>4. Is looking for a job?</b> {profile.lookingForAJob ? <span>Yes</span> : <span>No</span>}</div>
            {/*Этот элемент "div" содержит информацию ищет ли в данный момент работу пользователь. Если свойство
            "lookingForAJob", которое берется из "props", является "TRUE", то отрисуется элемент "span" с текстом "Yes",
            иначе отрисуется элемент "span" с текстом "No".*/}

            {profile.lookingForAJob && <div><b>Which one?</b> {profile.lookingForAJobDescription}</div>} {/*Если
            свойство "lookingForAJob", которое берется из "props", является "TRUE", то отрисуется элемент "div"
            с текстом из "lookingForAJobDescription", который означает работу, которую ищет пользователь.*/}
        </div>
    )
};

/*
"Contact" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function Contact(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"Contact" является внутренним вспомогательным компонентом для компонента "ProfileData", который содержит заготовку
для полей контактов пользователя, который используется в маппинге для отрисовки однотипного JSX.
Этот компонент подключается в компоненте "ProfileData".
*/
const Contact = ({contactTitle, contactValue}) => {
    return <div className={styles.contact}><b>{contactTitle}</b>: {contactValue}</div>
    {/*Этот элемент "div" и есть наш корневой элемент. Внутри он будет из себя представлять следующее:
    "Текст заголовка поля контакта": "Текст со значение самого контакта".*/}
};


export default ProfileInfo; /*Экспортируем компонент "ProfileInfo" по default, экспорт необходим для импорта.*/