import React, {ChangeEvent} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".

"ChangeEvent" импортировали для типизации событий.
*/


/*Создаем тип для "props". "props" в этом компоненте должен обязательно содержать следующие поля с указанными типами.*/
type PropsType = {
    status: string /*Информация о статусе пользователя, полученная с сервера, должна быть строкой.*/
    updateUserStatus: (newStatus: string) => void /*TC для изменения данных по статусу пользователя на странице профиля
    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/
    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в
    данный момент отображается на странице профиля, должно быть булева типа.*/
};

/*Создаем тип для локального "state". Локальный "state" в этом компоненте должен обязательно содержать следующие поля
с указанными типами.*/
type StateType = {
    editMode: boolean /*Значение, которое определяет вкючен ли режим редактирования статуса пользователя или нет,
    должно быть булева типа.*/
    status: string /*Информация о статусе пользователя, установленная в локальном "state", должна быть строкой.*/
};


/*
"ProfileStatus" это классовый компонент.
Классы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать
концепцию ООП.
React определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать
с этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно
взаимодействует.
Например, у него можно постоянно запрашивать JSX.
В React при создании класса мы наследуем и расширяем некий базовый класс "React.Component" при помощи "extends".
Компонент это функция, которая возвращает JSX.
Классовые компоненты могут содержать "side effects". Для этого используются методы жизненного цикла.
У классового компонента всегда есть метод render(){...}, который возвращает JSX.
При переходе по разным "Route" экземпляры классовых компонентов удаляются из памяти.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
Этот компонент подключается в компоненте "ProfileInfo".
Компонент "ProfileStatus" предоставляет реализацию статуса пользователя на странице пользователя.
Статус пользователя представляет из себя поле статуса как в ВК, на который можно нажать и активировать поле для ввода
статуса, а если убрать фокус с этого поля, то будет просто текст.
*/
class ProfileStatus extends React.Component<PropsType, StateType> { /*Указали, что "props" в этом классовом
компоненте имеют тип "PropsType", а "state" имеет тип "StateType".*/
    state = { /*Локальный "state" это дополнение к глобальному "state". Такой "state" может использоваться для данных,
    которые необходимы для работы приложения, но не относятся к бизнес-данным (например, временные данные или
    UI-данные). Любой компонент может определить свой локальный "state". Работать такой компонент будет по знакомому
    способу: если компонент что-то изменить в локальном "state", то он перерисуется. Для этого нужно использовать
    классовый компонент, поскольку "React" при работе с таким компонентом создает объект, в котором можно хранить
    локальный "state".*/
        editMode: false, /*Значение, которое определяет вкючен ли режим редактирования статуса пользователя или нет.*/
        status: this.props.status /*Значение, которое будет хранить информацию о статусе пользователя, полученную
        с сервера. Берется из "props".*/
    };

    activateEditMode = () => { /*Создаем метод, при вызове которого будет активироваться режим редактирования статуса
    пользователя. Этот метод будет использоваться в обработчике событий как callback.*/
        this.setState({ /*При помощи метода "setState()" из "React" работаем с локальным "state". Вместо этого
        метода можно было использовать метод "forceUpdate()" для того, чтобы заставить "React" перерисовать компонент,
        но это нежелательно. Метод "setState()" асинхронный. В метод "setState" нужно передать объект, свойства
        которого перезапишут свойства в локальном "state", он не удалит все свойства локального "state", а только
        заменит указанные. Ранее нужно было использовать классический способ создания метода:
        "activateEditMode () {...};", так как при использовании стрелочной функции "debugger" не видел контекста "this",
        а также приходилось использовать метод "bind()" для привязки этого контекста, но на данный момент эта проблема
        решена в "ReactJS".*/
            editMode: true, /*Указываем, что включили режим редактирования статуса пользователя.*/
            status: this.props.status /*Получаем информацию о статусе пользователя из "props".*/
        });
    };

    deactivateEditMode = () => { /*Создаем метод, при вызове которого будет деактивироваться режим редактирования
    статуса пользователя. Этот метод будет использоваться в обработчике событий как callback.*/
        this.setState({ /*При помощи метода "setState()" из "React" работаем с локальным "state". Вместо этого
        метода можно было использовать метод "forceUpdate()" для того, чтобы заставить "React" перерисовать компонент,
        но это нежелательно. Метод "setState()" асинхронный. В метод "setState" нужно передать объект, свойства
        которого перезапишут свойства в локальном "state", он не удалит все свойства локального "state", а только
        заменит указанные. Ранее нужно было использовать классический способ создания метода:
        "deactivateEditMode () {...};", так как при использовании стрелочной функции "debugger" не видел
        контекста "this", а также приходилось использовать метод "bind()" для привязки этого контекста, но на
        данный момент эта проблема решена в "ReactJS".*/
            editMode: false /*Указываем, что выключили режим редактирования статуса пользователя.*/
        });
        this.props.updateUserStatus(this.state.status); /*При помощи TC "updateUserStatus" для изменения статуса
        пользователя на странице профиля, полученного из "props", обновляем значение статуса пользователя
        в глобальном "state" (но не в локальный "state", для этого мы создали метод "onUserStatusChange" ниже).*/
    };

    onUserStatusChange = (event: ChangeEvent<HTMLInputElement>) => { /*Создали специальный метод "onUserStatusChange",
    который будет вызываться при изменении поля "input", брать текущее значение содержимого этого поля и сохранять
    его в локальный "state". Для события "event" указали тип "ChangeEvent<HTMLInputElement>".*/
        this.setState({
            status: event.currentTarget.value
        });
    };

    componentDidUpdate(prevProps: PropsType, prevState: StateType) { /*Это метод жизненного цикла классового компонента.
    Он вызывается в момент обновления (изменения "props" или "state") компонента. Указали, что предыдущие "props" в этом
    классовом компоненте имеют тип "PropsType", а предыдущий "state" имеет тип "StateType".*/
        if (prevProps.status !== this.props.status) { /*Если значение статуса из новых "props" не равно значению статуса
        из предыдущих "props", то только в этом случае обновляем значение статуса в локальном "state". Эта проверка
        нужна, чтобы избежать бесконечный цикл: после прихода новых "props" будут сразу обновлятся данные
        локального "state", что заставит перерисоваться компонент, при перерисовка снова сработает "componentDidUpdate"
        и локальный "state" снова изменится, что снова заставит перерисоваться компонент. В итоге весь этот код помогает
        нам синхронизировать глобальный "state" и локальный "state", чтобы не было таких случаев, когда если сразу
        после загрузки страницы профиля перейти в режим редактирования статуса и получить пустое поле (но у меня
        не было почему то этой проблемы изначально).*/
            this.setState({
                status: this.props.status
            });
        }
    };

    handleFocus = (event: ChangeEvent<HTMLInputElement>) => { /*Создали специальный метод "handleFocus" для
    автоматического выделения текста в поле статуса пользователя. Для события "event" указали тип
    "ChangeEvent<HTMLInputElement>".*/
        event.target.select();
    };

    render() {
        /*
        Здесь после return в компоненте начинается HTML разметка.
        Нужно помнить, что в этой разметке должен быть только один корневой элемент.
        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
        */
        return (
            <> {/*Этот пустой элемент и есть наш корневой элемент.*/}
                {!this.state.editMode && /*Если режим редактирования статуса пользователя отключен и мы являемся
                владельцем страницы, то отрисуется элемент "div", внутри которого будет элемент "span", содержащий
                обработчик события двойного нажатия по элементу "onDoubleClick". При срабатывании этого события
                активируется метод "activateEditMode" через callback, чтобы активировать режим редактирования
                статуса пользователя. Внутри элемента "span" будет отображаться текущее значение статуса пользователя
                из "props", а при его отсуствии будет надпись "Enter your status". Если мы же не являемся владельцем
                профиля, то мы не сможем перейти в режим редактирования, только увидеть сам статус. Здесь есть небольшая
                проблема - после ввода нового статуса какое-то время будет отображен старый статус, пока не завершится
                запрос на сервер на изменение этого статуса.
                Одним из вариантов решений этой проблемы может быть добавление заглушки "Preloader"
                на время пока идет запрос.*/
                <div>
                    {this.props.isOwner
                        ? <div><b>Status</b>: <span onDoubleClick={this.activateEditMode}>{this.props.status || 'Enter your status'}</span></div>
                        : <span>{this.props.status || ''}</span>
                    }
                </div>
                }

                {this.state.editMode && /*Если режим редактирования статуса пользователя включен, то
                отрисуется элемент "div", внутри которого будет элемент "input", содержащий обработчик события потери
                фокуса с элемента "onBlur". При срабатывании этого события активируется метод "deactivateEditMode"
                через callback, чтобы деактивировать режим редактирования статуса пользователя и сохранить
                новый статус в глобальном "state". Также у элемента "input" указан атрибут "autoFocus" для
                автоматического фокуса на элементе. Внутри элемента "input" будет отображаться текущее значение
                статуса пользователя при помощи атрибута "value" из локального "state". Также внутри элемента "input"
                содержится обработчик события появления фокуса на элементе "onFocus", при срабатывании которого
                активируется метод "handleFocus" через callback, чтобы автоматически выделить текст статуса
                пользователя.Еще внутри элемента "input" содержится обработчик события изменения поля "input"
                "onChange", при срабатывании которого активируется метод "onUserStatusChange" через callback, чтобы
                брать текущее значение содержимого этого поля и сохранять его в локальный "state".*/
                <div>
                    <input onChange={this.onUserStatusChange}
                           onFocus={this.handleFocus}
                           autoFocus={true}
                           onBlur={this.deactivateEditMode}
                           value={this.state.status}/>
                </div>
                }
            </>
        );
    };
};


export default ProfileStatus; /*Экспортируем компонент "ProfileStatus" по default и будем его использовать в нашем
проекте под именем "ProfileStatus", экспорт необходим для импорта.*/