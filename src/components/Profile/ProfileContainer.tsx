import React, {ComponentType} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
Импортируем "ComponentType" для типизации.
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Эта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/
import {compose} from 'redux';
/*
Функция "compose" из функционального программирования. Эта функция создает композицию обработчиков.
Библиотека "redux" содержит свою реализацию "compose". При помощи функции "compose" можно объеденять, например,
несколько обверток вокруг компонента и HOCs.
Обвертки и HOCs указываются снизу вверх. Функция "compose" вызывается дважды и работает схожим образом, как и метод
"connect" из библиотеки "react-redux".
*/
import {RouteComponentProps, withRouter} from 'react-router-dom';
/*
Библиотека "react-router-dom" необходима для создания роутинга и маршрутов в приложении.
Функция "withRouter" это HOC.
HOC - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Поскольку URL тоже является источником данных, то компоненту иногда могут понадобиться эти данные.
Чтобы их получить, можно воспользоваться "withRouter".
HOC "withRouter" принимает в качестве параметра компонент и передает ему через "props" данные из URL, чтобы компонент
знал где он находиться - т.е. какой у него маршрут.
Если подключить на самом высоком уровне дерева компонентов этот HOC, например, в "App.tsx", то данные URL будут доступны
и в дочерних компонентах.
То есть здесь можно было и не указывать HOC "withRouter".
При использовании "connect" роутинг сбивается. Чтобы решить эту проблемы мы обварачиваем "connect" при помощи
"withRouter". Но сейчас вроде и без этого все работает.
Также импортируем тип "RouteComponentProps".
*/

import Profile from './Profile'; /*Подключаем компонент "Profile".*/

import {
    getUserProfile, /*Подключаем TC "getUserProfile" из "profile-reducer".*/
    getUserStatus, /*Подключаем TC "getUserStatus" из "profile-reducer".*/
    saveProfile, /*Подключаем TC "saveProfile" из "profile-reducer".*/
    saveUserPhoto, /*Подключаем TC "saveUserPhoto" из "profile-reducer".*/
    updateUserStatus /*Подключаем TC "updateUserStatus" из "profile-reducer".*/
} from '../../redux/profile-reducer';

import {ProfileType} from '../../types/types'; /*Подключаем типы.*/
import {AppStateType} from '../../redux/redux-store'; /*Подключаем типы.*/


/*Создаем тип для "MapStateToProps". "MapStateToProps" в этом компоненте должен обязательно содержать следующие поля с
указанными типами.*/
type MapStateToPropsType = {
    profile: ProfileType | null /*Информация о профиле пользователя, полученная с сервера должна быть типа "PostType"
    или иметь тип "null", то есть быть пустой. Тип "PostType" был создан нами и импортирован сюда.*/
    status: string | null /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип "null",
    то есть быть пустыми.*/
    authUserID: number | null /*"ID" залогиненного пользователя должен быть число или иметь тип "null", то есть быть
    пустым.*/
};

/*Создаем тип для "MapDispatchToProps". "MapDispatchToProps" в этом компоненте должен обязательно содержать следующие
поля с указанными типами.*/
type MapDispatchToPropsType = {
    getUserProfile: (userID: number) => void /*TC для запроса и установки данных по профилю пользователя на странице
    профиля должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/
    getUserStatus: (userID: number) => void /*TC для запроса и установки данных по статусу пользователя на странице
    профиля должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/
    updateUserStatus: (status: string) => void /*TC для изменения данных по статусу пользователя на странице профиля
    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/
    saveUserPhoto: (photoFile: File) => void /*TC для загрузки фото пользователя на странице профиля и дальнейшего его
    отображения в нашем приложении должен быть функцией, которая принимает объект с фото пользователя, которое типа
    "File" из "TypeScript" и ничего не возвращает.*/
    saveProfile: (profile: ProfileType) => any /*TC для отправки новых данных профиля пользователя на странице профиля
    и дальнейшего их отображения в нашем приложении должен быть функцией, которая принимает объект типа "ProfileType" и
    возвращает что угодно с типом "any", так как пока неизвестно как это здесь типизировать, так как мы в файле
    "ProfileInfo.tsx" используем "then." вместе с этим TC. В самом файле "ProfileInfo.tsx" этот TC типизирован как
    функция, которая возвращает "Promise<any>", но если здесь указать также, то будет конфликт в типизации функции
    "connect", то есть здесь можно указать тоже "Promise<any>", если избавиться от типизации в функции "connect".*/
};

/*Создали отдельный тип для объекта "params" из объекта "match" из функции "withRouter" из библиотеки
"react-router-dom". Указали "string", так как все, что находится в этом объекте "params", является "string" (так
устроена функция "withRouter").*/
type ProfileWithRouterParamsTypes = {
    userID: string
};

/*Создаем общий тип для всех "props" путем комбинации двух созданных выше типов и типа "RouteComponentProps" из
библиотеки "react-router-dom". Последний тип мы указали, так как этот компонент хочет получить объект "match" из
функции "withRouter". "RouteComponentProps" это тип для отдельного вида "props" из функции "withRouter". В этом типе
"RouteComponentProps" мы уточнили какие свойства объекта "params" из объекта "match" из функции "withRouter" должны
содержаться внутри при помощи типа "ProfileWithRouterParamsTypes", который создали выше. Все это нужно для указания типа
"props" в классовом компоненте.*/
type PropsType = MapStateToPropsType & MapDispatchToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>;


/*
"ProfileContainer" это классовый компонент.
Классы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать
концепцию ООП.
React определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать
с этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно
взаимодействует.
Например, у него можно постоянно запрашивать JSX.
В React при создании класса мы наследуем и расширяем некий базовый класс "React.Component" при помощи "extends".
Компонент это функция, которая возвращает JSX.
Классовые компоненты могут содержать "side effects". Для этого используются методы жизненного цикла.
У классового компонента всегда есть метод render(){...}, который возвращает JSX.
При переходе по разным "Route" экземпляры классовых компонентов удаляются из памяти.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"ProfileContainer" является контейнерным компонентом для компонента "Profile".
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.tsx") из библиотеки "react-redux".
Этот компонент подключается в компоненте "App".
*/
class ProfileContainer extends React.Component<PropsType/*, StateType*/> { /*Указали, что "props" в этом классовом
компоненте имеют тип "PropsType". Еще здесь можно указать тип "state", но мы не указали.*/
    refreshProfile() { /*Создаем специальный метод, который содержит необходимый функционал для обновления
    страницы профиля.*/
        let userID: number | null = +this.props.match.params.userID; /*Получаем "ID" пользователя. HOC "withRouter"
        хранит некий объект, к которому можно обратиться как к "match.params.userID", чтобы получить значения
        дополнения ":userID" к пути "/profile/", как это указано у нас в компоненте "App". Добавили здесь "+" для
        преобразования строкового значения "this.props.match.params.userID" в числовое в целях типизации. Также указали
        явно тип "number | null" у "userID" для типизации.*/

        if (!userID) { /*Если не удалось получить "ID" пользователя, то*/
            userID = this.props.authUserID; /*пытаемся его получить от пользователя, под которым залогинены,*/
            if (!userID) { /*а если же и после этого не удалось получить "ID" пользователя, то*/
                this.props.history.push('/login/'); /*нас перенаправляет на страницу логирования. Желательно так не
                использовать "push" в компонентах, поэтому в дальнейшем это нужно заменить на что-то другое.*/
            };
        };

        if (!userID) { /*Написали вывод ошибки в консоль, если "ID" пользователя отсутствует. Но по идее не должно быть
        ситуаций, когда "ID" пользователя полностью отсутствует, возможно надо что-то изменить в проекте, чтобы не
        допускались такие случаи.*/
            console.error('ID should exist in URI params or in state');
        } else {/*Если же мы все-таки получили "ID" пользователя, то делаем следующее:*/
            this.props.getUserProfile(userID); /*вызываем TC "getUserProfile" для получения данных профиля
            пользователя и их установки на странице профиля. Без проверки на наличие "ID" пользователя в целях типизации
            пришлось бы указать, чтобы "userID" воспринимался как число при помощи "as number".*/
            this.props.getUserStatus(userID); /*вызываем TC "getUserStatus" для получения данных статуса
            пользователя и их установки на странице профиля. Без проверки на наличие "ID" пользователя в целях типизации
            пришлось бы указать, чтобы "userID" воспринимался как число при помощи "as number".*/
        }
    };

    componentDidMount() { /*Это метод жизненного цикла классового компонента. Он вызывается в момент первой
    отрисовки (монтирования) компонента.*/
        this.refreshProfile(); /*Вызываем метод "refreshProfile".*/
    };

    componentDidUpdate
    (prevProps:PropsType, prevState:MapStateToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>) {
    /*Это метод жизненного цикла классового компонента. Он вызывается в момент обновления (изменения "props" или
    "state") компонента. Указали тип для предыдущих "props" - "prevProps" в виде типа "PropsType", а для предыдущего
    "state" в виде типа "MapStateToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>", так как мы еще
    используем данный и из функции "withRouter".*/
        if (this.props.match.params.userID !== prevProps.match.params.userID) { /*Проверяем изменился ли "ID"
        пользователя в "props". Эта проверка нужна, чтобы избежать бесконечный цикл запроса новых "props" методом
        "refreshProfile": изначально срабатывает метод "refreshProfile" из "componentDidMount", получает новые "props",
        в свою очередь это триггерит метод "refreshProfile" из "componentDidUpdate", снова получаем новые "props" и
        снова триггерим метод "refreshProfile" из "componentDidUpdate" и так до бесконечности.*/
            this.refreshProfile(); /*Если изменился, то вызываем метод "refreshProfile".*/
        }
    };

    render() {
        /*
        Здесь после return в компоненте начинается HTML разметка.
        Нужно помнить, что в этой разметке должен быть только один корневой элемент.
        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
        */
        return (
            <Profile {...this.props} /*Отрисовываем компонент "Profile" и передаем ему через "props" необходимые для
            него данные. Этот элемент "Profile" и есть наш корневой элемент. Здесь используется spread-оператор "...",
            который из всех "props" создает атрибуты для компонента.*/
                     isOwner={!this.props.match.params.userID} /*Свойство, которое показывает является ли залогиненный
                     пользователь владельцем профиля, который в данный момент отображается на странице профиля. Будет
                     равно "TRUE", если в данных URL не было найдено значения дополнения ":userID" к пути "/profile/",
                     как это указано у нас в компоненте "App", т.е. пользователь совершил переход просто на "/profile/",
                     желая попасть на свою страницу, а не на чью-то другую. Это свойство нужно, чтобы интерфейс для
                     редактирования информации в профиле появлялся только на собственной странице пользователя. Хотя
                     тут есть проблема, когда мы переходим на свой профиль при помощи своего "ID" и не имеем
                     упомянутого интерфейса. Далее передается в компонент "ProfileInfo.tsx".*/
            />
        )
    }
};


const mapStateToProps = (state: AppStateType): MapStateToPropsType => ({ /*Здесь указываются данные из "state", которые
необходимо передать в компонент "ProfileContainer". Эта функция возвращает указанные данные в виде объекта. На входе
"mapStateToProps" принимает "state" с типом "AppStateType", который мы создали и импортировали сюда, а на выходе выдает
данные с типом "MapStateToPropsType".*/
    profile: state.profilePage.profile, /*Данные профиля пользователя для страницы профиля. Далее передается в
    компонент "ProfileInfo.tsx".*/
    status: state.profilePage.status, /*Данные статуса пользователя для страницы профиля. Далее передается в
    компонент "ProfileInfo.tsx".*/
    authUserID: state.auth.id, /*"ID" залогиненного пользователя.*/
});


export default compose<ComponentType>( /*При помощи функции "compose" объеденяем HOCs "withRouter" и "connect",
возвращая итоговый компонент "ProfileContainer". Здесь мы уточнили тип только одним параметром, так как согласно файлу
декларации функции "compose" (раздел "rest"), нам нужно уточнить только такой компонент, свойства "props" которого не
будут переданы в этот компонент функциями, которые были переданы внутрь функции "compose", то есть функциями "connect" и
"withRouter", то есть никакие свойства, так как мы не передаем извне ничего в компонент "ProfileContainer".*/
    connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps, { /*При
    помощи метода "connect" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL компоненту
    "ProfileContainer" в этом файле. Поскольку метод "connect" является "generic", то его можно уточнить: первым в "<>"
    указан тип для "MapStateToProps", вторым для "MapDispatchToProps", третьим для "собственных props" компонента,
    четвертым для "state". Эти параметры мы узнали перейдя в файл декларации метода "connect", "Ctrl+click" в
    "WebStorm".*/
        getUserProfile, /*TC для получения данных профиля пользователя и их установки на странице профиля.*/
        getUserStatus, /*TC для получения данных статуса пользователя и их установки на странице профиля.*/
        updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/
        saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем
        приложении.*/
        saveProfile}), /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их
        отображения в нашем приложении.*/
    withRouter /*Так же при помощи метода "withRouter" передаем в этот контейнерный компонент данные из URL.*/
)(ProfileContainer);
/*Получившийся в итоге компонент экспортируем, который будет использоваться в нашем проекте под именем
"ProfileContainer", по default, экспорт необходим для импорта.*/