import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {Redirect} from 'react-router-dom';
/*
Библиотека "react-router-dom" необходима для создания роутинга и маршрутов в приложении.
"Redirect" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется
атрибут "to".
Маршрут для пути редиректа уже должен быть создан.
*/
import {useDispatch, useSelector} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI
нежелательно общаться с BLL напрямую. Библиотека "react-redux" предоставляет продвинутые инструкции по созданию
контейнерных компонент и контекста.
"useSelector" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.
"useDispatch" - это hook, который принимает AC или TC и диспатчит их.
*/
import {InjectedFormProps, reduxForm} from 'redux-form';
/*
Библиотека "redux-form" нужна для работы с формами.
Эта библиотека добавляет в "store", то есть в глобальный "state" свой "reducer" и
обрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы
по организации данных форм в "state".
Эта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,
является общаться со своей частью в "reducer".
Эта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, "react-final-form",
который работыет на хуках. Так же может подойти "formik".
Эта библиотека, добавляя свою часть в глобальный "state", обязуется заниматься круговоротом данных (FLUX) со всеми
формами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть "state", которую создает эта библиотека,
не является по сути данными, относящимися к BLL, но при этом находятся в глобальном "state".
Также эта библиотека упрощает создание валидации форм, так как в ее "state" есть полезные для этого данные (поля и
свойства).
Так же стоит помнить, что дефолтное поведение кнопки при "submit" это отправка данных на сервер,
что является индикатором для перерисовки в React.
После создания части в глобальном "state", нужно необходимые формы обварачивать в HOC "reduxForm" из библиотеки
"redux-form" (как и метод "connect", метод "reduxForm" не совсем является HOC, он вызывается дважды, сначала мы
вызываем функцию "reduxForm" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания
мы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет
диспатчить и общаться с глобальным "state").
Каждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой "redux-form".
Вместо "input" необходимо использовать "Field" из библиотеки "redux-form". Указывая в нем атрибут "component", мы
указываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо
указывать атрибут "name", чтобы дать имя отправляемым через этот "input" данным. Библиотека "redux-form" будет
реагировать на эти атрибуты "name" и осуществлять круговорот данных.

Для получения данных при "submit" есть особый callback "handleSubmit" в "props", который создается при обворачивании
"reduxForm". В форме в событии "onSubmit" нужно указывать этот callback. В этом callback отключено дефолтное поведение
по перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается
"props.onSubmit()" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот
объект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,
срабатывающий при событии "onSubmit". Этот некий метод будет использоваться для передачи данных формы во внешний мир,
то есть в глобальный "state".

То есть в нашем случае происходит следующее:
- callback "handleSubmit" указан в компоненте "LoginForm".
- обворачиваем компонент "LoginForm" HOC-ом "reduxForm" в компоненте "LoginReduxForm", тем самым предоставляя
callback "handleSubmit" для компонента "LoginForm".
- компонент "LoginReduxForm" указывается в компоненте "Login", куда в событие "onSubmit" будет попадать объект
с данными, сформированный в событии "onSubmit" при помощи callback "handleSubmit" в компоненте "LoginForm".

То есть при срабатывании события "onSubmit" сначала вызывается callback "handleSubmit" в компоненте "LoginForm",
который собирает все данные из формы и помещает их в объект, потом внутри callback "handleSubmit" вызывается нами
созданный callback "onSubmitForm" (доступен из контейнерного компонента "LoginReduxForm") из компонента "Login",
в который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент
"LoginReduxForm", из которого перенаправляются в глобальный "state" в виде объекта под именем "login".

То есть общая логика при работе с библиотекой "redux-form" такова:
- вынести саму форму в отдельный компонент;
- повесить callback "handleSubmit" в качестве обработчика события "onSubmit" в этой форме;
- в этой форме вместо элементов "input" и прочего используем элемент "Field";
- обворачиваем эту форму HOC-ом "reduxForm".

В компонент "LoginForm" внедряются некие дополнительные "props" (например, тот же "handleSubmit") ХОКом, который
образуется при помощи компонента "LoginReduxForm". Эти "props" содержатся под именем "InjectedFormProps". Эти
"InjectedFormProps" также содержат добавленные нами "props". Поэтому мы импортировали "InjectedFormProps" из библиотеки
"reduxForm", чтобы типизировать такие "props" в компоненте "LoginForm".
*/
import {maxLengthCreator, required} from '../../utils/validators/validators'; /*Подключаем валидаторы для полей форм.*/
import {createField, GetValuesKeysType, Input} from '../common/FormsControls/FormsControls'; /*Подключаем созданный нами
компонент "Input" для создания элемента "input" с возможностью указывать валидацию. Также импортируем функцию
"createField", которая принимает параметры и создает элементы формы. Мы ее используем для создания формы в компоненте
"LoginForm". Дополнительно импортируем оттуда тип "GetValuesKeysType".*/

import {login} from '../../redux/auth-reducer'; /*Подключаем TC "login" из "auth-reducer".*/

import {
    getCaptchaURL, /*Импортируем селектор, который возвращает URL капчи при логинизации.*/
    getIsAuth /*Импортируем селектор, который возвращает информацию о том, что являемся ли мы залогинены в приложение
    или нет.*/
} from '../../redux/auth-selectors';

import styles from './Login.module.css'; /*Подключаем стили из CSS-модуля.*/
import style from '../common/FormsControls/FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/


/*Создаем общий тип для всех "props" компонента "Login" путем комбинации двух созданных выше типов "MapStateToPropsType"
и "MapDispatchToPropsType". Все это нужно для указания типа "props" в функциональном компоненте "Login".*/
type LoginPropsType = {

};

/*Создаем тип для "собственных props" компонента "LoginForm". "Собственные props" в этом компоненте должны обязательно
содержать следующие поля с указанными типами.*/
type LoginFormOwnPropsType = {
    captchaURL: string | null /*Путь к капче, который должен быть строкой или "null", то есть быть пустым.*/
};

/*Создаем тип для "props" компонента "LoginForm", которые будут использоваться в "formData" для компонента "Login". Эти
"props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.*/
type LoginFormValuesType = {
    email: string /*"Email" пользователя, который должен быть строкой.*/
    password: string /*Пароль пользователя, который должен быть строкой.*/
    rememberMe: boolean /*Информация запомнить ли пользователя, которая должна быть булева типа.*/
    captcha: string /*Путь к капче, который должен быть строкой.*/
};

/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства "name" в "createField".
Это свойство важно для формирования имен свойств "formData", то есть данных формы. Для этого мы использовали созданный
нами и иимпортированный сюда вспомогательный тип "GetValuesKeysType". Нужные нам имена свойств уже перечислены в типе
"LoginFormValuesType", поэтому мы при помощи этого типа "GetValuesKeysType" получаем типы ключей из типа
"LoginFormValuesType".*/
type LoginFormValuesKeysType = GetValuesKeysType<LoginFormValuesType>;


const maxLength30 = maxLengthCreator(30); /*Создали валидатор, который проверяет не введено ли больше
30 символов в поле.*/


/*
"LoginForm" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function LoginForm(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"LoginForm" является компонентом, который представляет из себя форму логинизации в виде заготовки для обворачивания ее
в HOC "reduxForm".
Этот компонент подключается в компоненте "LoginReduxForm" и обварачивается там в HOC "reduxForm", тем самым получая
callback "handleSubmit".
*/
const LoginForm: React.FC<InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType> =
    ({handleSubmit, error, captchaURL}) => {
    /*При помощии деструктуризации "props" указываем какие именно "props" мы получаем, чтобы не писать далее
    "props.handleSubmit", "props.error" и так далее:
    - callback "handleSubmit";
    - "error" - текст ошибки, которая может появиться при использовании формы, формируется при помощи библиотеки
    - "redux-form";
    - "captchaURL" - URL капчи при логинизации.
    Такое мы делаем только в функциональных компонентах.
    Указали при помощи "React.FC<>", что "props" в этом функциональном компоненте имеют тип
    "InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType>". Такая комбинация
    получилась следующим образом:
    - "InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType>" - здесь мы уточнили внедренные ХОКом, который
    образуется при помощи компонента "LoginReduxForm", "InjectedFormProps". "LoginFormValuesType" указывает, что
    приходит из этого ХОКа, а "LoginFormOwnPropsType" указывает, что приходит со стороны - "captchaURL".
    - "& LoginFormOwnPropsType" - также этот компонент содержит некие свои собственные "props", которые не приходят от
    ХОКа выше - тот же "captchaURL".
    Это мы сделали на основании файла декларации "InjectedFormProps" ("Ctrl+click" в "WebStorm"). Там указано, что
    первым параметром принимаются "formData" - то есть какие именно данные собирает форма в компоненте, вокруг которого
    обворачиваем "reduxForm" (то есть компонент "LoginForm"), и собственные "props" этого компонента "LoginForm",
    которые не приходят от ХОКа выше (так нужно для внутренней работы "InjectedFormProps"); а вторым параметром
    принимаются еще раз некие свои собственные "props", которые не приходят от ХОКа выше (так уже надо для работы самого
    этого компонента "LoginForm"). Третьим параметром принимается вид ошибки формы типа строка, но в данном случае мы
    этого не указываем. Только все эти три параметра указываются как бы вместе как единый параметр, а не через запятую
    как три разных параметра. ВОЗМОЖНО, это потому, что "InjectedFormProps" это объект (как единое целое состоит из
    разных свойств, которые можно типизировать суммой разных типов), а тот же "reduxForm" это функция (принимает
    последовательность параметров, где каждый параметр нужно отдельно типизировать).
    */

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <form onSubmit={handleSubmit}> {/*Здесь в элементе "form "в событии "onSubmit" указывает
        callback "handleSubmit". Этот элемент "form" и есть наш корневой элемент"*/}
            {createField<LoginFormValuesKeysType>
            ('Email', 'email', Input, [required, maxLength30])}
            {/*Создали поле для ввода почты на основе импортированной функции "createField". Уточняем здесь функцию
            "createField", что она имеет тип "LoginFormValuesKeysType", созданный нами выше.*/}
            {createField<LoginFormValuesKeysType>
            ('Password', 'password', Input, [required, maxLength30], {type: 'password'})}
            {/*Создали поле для ввода пароля на основе импортированной функции "createField". Уточняем здесь функцию
            "createField", что она имеет тип "LoginFormValuesKeysType", созданный нами выше.*/}
            {createField<LoginFormValuesKeysType>
            (undefined, 'rememberMe', Input, [], {type: 'checkbox'}, 'Remember me?')}
            {/*Добавили чек-бокс "Запомнить меня?" на основе импортированной функции "createField". "undefined" означает
            отсутствие свойства.  Уточняем здесь функцию "createField", что она имеет тип "LoginFormValuesKeysType",
            созданный нами выше.*/}

            {captchaURL && <img src={captchaURL} alt=''/>} {/*Если есть капча, то отрисуем элемент "img"
            с изображением капчи.*/}
            {captchaURL && createField<LoginFormValuesKeysType>
            ('Enter the captcha', 'captcha', Input, [required])}
            {/*Если есть капча, то отрисуем поле для ввода текства с капчи. Это поле создается на основе импортированной
            функции "createField". Уточняем здесь функцию "createField", что она имеет тип "LoginFormValuesKeysType",
            созданный нами выше.*/}

            {error && <div className={style.formSummaryError}>{error}</div>} {/*Если произошла какая-то ошибка, то
            выведем ее в отдельном элементе "div". Свойство "error" будет в объекте "props" благодаря
            библиотеке "redux-form", в него подцепится значение из TC "login" из "auth-reducer.ts".*/}

            <div> {/*Создаем специальный элемент "div", внутри которого будет находится элемент "button", который будет
            использоваться как кнопка для сабмита данных введенных в форму.*/}
                <button>Log in</button>
            </div>
        </form>
    );
};


/*Это отдельный контейнерный компонент, цель которого обвернуть компонент "LoginForm" в HOC "reduxForm", чтобы
предоставить callback "handleSubmit". Именно компонент "LoginReduxForm" будет заниматься общением
с глобальным "state".*/
const LoginReduxForm = reduxForm<LoginFormValuesType, LoginFormOwnPropsType>({ /*"reduxForm" является "generic",
поэтому мы его уточнили. В файле декларации "reduxForm" ("Ctrl+click" в "WebStorm") указано, что он принимает следующие
данные:
- "formData" - то есть какие именно данные собирает форма в компоненте, вокруг которого обворачиваем "reduxForm" (то
есть компонент "LoginForm");
- "собственные props" компонента, вокруг которого обворачиваем "reduxForm" (то есть компонент "LoginForm");
- вид ошибки формы типа строка, но в данном случае мы этого не указываем.*/
    form: 'login' /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный "state".*/
})(LoginForm);


/*
"Login" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function Login(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"Login" является компонентом, который представляет из себя финальную страницу с формой логинизации.
Этот компонент подключается в компоненте "App".
Внутри компонента "Login" подключается компонент "LoginReduxForm", в котором обворачиваем компонент "LoginForm"
HOC-ом "reduxForm", тем самым предоставляя callback "handleSubmit" для компонента "LoginForm".
*/
export const Login: React.FC<LoginPropsType> = (props) => { /*Указали при помощи
"React.FC<>", что "props" в этом функциональном компоненте имеют тип "LoginPropsType", созданный нами выше. Также
указали, что экспортируем этот компонент.*/
    const captchaURL = useSelector(getCaptchaURL); /*При помощи хука "useSelector", передав в него селектор
    "getCaptchaURL", получаем URL капчи при логинизации.*/
    const isAuth = useSelector(getIsAuth); /*При помощи хука "useSelector", передав в него селектор "getIsAuth",
    получаем информацию о том, что являемся ли мы залогинены в приложение или нет.*/

    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука "useDispatch".*/

    const onSubmitForm = (formData: LoginFormValuesType) => { /*Создали специальный callback "onSubmitForm", который
    будет вызываться при срабатывании события "onSubmit" в форме. Этот callback будет собирать все данные формы (email
    пользователя, пароль пользователя, указание запомнить ли данные входа, и капча, если присуствует) в одном месте. Эти
    данные будут отдаваться TC "login" для осуществления логинизации. Этот callback получает указанные данные на входе в
    объекте "formData" с типом "LoginFormValuesType".*/
        dispatch(login(formData.email, formData.password, formData.rememberMe, formData.captcha));
    };

    if (isAuth) { /*Если пользователь залогинен, то его должно перенаправить на страницу профиля, вместо показа
    формы для логинизации.*/
        return <Redirect to={'/profile/'}/>
    };

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            <h1>Log in</h1> {/*Отрисовываем элемент "h1" c текстом "Log in".*/}
            <LoginReduxForm onSubmit={onSubmitForm} captchaURL={captchaURL}/> {/*Здесь в событии "onSubmit" будет
            приходить объект с данными из callback "handleSubmit" из компонента "LoginForm", который обвернут
            компонентом "LoginReduxForm". Далее будет вызываться при этом событии нами созданный
            callback "onSubmitForm", в который будет передаваться этот объект с данными. После этого эти данные будут
            отправлятся в часть глобального "state", которую обрабатывает библиотека "redux-form", с целью
            осуществления работы нашей формы логина. Поскольку мы вызываем функцию "onSubmitForm" как callback,
            поэтому не ставим "()" после имени функции.*/}
        </div>
    );
};