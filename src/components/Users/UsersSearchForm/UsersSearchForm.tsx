import React from 'react';
import {useSelector} from 'react-redux';
/*Используем библиотеку Formik как аналог библиотеки Redux Form. Последнее нас не устраивает тем, что библиотека
Redux Form использует store из библиотеки Redux, храня среди данных BLL данные UI, и может лишний раз спровоцировать
перерисовку приложения.

Импортируем "Formik" из этой библиотеки, чтобы создавать компонент "Formik", внутри которого указывается код для
создания формы. Внутри можно указать атрибут "validate", в котором можно указывать валидацию формы. Также внутри нужно
указывать атрибут "onSubmit", который должен содержать логику сабмита данных формы. Также внутри можно указать атрибут
"initialValues", содержащий стартовые значения данных формы, которые будут в ней собираться.

Импортируем "Form" из этой библиотеки, чтобы создавать компонент "Form", внутри которого идет создание самой формы с ее
полями.

Импортируем "Field" из этой библиотеки, чтобы создавать компонент "Field", внутри которого идет создание поля для формы.
Внутри может указываться атрибут "name" для именования данных, которые будут собираться в этом поле и обрабатываться
далее в приложении, то есть это аналог атрибута "name" из библиотеки Redux Form.*/
import {Field, Form, Formik} from 'formik';
/*Импортируем селекторы "getUsersFilter()" и "getIsFetching()".*/
import {getUsersFilter, getIsFetching} from '../../../redux/users-selectors';
/*Импортируем тип "UsersFilterType".*/
import {UsersFilterType} from '../../../redux/users-reducer';

type PropsType = {
    /*Метод для обновления данных по фильтрам для отображения пользователей в постраничном выводе пользователей при
    изменении этих данных должен быть функцией, принимающей параметр типа "UsersFilterType" и ничего не возвращающей.*/
    onFilterChange: (filter: UsersFilterType) => void
};

/*Указываем тип для свойства, содержащее значение для фильтра, работающее следующим образом: если указать в нем "true",
то сервер выберет только тех пользователей, которых мы фолловим, если указать "false" - только тех, кого мы не фолловим,
если указать "null" или вообще не указывать, то выберет всех пользователей. Здесь мы специально указали это в виде
строковых значений, так как библиотека Formik работает внутри формы со строковыми значениями. Но в самой форме мы делаем
преобразования в булев тип и в null для нашего state и для запросов на сервер.*/
type FilterFriendFormType = 'true' | 'false' | 'null';

/*Создаем отдельный тип для данных, которые собирает форма ниже в компоненте "UsersSearchForm".*/
type FormType = {
    /*Свойство, содержащее значение для фильтра в виде строкового значения, которое будет получать сервер и искать
    наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких пользователей.*/
    term: string
    /*Свойство, которое содержит значение для фильтра булева типа. Если указать в нем "true", то сервер выберет только
    тех пользователей, которых мы фолловим, если указать "false" - только тех, кого мы не фолловим, если указать "null"
    или вообще не указывать, то выберет всех пользователей. Должно быть типа "FilterFriendFormType", который мы создали
    выше.*/
    friend: FilterFriendFormType
};

/*Выносим отдельно функцию для валидации формы, которая указывается в атрибуте "validate" в компоненте "Formik" из
библиотеки Formik.*/
const usersSearchFormValidate = (values: any) => {
    /*В данном случае не указали никаких ошибок при валидации.*/
    const errors = {};
    return errors;
};

/*"UsersSearchForm" это функциональный компонент, который создан в виде стрелочной функции. "UsersSearchForm" является
компонентом, который отображает форму с фильтрами для поиска пользователей на странице с постраничным выводом
пользователей.

Компонент "UsersSearchForm" импортируется в файле "Users.tsx".

Для оптимизации лишних отрисовок мы оборачиваем этот функциональный компонент при помощи "React.memo()".*/
export const UsersSearchForm: React.FC<PropsType> = React.memo(({onFilterChange}) => {
    /*При помощи хука "useSelector()", передав в него селектор "getUsersFilter()", получаем данные для фильтрации
    пользователей в постраничном выводе.*/
    const filter = useSelector(getUsersFilter);
    /*При помощи хука "useSelector()", передав в него селектор "getIsFetching()", получаем специальное свойство,
    находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного вывода (если в
    процессе, то будет отрисовываться компонент-заглушка "Preloader").*/
    const isFetching = useSelector(getIsFetching);

    /*Создаем callback-функцию "onSubmitForm()", которая будет указываться в атрибуте "onSubmit" в компоненте "Formik"
    из библиотеки Formik и содержать логику сабмита данных формы. Согласно библиотеке Formik эта функция должна
    принимать значения данных формы в виде первого параметра "values", который имеет тип "FormType", созданный нами
    выше. Вторым параметром эта функция должна принимать функцию "setSubmitting()" (будет получена при помощи
    деструктуризации). Указываем, что эта функция "setSubmitting()" является функцией, принимающей булев параметр
    "isSubmitting" (указываемый внутри стрелочной функции элемента "Formik", возвращающей элемент "Form", содержащий
    саму форму) и ничего не возвращает. При срабатывании этой функции формируется объект "filter" на основе данных формы
    при их сабмите, содержащий данные по фильтрам для отображения пользователей в постраничном выводе пользователей.
    Затем вызывается метод "onFilterChange()", в который передается этот объект "filter", далее благодаря срабатыванию
    метода "onFilterChange()" данные по фильтрам устанавливаются в наш state и формируется запрос данных по
    пользователям для постраничного вывода на сервер, содержащий фильтры для отображения пользователей в постраничном
    выводе. Также при помощи функции "setSubmitting()" мы отключаем нашу кнопку на время пока идет запрос данных по
    пользователям на сервер.*/
    const onSubmitForm = (values: FormType, {setSubmitting}: { setSubmitting: (isSubmitting: boolean) => void }) => {
        /*Создаем объект, который содержит данные по фильтрам для отображения пользователей в постраничном выводе
        пользователей. Он будет получать эти данные из формы, которые будут в ней собираться в объекте "values" при
        сабмите данных и попадать в эту callback-функцию.*/
        const filter: UsersFilterType = {
            /*Строковое значение из "values.term" сохраняем как есть.*/
            term: values.term,
            /*Здесь же строковые значения из "values.friend" мы преобразовываем в null и булев тип для нашего state и
            для запросов на сервер.*/
            friend: values.friend === 'null' ? null : values.friend === 'true' ? true : false
        };

        onFilterChange(filter);

        if (!isFetching) {
            setSubmitting(false);
        } else {
            setSubmitting(true);
        }
    };

    return (
        <div>
            {/*Создаем элемент "Formik" из библиотеки Formik для создания формы. Внутри указываем атрибуты
            "initialValues", "validate" и "onSubmit".*/}
            <Formik
                /*Таким образом указываем библиотеке Formik, чтобы она переинициировала форму при получении новых props,
                например, "filter.term" или "filter.friend". Если не указывать значение этого атрибута, то будет тоже
                true.*/
                enableReinitialize={true}
                /*В атрибуте "initialValues", содержащем стартовые значения данных формы, которые будут в ней
                собираться, указываем значения "filter.term" и "filter.friend" для свойств "term" и "friend"
                соответственно. Значение "filter.friend" мы преобразовываем в строку при помощи функции "String()" и
                указываем, чтобы полученное значение воспринималось как типа "FilterFriendFormType" при помощи
                "as FilterFriendFormType". Нам нужны здесь строковые значения, так как библиотека Formik работает внутри
                со строковыми значениями данных формы.*/
                initialValues={{term: filter.term, friend: String(filter.friend) as FilterFriendFormType}}
                /*В атрибуте "validate", ответственного за валидацию формы из библиотеки Formik, указываем функцию
                "usersSearchFormValidate()", которую создали выше.*/
                validate={usersSearchFormValidate}
                /*В атрибуте "onSubmit", ответственного за логику сабмита данных формы из библиотеки Formik, указываем
                функцию "onSubmitForm()", которую создали выше.*/
                onSubmit={onSubmitForm}
            >
                {/*Внутри элемента "Formik" должна указываться таким образом стрелочная функция, которая принимает булев
                параметр "isSubmitting" и возвращает элемент "Form", содержащий саму форму. Параметр "isSubmitting"
                нужен для того, что знать происходит ли сейчас сабмит данных формы или нет. Пока происходит сабмит
                данных формы библиотека Formik по умолчанию делает неактивной кнопку сабмита данных.*/}
                {({isSubmitting}) => (
                    /*При помощи элемента "Form" из библиотеки Formik создаем саму форму. Внутри указываем поля формы
                    при помощи элементов "Field" из библиотеки Formik.*/
                    <Form>
                        {/*Первое поле формы имеет тип поля для ввода текста и собирает данные в виде свойства "term". В
                        этом поле будет вводиться текст, отправляемый на сервер, чтобы сервер мог отфильтровать
                        пользователей, которые содержат этот текст в своем имени, и выдать нам таких пользователей.*/}
                        <Field type='text' name='term'/>

                        {/*Второе поле формы имеет тип выпадающего списка и собирает данные в виде свойства "friend". В
                        этом поле будет выбираться одна из трех опций, которые созданы ниже при помощи элементов
                        "option", и значение этой выбранной опции будет отправляться на сервер, чтобы сервер в
                        зависимости от полученного значение мог отфильтровать пользователей для выдачи их нам.*/}
                        <Field as='select' name='friend'>
                            {/*Первым значением в выпадающем списке будет "null", что для сервера будет означать вывести
                            всех пользователей.*/}
                            <option value='null'>All</option>
                            {/*Вторым значением в выпадающем списке будет "true", что для сервера будет означать вывести
                            только тех пользователей, которых мы фолловим.*/}
                            <option value='true'>Followed</option>
                            {/*Третьим значением в выпадающем списке будет "false", что для сервера будет означать
                            вывести только тех пользователей, которых мы не фолловим.*/}
                            <option value='false'>Unfollowed</option>
                        </Field>

                        {/*Внутри формы также создаем кнопку с текстом "Find" для сабмита данных формы. Также этот
                        элемент содержит атрибут "disabled" со значением равным "isSubmitting". Если "isSubmitting"
                        равен, то таким образом можно указать, что больше не происходит сабмит данных формы для того,
                        чтобы кнопка сабмита данных снова стала активна, и мы могли указать новые данные фильтров и
                        сделать сабмит данных.*/}
                        <button type='submit' disabled={isSubmitting}>
                            Find
                        </button>
                    </Form>
                )}
            </Formik>
        </div>
    )
});