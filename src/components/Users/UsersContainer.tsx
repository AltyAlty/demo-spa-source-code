import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Это прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC (ХОК) - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/
import {compose} from 'redux';
/*
Функция "compose" из функционального программирования. Эта функция создает композицию обработчиков.
Библиотека "redux" содержит свою реализацию "compose". При помощи функции "compose" можно объеденять, например,
несколько обверток вокруг компонента и ХОКи.
Обвертки и ХОКи указываются снизу вверх. Функция "compose" вызывается дважды и работает схожим образом, как и метод
"connect" из библиотеки "react-redux".
*/

import {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC "withAuthRedirect" для
добавления редиректа. В данный момент не используется.*/

import {
    setCurrentPage, /*Подключаем AC "setCurrentPage" из "users-reducer".*/
    requestUsers, /*Подключаем TC "requestUsers" из "users-reducer".*/
    follow, /*Подключаем TC "follow" из "users-reducer".*/
    unfollow /*Подключаем TC "unfollow" из "users-reducer".*/
} from '../../redux/users-reducer';

import Users from './Users'; /*Подключаем компонент "Profile".*/
import Preloader from '../common/Preloader/Preloader'; /*Подключаем компонент "Preloader".*/

import {
    getCurrentPage, /*Импортируем селектор, который возвращает общее количество пользователей.*/
    getIsFetching, /*Импортируем селектор, который возвращает специальное свойство, которое обозначает находится ли в
    процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/
    getPageSize, /*Импортируем селектор, который возвращает максимальное количество пользователей, которое выводится в
    постраничном выводе пользователей.*/
    getTotalUsersCount, /*Импортируем селектор, который возвращает общее количество пользователей.*/
    getWhoIsInFollowingProgress, /*Импортируем селектор, который возвращает специальное свойство, которое содержит
    массив, который будет хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе
    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
    getUsers, /*Импортируем селектор, который возвращает данные по пользователям для постраничного вывода.*/
    getPortionSize /*Импортируем селектор, который возвращает свойство, которое указывает какое количество номеров
    страниц в постраничном выводе может отображаться в одной порции таких страниц.*/
} from '../../redux/users-selectors'; /*Импортируем селекторы для компонента "UsersContainer".*/

import {UserType} from '../../types/types'; /*Импортируем типы.*/
import {AppStateType} from '../../redux/redux-store'; /*Импортируем типы.*/


/*Создаем тип для "MapStateToProps". "MapStateToProps" в этом компоненте должен обязательно содержать следующие поля с
указанными типами.*/
type MapStateToPropsType = {
    currentPage: number /*Номер текущей выбранной страницы в постраничном выводе должен быть числом.*/
    pageSize: number /*Максимальное количество пользователей на одной странице в постраничном выводе должно быть
    числом.*/
    isFetching: boolean /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение
    данных по пользователям для постраничного вывода (если в процессе, то будет отрисовываться компонент-заглушка
    "Preloader"), должно быть булева типа.*/
    totalUsersCount: number /*Общее количество пользователей должно быть числом.*/
    users: Array<UserType> /*Данные по пользователям для постраничного вывода должны быть в виде массива элементов с
    типом "UserType", который был создан нами и импортирован сюда.*/
    portionSize: number /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном
    выводе может отображаться в одной порции таких страниц, должно быть числом.*/
    WhoIsInFollowingProgress: Array<number> /*Специальное свойство, которое содержит массив, который будет хранить "ID"
    пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним
    отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя, должно быть массивом чисел.*/
};

/*Создаем тип для "MapDispatchToProps". "MapDispatchToProps" в этом компоненте должен обязательно содержать следующие
поля с указанными типами.*/
type MapDispatchToPropsType = {
    requestUsers: (currentPage: number, pageSize: number) => void /*TC для запроса и установки данных по пользователям
    в постраничном выводе должно быть функцией, которая принимает числовой параметр и ничего не возвращает.*/
    setCurrentPage: (pageNumber: number) => void /*AC для установки значения текущей выбранной страницы в постраничном
    выводе пользователей в "state" должно быть функцией, которая принимает числовой параметр и ничего не возвращает.*/
    unfollow: (id: number) => void /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой
    параметр и ничего не возвращает.*/
    follow: (id: number) => void /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой
    параметр и ничего не возвращает.*/
};

/*Создаем тип для "собственных props" (для учебных целей в рамках изучения типов для "props" свойство"pageTitle"
передали сюда в "App.js"). "Собственные props" в этом компоненте должны обязательно содержать следующие поля с
указанными типами.*/
type OwnPropsType = {
    pageTitle: string /*Свойство "pageTitle" должно быть строкой.*/
};

/*Создаем общий тип для всех "props" путем комбинации трех созданные выше типов. Все это нужно для указания типа
"props" в классовом компоненте.*/
type PropsType = MapStateToPropsType & MapDispatchToPropsType & OwnPropsType;

/*
"UsersContainer" это классовый компонент.
Классы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать
концепцию ООП.
React определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать
с этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно
взаимодействует.
Например, у него можно постоянно запрашивать JSX.
В React при создании класса мы наследуем и расширяем некий базовый класс "React.Component" при помощи "extends".
Компонент это функция, которая возвращает JSX.
Классовые компоненты могут содержать "side effects". Для этого используются методы жизненного цикла.
У классового компонента всегда есть метод render(){...}, который возвращает JSX.
При переходе по разным "Route" экземпляры классовых компонентов удаляются из памяти.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"UsersContainer" является контейнерным компонентом для компонента "Users".
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.js") из библиотеки "react-redux".
Этот компонент подключается в компоненте "App".
*/
class UsersContainer extends React.Component<PropsType/*, StateType*/> { /*Указали, что "props" в этом классовом
компоненте имеют тип "PropsType". Еще здесь можно указать тип "state", но мы не указали.*/
    componentDidMount() {/*Это метод жизненного цикла классового компонента. Он вызывается в момент первой
    отрисовки (монтирования) компонента.*/
        const {currentPage, pageSize} = this.props; /*Создаем две константы "currentPage" (текущая выбранная страница
        в постраничном выводе) и "pageSize" (максимальное количество пользователей на одной странице в постраничном
        выводе), и передаем в них значения из "props", эти значения подхватяться из-за совпадения имен. В классовом
        компоненте порой лучше сделать деструктуризацию параметров из "props", так как возможно могут быть какие-то
        проблемы с лишней перерисовкой. "{}" здесь обозначают деструктуризацию.*/
        this.props.requestUsers(currentPage, pageSize); /*Вызываем TC "requestUsers" для запроса и установки данных
        по пользователям в постраничном выводе, передав значение текущей выбранной страницы и максимальное количество
        пользователей на одной странице в постраничном выводе.*/
    };

    onPageChange = (pageNumber: number) => { /*Создали специальный метод, который будет вызываеться при смене страницы
    в постраничном выводе пользователей, принимает номер новой текущей выбранной страницы.*/
        const {pageSize} = this.props; /*Создаем константу "pageSize" (количество пользователей на одной странице
        в постраничном выводе), и передаем в нее значение из "props", это значение подхватится из-за совпадения имен.
        В классовом компоненте порой лучше сделать деструктуризацию параметров из "props", так как возможно могут быть
        какие-то проблемы с лишней перерисовкой. "{}" здесь обозначают деструктуризацию.*/
        this.props.setCurrentPage(pageNumber); /*Вызываем AC "setCurrentPage" для установки значения текущей выбранной
        страницы в постраничном выводе пользователей в "state", передав номер новой текущей выбранной страницы.*/
        this.props.requestUsers(pageNumber, pageSize); /*Вызывае TC "requestUsers" для запроса и установки данных
        по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы и максимальное
        количество пользователей на одной странице в постраничном выводе.*/
    };

    render() {
        /*
        Здесь после return в компоненте начинается HTML разметка.
        Нужно помнить, что в этой разметке должен быть только один корневой элемент.
        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
        */
        return <> {/*Этот пустой элемент и есть наш корневой элемент.*/}
            <h2>{this.props.pageTitle}</h2> {/*Для учебных целей в рамках изучения типов для "props" выводим значение
            свойства "pageTitle" в элементе "h2"*/}

            {this.props.isFetching ? <Preloader/> : null} {/*Если в "state" значение "isFetching" является "true",
            то показываем компонент "Preloader". Этот элемент "Preloader" и будет нашим корневым элементом.
            Если же компонент "Preloader" не отрисовывается, то далее отрисовываем компонент "Users" и передаем ему
            через "props" необходимые для него данные. Этот элемент "Users" и будет нашим корневым элементом.*/}
            <Users totalUsersCount={this.props.totalUsersCount} /*Общее количество пользователей. Далее передается
                   в компонент "Paginator".*/
                   pageSize={this.props.pageSize} /*Максимальное количество пользователей на одной странице в
                   постраничном выводе. Далее передается в компонент "Paginator".*/
                   currentPage={this.props.currentPage} /*Номер текущей выбранной страницы в постраничном выводе. Далее
                   передается в компонент "Paginator".*/
                   onPageChange={this.onPageChange} /*Метод "onPageChange" для обновления данных при смене текущей
                   выбранной страницы в постраничном выводе. Далее передается в компонент "Paginator".*/
                   users={this.props.users} /*Данные по пользователям для постраничного вывода. Далее мапиться для
                   отрисовки компонентов "User".*/
                   WhoIsInFollowingProgress={this.props.WhoIsInFollowingProgress} /*Специальное свойство, которое
                   содержит массив, который будет хранить "ID" пользователей, которые в какой-то определенный момент
                   находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для
                   анфолловинга/фолловинга от пользователя. Далее передается в компонент "User".*/
                   unfollow={this.props.unfollow} /*TC для анфолловинга пользователей. Далее передается в
                   компонент "User".*/
                   follow={this.props.follow} /*TC для фолловинга пользователей. Далее передается в компонент "User".*/
                   portionSize={this.props.portionSize} /*Свойство, которое указывает какое максимальное количество
                   номеров страниц в постраничном выводе может отображаться в одной порции таких страниц. Это сделано,
                   чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность выбирать
                   страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими порциями страниц.
                   Далее передается в компонент "Paginator".*/
            />
        </>
    }
};

const mapStateToProps = (state: AppStateType): MapStateToPropsType => {/*Здесь указываются данные из "state", которые
необходимо передать в компонент "ProfileContainer". Эта функция возвращает указанные данные в виде объекта. Эти данные
мы получаем при помощи созданных нами селекторов из "users-selectors.ts". На входе "mapStateToProps" принимает "state"
с типом "AppStateType", который мы создали и импортировали сюда, а на выходе выдает данные с типом
"MapStateToPropsType".*/
    return {
        users: getUsers(state), /*Данные по пользователям для постраничного вывода пользователей.*/
        pageSize: getPageSize(state), /*Максимальное количество пользователей, которое выводится в постраничном выводе
        пользователей.*/
        totalUsersCount: getTotalUsersCount(state), /*Общее количество пользователей.*/
        currentPage: getCurrentPage(state), /*Текущий номер выбранной страницы в постраничном выводе пользователей.*/
        isFetching: getIsFetching(state), /*Специальное свойство, которое обозначает находится ли в процессе запрос
        на сервер на получение данных по пользователям для постраничного вывода. Если в процессе, то будет
        отрисовываться компонент-заглушка "Preloader".*/
        WhoIsInFollowingProgress: getWhoIsInFollowingProgress(state), /*Специальное свойство, которое содержит массив,
        который будет хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе
        анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
        portionSize: getPortionSize(state) /*Свойство, которое указывает какое количество номеров страниц в постраничном
        выводе может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц,
        коих огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40)
        и переключаться между этими порциями страниц.*/
    }
};

export default compose( /*При помощи функции "compose" объеденяем ХОКи "withAuthRedirect" и "connect", возвращая
итоговый компонент "AppContainer".*/
    // TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState
    connect<MapStateToPropsType, MapDispatchToPropsType, OwnPropsType, AppStateType>(mapStateToProps, {
    /*При помощи метода "connect" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL в
    другой контейнерный компонент "UsersContainer" из этого файла. Поскольку метод "connect" является "generic", то
    его можно уточнить: первым в "<>" указан тип для "MapStateToProps", вторым для "MapDispatchToProps", третьим для
    "собственных props" компонента, четвертым для "state". Эти параметры мы узнали перейдя в файл декларации метода
    "connect", "Ctrl+click" в "WebStorm".*/
        setCurrentPage, /*AC для установки текущего номера выбранной страницы в постраничном выводе пользователей.*/
        requestUsers, /*TC для запроса с сервера и установки в "state" данных по пользователя для постраничного вывода
        пользователей.*/
        follow, /*TC для фолловинга пользователей в постраничном выводе пользователей.*/
        unfollow /*TC для анфолловинга пользователей в постраничном выводе пользователей.*/
    }),
    //withAuthRedirect /*При помощи ХОКа "withAuthRedirect" добавляем логику по редиректу в компонент.*/
)(UsersContainer);
/*
Получившийся в итоге компонент экспортируем, который будет использоваться под именем "UsersContainer", по default,
экспорт необходим для импорта.
*/