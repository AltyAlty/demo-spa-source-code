import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Это прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/

import {
    requestUsers, /*Подключаем TC "requestUsers" из "users-reducer.ts".*/
    follow, /*Подключаем TC "follow" из "users-reducer.ts".*/
    unfollow, /*Подключаем TC "unfollow" из "users-reducer.ts".*/
    UsersFilterType /*Подключаем типы из "users-reducer.ts".*/
} from '../../redux/users-reducer';

import {usersAC} from '../../redux/users-reducer'; /*Подключаем объект "usersAC", что использовать оттуда AC
"setCurrentPage" из "users-reducer" */

import Users from './Users'; /*Подключаем компонент "Profile".*/
import Preloader from '../common/Preloader/Preloader'; /*Подключаем компонент "Preloader".*/

import {
    getCurrentPage, /*Импортируем селектор, который возвращает общее количество пользователей.*/
    getIsFetching, /*Импортируем селектор, который возвращает специальное свойство, которое обозначает находится ли в
    процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/
    getPageSize, /*Импортируем селектор, который возвращает максимальное количество пользователей, которое выводится в
    постраничном выводе пользователей.*/
    getTotalUsersCount, /*Импортируем селектор, который возвращает общее количество пользователей.*/
    getWhoIsInFollowingProgress, /*Импортируем селектор, который возвращает специальное свойство, которое содержит
    массив, который будет хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе
    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
    getUsers, /*Импортируем селектор, который возвращает данные по пользователям для постраничного вывода.*/
    getPortionSize, /*Импортируем селектор, который возвращает свойство, которое указывает какое количество номеров
    страниц в постраничном выводе может отображаться в одной порции таких страниц.*/
    getUsersFilter /*Импортируем селектор, который возвращает данные по фильтрам для отображения пользователей в
    постраничном выводе пользователей.*/
} from '../../redux/users-selectors'; /*Импортируем селекторы для компонента "UsersContainer".*/

import {UserType} from '../../types/types'; /*Подключаем типы.*/
import {AppStateType} from '../../redux/redux-store'; /*Подключаем типы.*/


/*Создаем тип для "MapStateToProps". "MapStateToProps" в этом компоненте должен обязательно содержать следующие поля с
указанными типами.*/
type MapStateToPropsType = {
    currentPage: number /*Номер текущей выбранной страницы в постраничном выводе должен быть числом.*/
    pageSize: number /*Максимальное количество пользователей на одной странице в постраничном выводе должно быть
    числом.*/
    isFetching: boolean /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение
    данных по пользователям для постраничного вывода (если в процессе, то будет отрисовываться компонент-заглушка
    "Preloader"), должно быть булева типа.*/
    totalUsersCount: number /*Общее количество пользователей должно быть числом.*/
    users: Array<UserType> /*Данные по пользователям для постраничного вывода должны быть в виде массива элементов с
    типом "UserType", который был создан нами и импортирован сюда.*/
    portionSize: number /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном
    выводе может отображаться в одной порции таких страниц, должно быть числом.*/
    WhoIsInFollowingProgress: Array<number> /*Специальное свойство, которое содержит массив, который будет хранить "ID"
    пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним
    отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя, должно быть массивом чисел.*/
    filter: UsersFilterType /*Свойство, которое содержит объект, внутри которого указываются фильтры для выборки
    пользователей в постраничном выводе, должно быть типа "UsersFilterType", который мы создали и импортировали сюда.*/
};

/*Создаем тип для "MapDispatchToProps". "MapDispatchToProps" в этом компоненте должен обязательно содержать следующие
поля с указанными типами.*/
type MapDispatchToPropsType = {
    requestUsers: (currentPage: number, pageSize: number, filter: UsersFilterType) => void /*TC для запроса и установки
    данных по пользователям в постраничном выводе должен быть функцией, которая принимает два числовых параметра и один
    параметр с типом "UsersFilterType", который мы создали и импортировали сюда, и ничего не возвращает.*/
    setCurrentPage: (pageNumber: number) => void /*AC для установки значения текущей выбранной страницы в постраничном
    выводе пользователей в "state" должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/
    unfollow: (id: number) => void /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой
    параметр и ничего не возвращает.*/
    follow: (id: number) => void /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой
    параметр и ничего не возвращает.*/
};

/*Создаем тип для "собственных props" (для учебных целей в рамках изучения типов для "props" свойство"pageTitle"
передали сюда в "App.tsx"). "Собственные props" в этом компоненте должны обязательно содержать следующие поля с
указанными типами.*/
type OwnPropsType = {
    pageTitle: string /*Свойство "pageTitle" должно быть строкой.*/
};

/*Создаем общий тип для всех "props" путем комбинации трех созданных выше типов. Все это нужно для указания типа
"props" в классовом компоненте.*/
type PropsType = MapStateToPropsType & MapDispatchToPropsType & OwnPropsType;


/*
"UsersContainer" это классовый компонент.
Классы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать
концепцию ООП.
React определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать
с этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно
взаимодействует.
Например, у него можно постоянно запрашивать JSX.
В React при создании класса мы наследуем и расширяем некий базовый класс "React.Component" при помощи "extends".
Компонент это функция, которая возвращает JSX.
Классовые компоненты могут содержать "side effects". Для этого используются методы жизненного цикла.
У классового компонента всегда есть метод render(){...}, который возвращает JSX.
При переходе по разным "Route" экземпляры классовых компонентов удаляются из памяти.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"UsersContainer" является контейнерным компонентом для компонента "Users".
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.tsx") из библиотеки "react-redux".
Этот компонент подключается в компоненте "App".
*/
class UsersContainer extends React.Component<PropsType/*, StateType*/> { /*Указали, что "props" в этом классовом
компоненте имеют тип "PropsType". Еще здесь можно указать тип "state", но мы не указали.*/
    componentDidMount() {/*Это метод жизненного цикла классового компонента. Он вызывается в момент первой
    отрисовки (монтирования) компонента.*/
        const {currentPage, pageSize, filter} = this.props; /*Создаем три константы "currentPage" (текущая выбранная
        страница в постраничном выводе), "pageSize" (максимальное количество пользователей на одной странице в
        постраничном выводе) и "filter" (данные для фильтрации пользователей в постраничном выводе), и передаем в них
        значения из "props", эти значения подхватятся из-за совпадения имен. В классовом компоненте порой лучше сделать
        деструктуризацию параметров из "props", так как возможно могут быть какие-то проблемы с лишней перерисовкой.
        "{}" здесь обозначают деструктуризацию.*/
        this.props.requestUsers(currentPage, pageSize, filter); /*Вызываем TC "requestUsers" для запроса и установки
        данных по пользователям в постраничном выводе, передав значение текущей выбранной страницы, максимальное
        количество пользователей на одной странице в постраничном выводе и данные для фильтрации пользователей в
        постраничном выводе.*/
    };

    onPageChange = (pageNumber: number) => { /*Создали специальный метод, который будет вызываться при смене страницы
    в постраничном выводе пользователей, принимает номер новой текущей выбранной страницы.*/
        const {pageSize, filter} = this.props; /*Создаем две константы "pageSize" (количество пользователей на одной
        странице в постраничном выводе) и "filter" (данные для фильтрации пользователей в постраничном выводе), и
        передаем в них значения из "props", эти значения подхватятся из-за совпадения имен. В классовом компоненте порой
        лучше сделать деструктуризацию параметров из "props", так как возможно могут быть какие-то проблемы с лишней
        перерисовкой. "{}" здесь обозначают деструктуризацию.*/
        this.props.setCurrentPage(pageNumber); /*Вызываем AC "setCurrentPage" для установки значения текущей выбранной
        страницы в постраничном выводе пользователей в "state", передав номер новой текущей выбранной страницы.*/
        this.props.requestUsers(pageNumber, pageSize, filter); /*Вызываем TC "requestUsers" для запроса и установки
        данных по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы, максимальное
        количество пользователей на одной странице в постраничном выводе и данные для фильтрации пользователей в
        постраничном выводе.*/
    };

    onFilterChange = (filter: UsersFilterType) => { /*Создали специальный метод, который будет вызываться при изменении
    данных по фильтрам для отображения пользователей в постраничном выводе пользователей. Этот метод принимает данные по
    фильтрам для отображения пользователей в постраничном выводе пользователей, которые должны быть типа
    "UsersFilterType", который мы создали и импортировали сюда.*/
        const {pageSize} = this.props; /*Создаем константу "pageSize" (максимальное количество пользователей на одной
        странице в постраничном выводе), и передаем в нее значение из "props", это значение подхватится из-за совпадения
        имен. В классовом компоненте порой лучше сделать деструктуризацию параметров из "props", так как возможно могут
        быть какие-то проблемы с лишней перерисовкой. "{}" здесь обозначают деструктуризацию.*/
        this.props.requestUsers(1, pageSize, filter); /*Вызываем TC "requestUsers" для запроса и установки
        данных по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы (указали "1",
        так как если бы передавали сюда последнюю текущую выбранную страницу, то могли бы быть случаи, когда мы уже
        вывели несколько страниц пользователей, перешли на какую-то страницу, кроме первой, потом сделали новый запрос
        пользователей с другими фильтрами, и нам в ответ могло прийти меньшее количество страниц пользователей, чем
        номер страницы, которую мы до этого выбрали, например, были на шестой странице, а пришло пять страниц, в итоге
        мы окажемся на пустой шестой странице, а указав "1", после каждого нового запроса пользователей нас будет всегда
        сбрасывать на первую страницу), максимальное количество пользователей на одной странице в постраничном выводе и
        данные для фильтрации пользователей в постраничном выводе.*/
    };

    render() {
        /*
        Здесь после return в компоненте начинается HTML разметка.
        Нужно помнить, что в этой разметке должен быть только один корневой элемент.
        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
        */
        return <> {/*Этот пустой элемент и есть наш корневой элемент.*/}
            <h2>{this.props.pageTitle}</h2> {/*Для учебных целей в рамках изучения типов для "props" выводим значение
            свойства "pageTitle" в элементе "h2"*/}

            {this.props.isFetching ? <Preloader/> : null} {/*Если в "state" значение "isFetching" является "true",
            то показываем компонент "Preloader". Этот элемент "Preloader" и будет нашим корневым элементом.
            Если же компонент "Preloader" не отрисовывается, то далее отрисовываем компонент "Users" и передаем ему
            через "props" необходимые для него данные. Этот элемент "Users" и будет нашим корневым элементом.*/}
            <Users totalUsersCount={this.props.totalUsersCount} /*Общее количество пользователей. Далее передается
                   в компонент "Paginator.tsx".*/
                   pageSize={this.props.pageSize} /*Максимальное количество пользователей на одной странице в
                   постраничном выводе. Далее передается в компонент "Paginator.tsx".*/
                   currentPage={this.props.currentPage} /*Номер текущей выбранной страницы в постраничном выводе. Далее
                   передается в компонент "Paginator.tsx".*/
                   onPageChange={this.onPageChange} /*Метод "onPageChange" для обновления данных при смене текущей
                   выбранной страницы в постраничном выводе. Далее передается в компонент "Paginator.tsx".*/
                   onFilterChange={this.onFilterChange} /*Метод "onFilterChange" для обновления данных по фильтрам для
                   отображения пользователей в постраничном выводе пользователей при изменении этих данных. Далее
                   передается в компонент "UsersSearchForm.tsx".*/
                   users={this.props.users} /*Данные по пользователям для постраничного вывода. Далее мапиться для
                   отрисовки компонентов "User.tsx".*/
                   WhoIsInFollowingProgress={this.props.WhoIsInFollowingProgress} /*Специальное свойство, которое
                   содержит массив, который будет хранить "ID" пользователей, которые в какой-то определенный момент
                   находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для
                   анфолловинга/фолловинга от пользователя. Далее передается в компонент "User.tsx".*/
                   unfollow={this.props.unfollow} /*TC для анфолловинга пользователей. Далее передается в
                   компонент "User.tsx".*/
                   follow={this.props.follow} /*TC для фолловинга пользователей. Далее передается в компонент "User".*/
                   portionSize={this.props.portionSize} /*Свойство, которое указывает какое максимальное количество
                   номеров страниц в постраничном выводе может отображаться в одной порции таких страниц. Это сделано,
                   чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность выбирать
                   страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими порциями страниц.
                   Далее передается в компонент "Paginator.tsx".*/
            />
        </>
    }
};


const mapStateToProps = (state: AppStateType): MapStateToPropsType => {/*Здесь указываются данные из "state", которые
необходимо передать в компонент "ProfileContainer". Эта функция возвращает указанные данные в виде объекта. Эти данные
мы получаем при помощи созданных нами селекторов из "users-selectors.ts". На входе "mapStateToProps" принимает "state"
с типом "AppStateType", который мы создали и импортировали сюда, а на выходе выдает данные с типом
"MapStateToPropsType".*/
    return {
        users: getUsers(state), /*Данные по пользователям для постраничного вывода пользователей.*/
        pageSize: getPageSize(state), /*Максимальное количество пользователей, которое выводится в постраничном выводе
        пользователей.*/
        totalUsersCount: getTotalUsersCount(state), /*Общее количество пользователей.*/
        currentPage: getCurrentPage(state), /*Текущий номер выбранной страницы в постраничном выводе пользователей.*/
        isFetching: getIsFetching(state), /*Специальное свойство, которое обозначает находится ли в процессе запрос
        на сервер на получение данных по пользователям для постраничного вывода. Если в процессе, то будет
        отрисовываться компонент-заглушка "Preloader".*/
        WhoIsInFollowingProgress: getWhoIsInFollowingProgress(state), /*Специальное свойство, которое содержит массив,
        который будет хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе
        анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
        portionSize: getPortionSize(state), /*Свойство, которое указывает какое количество номеров страниц в постраничном
        выводе может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц,
        коих огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40)
        и переключаться между этими порциями страниц.*/
        filter: getUsersFilter(state) /*Свойство, которое содержит объект, внутри которого указываются фильтры для
        выборки пользователей в постраничном выводе.*/
    }
};


export default connect<MapStateToPropsType, MapDispatchToPropsType, OwnPropsType, AppStateType>(mapStateToProps, {
/*При помощи метода "connect" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL в другой
контейнерный компонент "UsersContainer" из этого файла. Поскольку метод "connect" является "generic", то его можно
уточнить: первым в "<>" указан тип для "MapStateToProps", вторым для "MapDispatchToProps", третьим для "собственных
props" компонента, четвертым для "state". Эти параметры мы узнали перейдя в файл декларации метода "connect",
"Ctrl+click" в "WebStorm".*/
        setCurrentPage: usersAC.setCurrentPage, /*AC для установки текущего номера выбранной страницы в постраничном
        выводе пользователей. Указываем этот АС именно таким образом здесь, так как используем его как свойство из
        объекта.*/
        requestUsers, /*TC для запроса с сервера и установки в "state" данных по пользователя для постраничного вывода
        пользователей.*/
        follow, /*TC для фолловинга пользователей в постраничном выводе пользователей.*/
        unfollow /*TC для анфолловинга пользователей в постраничном выводе пользователей.*/
    }
)(UsersContainer);
/*Получившийся в итоге компонент экспортируем, который будет использоваться в нашем проекте под именем "UsersContainer",
по default, экспорт необходим для импорта.*/