import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {useSelector} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI
нежелательно общаться с BLL напрямую. Библиотека "react-redux" предоставляет продвинутые инструкции по созданию
контейнерных компонент и контекста.
"useSelector" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.
*/

import {Users} from './Users'; /*Подключаем компонент "Profile".*/
import Preloader from '../common/Preloader/Preloader'; /*Подключаем компонент "Preloader".*/

import {getIsFetching} from '../../redux/users-selectors'; /*Импортируем селектор, который возвращает специальное
свойство, которое обозначает находится ли в процессе запрос на сервер на получение данных по пользователям для
постраничного вывода.*/


/*Создаем тип для "props". "Props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.
Все это нужно для указания типа "props" в функциональном компоненте.*/
type PropsType = {

};


/*
"UsersContainer" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function UsersContainer(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"UsersContainer" является компонентом, который отображает страницу с постраничным выводом пользователей.
Этот компонент подключается в компоненте "App".
Внутри компонента "UsersContainer" подключается компонент "Users", который отображает страницу с постраничным выводом
пользователей, и компонент "Preloader", который в некоторых случаях используется как компонент-заглушка.
*/
export const UsersContainer: React.FC<PropsType> = (props) => { /*Указали при помощи
"React.FC<>", что "props" в этом функциональном компоненте имеют тип "PropsType". Также указали, что экспортируем этот
компонент.*/
    const isFetching = useSelector(getIsFetching); /*При помощи хука "useSelector", передав в него селектор
    "getIsFetching", получаем специальное свойство, которое обозначает находится ли в процессе запрос на сервер на
    получение данных по пользователям для постраничного вывода (если в процессе, то будет отрисовываться
    компонент-заглушка "Preloader").*/

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return <> {/*Этот пустой элемент и есть наш корневой элемент.*/}
        {isFetching ? <Preloader/> : null} {/*Если в "state" значение "isFetching" является "true", то показываем
        компонент "Preloader". Этот элемент "Preloader" и будет нашим корневым элементом. Если же компонент "Preloader"
        не отрисовывается, то далее отрисовываем компонент "Users". Этот элемент "Users" и будет нашим корневым
        элементом.*/}
        <Users/>
    </>
};