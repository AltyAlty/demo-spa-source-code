import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {Field, Form, Formik} from 'formik';
/*
Используем библиотеку "formik" как аналог библиотеки "redux-form". Последнее нас не устраивает то, что библиотека
"redux-form" использует "store" из библиотеки "redux", храня среди данных BLL данные UI, и может лишний раз
спровоцировать перерисовку приложения.
Импортируем "Formik" из этой библиотеки, чтобы создавать тег "Formik", внутри которого указывается код для создания
формы. Внутри можно указать атрибут "validate", в котором можно указывать валидацию формы. Также внутри нужно указывать
атрибут "onSubmit", который должен содержать логику сабмита данных формы. Также внутри можно указать атрибут
"initialValues", который содержит стартовые значения данных формы, которые будут в ней собираться.
Импортируем "Form" из этой библиотеки, чтобы создавать тег "Form", внутри которого идет создание самой формы с ее
полями.
Импортируем "Field" из этой библиотеки, чтобы создавать тег "Field", внутри которого идет создание поля для формы.
Внутри может указываться атрибут "name" для именования данных, которые будут собираться в этом поле и обрабатываться
далее в приложении, то есть это аналог атрибута "name" из библиотеки "redux-form".
*/
import {useSelector} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI
нежелательно общаться с BLL напрямую. Библиотека "react-redux" предоставляет продвинутые инструкции по созданию
контейнерных компонент и контекста.
"useSelector" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.
*/

import {getUsersFilter} from '../../redux/users-selectors'; /*Импортируем селектор, который возвращает данные по
фильтрам для отображения пользователей в постраничном выводе пользователей.*/

import {UsersFilterType} from '../../redux/users-reducer'; /*Подключаем типы.*/


/*Создаем тип для "props". "Props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.
Все это нужно для указания типа "props" в функциональном компоненте.*/
type PropsType = {
    onFilterChange: (filter: UsersFilterType) => void /*Метод для обновления данных по фильтрам для отображения
    пользователей в постраничном выводе пользователей при изменении этих данных должен быть функцией, которая принимает
    параметр типа "UsersFilterType", который мы создали и импортировали сюда, и ничего не возвращает.*/
};

type FilterFriendFormType = 'true' | 'false' | 'null'; /*Указали тип для свойства, которое содержит значение для
фильтра, который работает следующим образом: если указать в нем "true", то сервер выберет только тех пользователей,
которых мы фолловим, если указать "false" - только тех, кого мы не фолловим, если указать "null" или вообще не
указывать, то выберет всех пользователей. Здесь мы специально указали это в виде строковых значений, так как библиотека
"formik" работает внутри формы со строковыми значениями. Но в самой форме мы делаем преобразования в булевый тип и в
"null" для нашего "state" и для запросов на сервер.*/

/*Создаем отдельный тип для данных, которые собирает форма ниже в компоненте "UsersSearchForm.tsx".*/
type FormType = {
    term: string /*Свойство, которое содержит значение для фильтра в виде строкового значения, которое будет получать
    сервер и искать наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких
    пользователей.*/
    friend: FilterFriendFormType /*Свойство, которое содержит значение для фильтра булева типа, если указать в нем
    "true", то сервер выберет только тех пользователей, которых мы фолловим, если указать "false" - только тех, кого мы
    не фолловим, если указать "null" или вообще не указывать, то выберет всех пользователей, должно быть типа
    "FilterFriendFormType", который мы создали выше.*/
};


/*Вынесли отдельно функцию для валидации формы, которая указывается в атрибуте "validate" в теге "Formik" из библиотеки
"formik".*/
const usersSearchFormValidate = (values: any) => {
    const errors = {}; /*В данном случае не указали никаких ошибок при валидации.*/
    return errors;
};


/*
"UsersSearchForm" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function UsersSearchForm(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"UsersSearchForm" является компонентом, который отображает форму с фильтрами для поиска пользователей на странице с
постраничным выводом пользователей. Этот компонент подключается в компоненте "Users".
*/
const UsersSearchForm: React.FC<PropsType> = React.memo(({onFilterChange}) => { /*Для оптимизации лишних
отрисовок мы обворачиваем этот функциональный компонент при помощи "React.memo()". Также указываем какие именно "props"
мы получаем, чтобы не писать далее "props.onFilterChange". Такое мы делаем только в функциональных компонентах. Также
указали при помощи "React.FC<>", что "props" в этом функциональном компоненте имеют тип "PropsType", созданный нами
выше.*/

    const filter = useSelector(getUsersFilter); /*При помощи хука "useSelector", передав в него селектор
    "getUsersFilter", получаем данные для фильтрации пользователей в постраничном выводе.*/

    /*Создаем callback функцию "onSubmitForm", которая будет указываться в атрибуте "onSubmit" в теге "Formik" из
    библиотеки "formik" и которая содержит логику сабмита данных формы. Согласно библиотеке "formik" эта функция должна
    принимать значения данных формы в виде первого параметра "values", который имеет тип "FormType", созданный нами
    выше. Вторым параметром эта функция должна принимать функцию "setSubmitting" (будет получена при помощи
    деструктуризации). Указали, что эта функция "setSubmitting" является функцией, которая принимает булевый параметр
    "isSubmitting" (который указывается внутри стрелочной функции элемента "Formik", которая возвращает элемент "Form",
    содержащий саму форму) и ничего не возвращает.
    При срабатывании этой функции формируется объект "filter" на основе данных формы при их сабмите, содержащий данные
    по фильтрам для отображения пользователей в постраничном выводе пользователей. Затем вызывается метод
    "onFilterChange", в который передается этот объект "filter", далее благодаря срабатыванию метода "onFilterChange"
    данные по фильтрам устанавливаются в наш "state" и формируется запрос данных по пользователям для постраничного
    вывода на сервер, содержащий фильтры для отображения пользователей в постраничном выводе. После этого вызывается
    функция "setSubmitting", в которую передается параметр "false", чтобы указать, что больше не происходит сабмит
    данных формы для того, чтобы кнопка сабмита данных снова стала активна, и мы могли указать новые данные фильтров и
    снова сделать сабмит данных для запроса новых пользователей, но по идее надо делать так, чтобы кнопка стала активна
    только после того, как отобразятся пользователи в ответ на наш запрос.*/
    const onSubmitForm = (values: FormType, {setSubmitting}: {setSubmitting: (isSubmitting: boolean) => void}) => {
        const filter: UsersFilterType = { /*Создаем объект, который содержит данные по фильтрам для отображения
        пользователей в постраничном выводе пользователей. Он будет получать эти данные из формы, которые будут в ней
        собираться в объекте "values" при сабмите данных и попадать в эту callback функцию.*/
            term: values.term, /*Строковое значение из "values.term" сохраняем как есть.*/
            friend: values.friend === 'null' ? null : values.friend === 'true' ? true : false /*Здесь же строковые
            значения из "values.friend" мы преобразовываем в "null" и булевый тип для нашего "state" и для запросов на
            сервер.*/
        };

        onFilterChange(filter);
        setSubmitting(false);
    };

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            <Formik /*Создает элемент "Formik" из библиотеки "formik" для создания формы. Внутри указываем атрибуты
            "initialValues", "validate" и "onSubmit".*/
                enableReinitialize={true} /*Таким образом указали библиотеке "formik", чтобы она переинициировала форму
                при получении новых "props", например, "filter.term" или "filter.friend". Если не указывать значение
                этого атрибута, то будет тоже "true".*/
                initialValues={{term: filter.term, friend: String(filter.friend) as FilterFriendFormType}} /*В атрибуте
                "initialValues", который содержит стартовые значения данных формы, которые будут в ней собираться,
                указали значения "filter.term" и "filter.friend" для свойств "term" и "friend" соответственно. Значение
                "filter.friend" мы преобразовываем в строку при помощи функции "String()" и указываем, чтобы полученное
                значение воспринималось как типа "FilterFriendFormType" при помощи "as FilterFriendFormType". Нам нужны
                здесь строковые значения, так как библиотека "formik" работает внутри со строковыми значениями данных
                формы.*/
                validate={usersSearchFormValidate} /*В атрибуте "validate", который ответственен за валидацию формы из
                библиотеки "formik", указали функцию "usersSearchFormValidate", которую создали выше.*/
                onSubmit={onSubmitForm} /*В атрибуте "onSubmit", который ответственен за логику сабмита данных формы из
                библиотеки "formik", указали функцию "onSubmitForm", которую создали выше.*/
            >
                {({isSubmitting}) => ( /*Внутри элемента "Formik" должна указываться таким образом стрелочная
                функция, которая принимает булевый параметр "isSubmitting" и возвращает элемент "Form", содержащий саму
                форму. Параметр "isSubmitting" указывает происходит ли сейчас сабмит данных формы или нет. Пока
                происходит сабмит данных формы библиотека "formik" по умолчанию делает неактовной кнопку сабмита
                данных.*/
                    <Form> {/*При помощи элемента "Form" из библиотеки "formik" создаем саму форму. Внутри указываем
                    поля формы при помощи элементов "Field" из библиотеки "formik".*/}
                        <Field type='text' name='term'/> {/*Первое поле формы имеет тип поля для ввода текста и собирает
                        данные в виде свойства "term". В этом поле будет вводиться текст, который будет отправляться на
                        сервер, чтобы сервер мог отфильтровать пользователей, которые содержат этот текст в своем имени,
                        и выдать нам таких пользователей.*/}
                        <Field as='select' name='friend' > {/*Второе поле формы имеет тип выпадающего списка и собирает
                        данные в виде свойства "friend". В этом поле будет выбираться одна из трех опций, которые
                        созданы ниже при помощи элементов "option", и значение этой выбранной опции будет отправляться
                        на сервер, чтобы сервер в зависимости от полученного значение мог отфильтровать пользователей
                        для выдачи их нам.*/}
                            <option value='null'>All</option> {/*Первым значением в выпадающем списке будет "null", что
                            для сервера будет означать вывести всех пользователей.*/}
                            <option value='true'>Followed</option> {/*Вторым значением в выпадающем списке будет "true",
                            что для сервера будет означать вывести только тех пользователей, которых мы фолловим.*/}
                            <option value='false'>Unfollowed</option> {/*Третьим значением в выпадающем списке будет
                            "false", что для сервера будет означать вывести только тех пользователей, которых мы не
                            фолловим.*/}
                        </Field>
                        <button type='submit' disabled={isSubmitting}> {/*Внутри формы также создаем кнопку с текстом
                        "Find" для сабмита данных формы. Также этот элемент содержит атрибут "disabled" для указания
                        параметру "isSubmitting" значение "false", чтобы таким образом указать, что больше не происходит
                        сабмит данных формы для того, чтобы кнопка сабмита данных снова стала активна, и мы могли
                        указать новые данные фильтров и снова сделать сабмит данных.*/}
                            Find
                        </button>
                    </Form>
                )}
            </Formik>
        </div>
    )
});


export default UsersSearchForm; /*Экспортируем компонент "UsersSearchForm" по default и будем его использовать в нашем
проекте под именем "UsersSearchForm", экспорт необходим для импорта.*/