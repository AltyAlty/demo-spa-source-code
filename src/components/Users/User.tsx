import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {NavLink} from 'react-router-dom';
/*
Библиотека "react-router-dom" необходима для создания роутинга и маршрутов в приложении.
Подключаем "NavLink", который является аналогом элемента "a" из HTML, хотя в браузере в итоге все равно будет
отображаться элемент "a".
Но "NavLink" не перезагружает все приложение в отличии от обычного использования элемента "a", то есть "NavLink"
отменяет действие по умолчанию элемента "a".
"NavLink" используется для перемещения по "Route" маршрутам.
"NavLink" вместо атрибута "href" использует атрибут "to".
"NavLink" добавляет атрибует "class" со значением "active" к элементу "a", когда осуществляется переход по ссылке.
Но класс "active" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за
использования CSS-модуля.
Атрибут "activeClassName" позволяет указывать какой именно класс добавляется к элементу "a" вместо класса "active".
*/

import styles from './User.module.css'; /*Подключаем стили из CSS-модуля.*/
import userPhoto from '../../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя,
на случай если у пользователя нет фото.*/

import {UserType} from '../../types/types'; /*Подключаем типы.*/


/*Создаем тип для "props". "Props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.
Все это нужно для указания типа "props" в функциональном компоненте.*/
type PropsType = {
    user: UserType /*Данные по одному пользователю для постраничного вывода должны быть в виде объекта с типом
    "UserType", который был создан нами и импортирован сюда.*/
    WhoIsInFollowingProgress: Array<number> /*Специальное свойство, которое содержит массив, который будет хранить "ID"
    пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним
    отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя, должно быть массивом чисел.*/
    unfollow: (id: number) => void /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой
    параметр и ничего не возвращает.*/
    follow: (id: number) => void /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой
    параметр и ничего не возвращает.*/
};


/*
"User" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function User(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"Users" является компонентом, который описывает, как должны выглядеть блоки с информацией о пользователе на странице
с постраничным выводом пользователей.
Этот компонент подключается в компоненте "Users".
*/
const User: React.FC<PropsType> = ({/*Указываем какие именно "props" мы получаем, чтобы не писать далее "props.user",
"props.WhoIsInFollowingProgress" и так далее. Такое мы делаем только в функциональных компонентах. Указали при помощи
"React.FC<>", что "props" в этом функциональном компоненте имеют тип "PropsType".*/
                  user, /*Объект с данным по пользователю.*/
                  WhoIsInFollowingProgress, /*Специальное свойство, которое содержит массив, который будет
                  хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе
                  анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга
                  от пользователя.*/
                  unfollow, /*TC для анфолловинга пользователей.*/
                  follow /*TC для фолловинга пользователей.*/
}) => {
    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            <span>
                <div> {/*Это отдельный элемент "div" для отображения фото пользователя в виде элемента "NavLink" для
                перехода на профиль пользователя.*/}
                    <NavLink to={'/profile/' + user.id}> {/*Создаем маршрут для пути перехода на страницу выбранного
                    пользователя. Отрисуется компонент "Profile".*/}
                        <img src={user.photos.small != null ? user.photos.small : userPhoto}
                             alt='' className={styles.userPhoto}/> {/*Отображаем фото пользователя, если его нет, то
                             подгружаем дефолтный аватар из проекта приложения.*/}
                    </NavLink>
                </div>

                <div> {/*Это отдельный элемент "div" для кнопок с функционалом "Follow/Unfollow".*/}
                    {user.followed /*Если значение "followed" (свойство, которое говорит фолловим ли мы уже
                    пользователя или нет, это свойство меняется в "usersReducer") у пользователя*/
                        ? <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)} /*является "TRUE", то
                        отображаем элемент кнопки (причем кнопка будет отключена, если на нее нажали и происходит
                        процесс анфолловинга пользователя, то есть мы берем массив "WhoIsInFollowingProgress" и вызываем
                        для него метод "some()", который вернет "TRUE" если в указанном массиве есть "ID" пользователя
                        равное "ID" пользователя, указанного при создании отдельного экземпляра компонента "User"
                        в результате маппинга)*/
                                  onClick={() => { /*и если нажать на кнопку, то*/
                                      unfollow(user.id); /*сработает TC "unfollow", чтобы заанфолловить пользователя,*/
                                  }}>Unfollow</button> /*и отображаем текст "Unfollow" на кнопке.*/

                        : <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)} /*является "FALSE", то
                        отображаем элемент кнопки (причем кнопка будет отключена, если на нее нажали и происходит
                        процесс фолловинга пользователя, то есть мы берем массив "WhoIsInFollowingProgress" и вызываем
                        для него метод "some()", который вернет "TRUE" если в указанном массиве есть "ID" пользователя
                        равное "ID" пользователя, указанного при создании отдельного экземпляра компонента "User"
                        в результате маппинга)*/
                                  onClick={() => { /*и если нажать на кнопку, то*/
                                      follow(user.id); /*сработает TC "follow", чтобы зафолловить пользователя.*/
                                  }}>Follow</button> /*и отображаем текст "Follow" на кнопке.*/
                    }
                </div>
            </span>

            <span> {/*Это отдельный элемент "span" для отображения информации с id, именем и статусом пользователя.
            А также имеется заглушка для страны и города пользователя, так как на данный момент на сервере такой
            информации нет.*/}
                <span> {/*Это отдельный элемент "span" для отображения информации с id, именем и статусом
                пользователя.*/}
                    <div>{user.id}</div> {/*Этот элемент "div" отображает "ID" пользователя.*/}
                    <div>{user.name}</div> {/*Этот элемент "div" отображает имя пользователя.*/}
                    <div>{user.status}</div> {/*Этот элемент "div" отображает статус пользователя.*/}
                </span>
                <span> {/*Это отдельный элемент "span" для отображения заглушки для страны и города пользователя.*/}
                    <div>{"user.location.country"}</div> {/*Этот элемент "div" отображает заглушку для страны
                    пользователя.*/}
                    <div>{"user.location.city"}</div> {/*Этот элемент "div" отображает заглушку для города
                    пользователя.*/}
                </span>
            </span>
        </div>
    )
};


export default User; /*Экспортируем компонент "User" по default и будем его использовать в нашем проекте под именем
"User", экспорт необходим для импорта.*/