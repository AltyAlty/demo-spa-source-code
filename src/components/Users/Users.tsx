import React, {useEffect, useState} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
Классовый компонент позволяет реализовать локальный "state" (смотри "ProfileStatus") и методы
жизненного цикла ("componentDidMount" и т.д.), а функциональный компонент этого не может делать.
Такие возможности классового компонента были созданы благодаря тому, что "React" на основе класса
создает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может
хранить такие вещи как "state" и методы. Функция же просто вызывается и возвращает "JSX", постоянное
общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала
и удалилась. Для решения этой проблемы в функциональных компонентах были созданы "Hooks" (хуки).
"Hook" - это функция, которая может делать side effects.
"React" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и
этой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента
"React" запоминает эту информацию где-то на своей стороне, а не внутри объекта.
Хуки нельзя писать в условиях и циклах.
Можно писать свои кастомные хуки.
Подключаем хук "useState", который возвращает массив с двуми элементами. Первый элемент - это значение,
которое хранится в "state". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя
первый элемент мы заставляем "React" перерисовывать функциональный компонент.
Подключаем хук "useEffect", который принимает функцию первым параметром и выполняет ее, когда произойдет
отрисовка компонента, то есть после каждого вызова "render". Вторым параметром этот хук принимает зависимости -
зависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то
этот хук сработает только один раз. Этот хук используется для side effects.
*/
import {useDispatch, useSelector} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI
нежелательно общаться с BLL напрямую. Библиотека "react-redux" предоставляет продвинутые инструкции по созданию
контейнерных компонент и контекста.
"useSelector" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.
"useDispatch" - это hook, который принимает AC или TC и диспатчит их.
*/
import {useHistory} from 'react-router-dom';
/*
Библиотека "react-router-dom" необходима для создания роутинга и маршрутов в приложении.
Подключаем хук "useHistory", который взаимодействует и управляет данными, связанными с роутингом и маршрутами, например,
с адресной строкой (в виде объекта "history"). С похожими данными работает HOC "withRouter".
*/

import {
    requestUsers, /*Подключаем TC "requestUsers" из "users-reducer.ts".*/
    follow, /*Подключаем TC "follow" из "users-reducer.ts".*/
    unfollow, /*Подключаем TC "unfollow" из "users-reducer.ts".*/
    UsersFilterType /*Подключаем типы из "users-reducer.ts".*/
} from '../../redux/users-reducer';

import {usersAC} from '../../redux/users-reducer'; /*Подключаем объект "usersAC", что использовать оттуда AC из
"users-reducer.ts".*/

import Paginator from '../common/Paginator/Paginator'; /*Подключаем компонент "Paginator".*/
import User from './User'; /*Подключаем компонент "User".*/
import UsersSearchForm from './UsersSearchForm'; /*Подключаем компонент "UsersSearchForm".*/
import {Preloader} from '../common/Preloader/Preloader'; /*Подключаем компонент "Preloader".*/

import {
    getCurrentPage, /*Импортируем селектор, который возвращает общее количество пользователей.*/
    getPageSize, /*Импортируем селектор, который возвращает максимальное количество пользователей, которое выводится в
    постраничном выводе пользователей.*/
    getTotalUsersCount, /*Импортируем селектор, который возвращает общее количество пользователей.*/
    getWhoIsInFollowingProgress, /*Импортируем селектор, который возвращает специальное свойство, которое содержит
    массив, который будет хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе
    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
    getUsers, /*Импортируем селектор, который возвращает данные по пользователям для постраничного вывода.*/
    getPortionSize, /*Импортируем селектор, который возвращает свойство, которое указывает какое количество номеров
    страниц в постраничном выводе может отображаться в одной порции таких страниц.*/
    getUsersFilter, /*Импортируем селектор, который возвращает данные по фильтрам для отображения пользователей в
    постраничном выводе пользователей.*/
    getIsFetching, /*Импортируем селектор, который возвращает специальное свойство, которое обозначает находится ли в
    процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/
} from '../../redux/users-selectors';


import * as queryString from 'querystring'; /*Импортируем объект "queryString" из библиотеки "querystring", чтобы оттуда
использовать функцию "parse()" для парсинга строки и преобразования ее в объект, и функцию "stringify()" для обратного
преобразования.*/


/*Создаем тип для "props". "Props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.
Все это нужно для указания типа "props" в функциональном компоненте.*/
type PropsType = {

};

/*Создали тип для сформированного на основе параметров адресной строки объекта, который будет содержать свойства,
обозначающие данные для фильтрации пользователей в постраничном выводе.*/
type QueryParamsType = {
    term?: string,
    friend?: string,
    page?: string
};


/*
"Users" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function Users(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"Users" является компонентом, который отображает страницу с постраничным выводом пользователей.
Этот компонент подключается в компоненте "App".
Внутри компонента "Users" подключаются компоненты:
- "User", который описывает, как должны выглядеть блоки с информацией о пользователе на странице с постраничным
выводом пользователей;
- "Paginator", который осуществляет функционал постраничного вывода информации;
- "Preloader", который является компонентом-заглушкой;
- "UsersSearchForm", который отображает форму с фильтрами для поиска пользователей на странице с постраничным выводом
пользователей.
*/
export const Users: React.FC<PropsType> = (props) => { /*Указали при помощи "React.FC<>", что
"props" в этом функциональном компоненте имеют тип "PropsType". Также указали, что экспортируем этот компонент.*/
    const totalUsersCount = useSelector(getTotalUsersCount); /*При помощи хука "useSelector", передав в него селектор
    "getTotalUsersCount", получаем общее количество пользователей.*/
    const currentPage = useSelector(getCurrentPage); /*При помощи хука "useSelector", передав в него селектор
    "getCurrentPage", получаем номер текущей выбранной страницы в постраничном выводе.*/
    const pageSize = useSelector(getPageSize); /*При помощи хука "useSelector", передав в него селектор "getPageSize",
    получаем максимальное количество пользователей на одной странице в постраничном выводе.*/
    const portionSize = useSelector(getPortionSize); /*При помощи хука "useSelector", передав в него селектор
    "getPortionSize", получаем свойство, которое указывает какое максимальное количество номеров страниц в постраничном
    выводе может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих
    огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и
    переключаться между этими порциями страниц.*/
    const users = useSelector(getUsers); /*При помощи хука "useSelector", передав в него селектор "getUsers", получаем
    данные по пользователям для постраничного вывода.*/
    const WhoIsInFollowingProgress = useSelector(getWhoIsInFollowingProgress); /*При помощи хука "useSelector", передав
    в него селектор "getWhoIsInFollowingProgress", получаем специальное свойство, которое содержит массив, который будет
    хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то
    есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
    const filter = useSelector(getUsersFilter); /*При помощи хука "useSelector", передав в него селектор
    "getUsersFilter", получаем данные для фильтрации пользователей в постраничном выводе.*/
    const isFetching = useSelector(getIsFetching); /*При помощи хука "useSelector", передав в него селектор
    "getIsFetching", получаем специальное свойство, которое обозначает находится ли в процессе запрос на сервер на
    получение данных по пользователям для постраничного вывода (если в процессе, то будет отрисовываться
    компонент-заглушка "Preloader").*/

    const [isNotJustCreated, setIsNotJustCreated] = useState<boolean>(false); /*При помощи деструктуризирующего
    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент
    будет означать специальное свойство, которое показывает то, что мы успели уже указать данные для фильтрации
    пользователей в постраничном выводе или не успели (изначально "false"). Нам это нужно, чтобы затриггерить функцию
    "push" в компоненте "Users.tsx", когда мы выбираем первую страницу после того как уже выбрали другую страницу в
    постраничном выводе. Вторая переменная будет хранить функцию из хука "useState", которая будет изменять первый
    элемент (то есть указывать то, что мы успели уже указать данные для фильтрации пользователей в постраничном выводе
    или не успели). При помощи типизации указали, что первый параметр должен быть булева типа.*/

    const [isJustCreated, setIsJustCreated] = useState<boolean>(true); /*При помощи деструктуризирующего
    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент
    будет означать специальное свойство, которое показывает то, что мы еще не успели указать данные для фильтрации
    пользователей в постраничном выводе или успели (изначально "true"). Нам это нужно, чтобы не затриггерить функцию
    "push" в компоненте "Users.tsx" при первой отрисовке, то есть когда не указано параметров фильтрации пользователей и
    выбрана первая страница в постраничном выводе по умолчанию, так как UI-фреймворк "Ant Design" при взаимодействии с
    некоторыми элементами интерфейса (например, при нажатии на кнопки или при изменении параметров адресной строки)
    сворачивает все подменю, чего нам не хотелось бы видеть при первой отрисовке компонента. Вторая переменная будет
    хранить функцию из хука "useState", которая будет изменять первый элемент (то есть указывать то, что мы еще не
    успели уже указать данные для фильтрации пользователей в постраничном выводе или успели). При помощи типизации
    указали, что первый параметр должен быть булева типа.*/

    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука "useDispatch".*/

    useEffect(() => { /*Используем хук "useEffect", чтобы получить данные по пользователям для постраничного
    вывода при отрисовке компонента.*/
            dispatch(requestUsers(currentPage, pageSize, filter)); /*Первый параметр это TC "requestUsers" для запроса и
        установки данных по пользователям в постраничном выводе, передав значение текущей выбранной страницы,
        максимальное количество пользователей на одной странице в постраничном выводе и данные для фильтрации
        пользователей в постраничном выводе.*/
        },
        [] /*Второй параметр это пустой массив, так как мы хотим, чтобы TC "requestUsers" из первого параметра
        сработал только один раз после создания компонента.*/
    );

    const history = useHistory(); /*Делаем это для более краткого использования хука "useHistory".*/

    useEffect(() => { /*Используем хук "useEffect", чтобы синхронизировать данные для фильтрации пользователей в
    постраничном выводе и номер текущей выбранной страницы в постраничном выводе, указанные в параметрах адресной
    строки, с аналогичными данными из глобального "state" при отрисовке компонента.*/
        const search = history.location.search.substr(1); /*Первым параметром мы получаем параметры, которые
        указаны в адресной строке (например, строку "?term=a&friend=true&page=2"), обращаясь к объекту "history",
        который возвращается хуком "useHistory". Поскольку нам не нужен знак "?" в полученной строке, то мы используем
        также функцию "substr()", передав в нее "1" в качестве параметра, чтобы считывалось все после первого символа.*/

        const parsed = queryString.parse(search) as QueryParamsType; /*Также в рамках первого параметра, при помощи
        функции "parse()" из библиотеки "querystring" мы парсим строку с параметрами адресной строки, превращая ее в
        объект, например, "{term: "a", friend: "true", page: "1"}". Также указали, чтобы этот объект воспринимался как
        объект типа "QueryParamsType".*/

        let actualCurrentPage = currentPage; /*Также в рамках первого параметра, получаем номер актуальной текущей
        выбранной страницы в постраничном выводе.*/

        let actualFilter = filter; /*Также в рамках первого параметра, получаем актуальные данные для фильтрации
        пользователей в постраничном выводе.*/

        if (!!parsed.page) actualCurrentPage = Number(parsed.page); /*Также в рамках первого параметра, если в
        параметрах адресной строки была указана текущая выбранная страница, то ее номер запишется в переменную
        "actualCurrentPage". При помощи функции "Number()" приводим строку к числу. При помощи "!!" переводим значение
        "parsed.page" в булевый тип.*/

        if (!!parsed.term) actualFilter = {...actualFilter, term: parsed.term as string}; /*Также в рамках первого
        параметра, если в параметрах адресной строки был указан параметр "term", то значение этого параметра запишется в
        переменную "actualFilter". Делаем здесь глубокое копиривание, чтобы соблюдать иммутабельность, поскольку
        работаем с объектом. Если мы укажем в адресной строке какой-либо параметр больше одного раза, то ни один из них
        не будет перезатирать других, и если мы получаем эти параметры в виде строки, переводя ее в объект, то этот
        параметр в объекте будет иметь значение массива со всеми значениями этого параметра, указанными в адресной
        строке, поэтому мы указываем, чтобы значение параметра "term" воспринималось как строка при помощи "as string".
        При помощи "!!" переводим значение "parsed.term" в булевый тип.*/

        switch (parsed.friend) { /*Также в рамках первого параметра, если в параметрах адресной строки был указан
        параметр "friend", то значение этого параметра запишется в переменную "actualFilter". Делаем здесь глубокое
        копиривание, чтобы соблюдать иммутабельность, поскольку работаем с объектом. Используем здесь конструкцию
        "switch/case", чтобы преобразовывать строковые значения в булевый тип или "null".*/
            case 'null':
                actualFilter = {...actualFilter, friend: null};
                break;
            case 'true':
                actualFilter = {...actualFilter, friend: true};
                break;
            case 'false':
                actualFilter = {...actualFilter, friend: false};
                break;
        };

        dispatch(usersAC.setCurrentPage(actualCurrentPage)); /*Также в рамках первого параметра вызываем AC
        "setCurrentPage" для установки значения текущей выбранной страницы в постраничном выводе пользователей в
        "state", передав номер актуальной текущей выбранной страницы, который был получен из параметров адресной
        строки.*/

        dispatch(requestUsers(actualCurrentPage, pageSize, actualFilter)); /*Также в рамках первого параметра вызываем
        TC "requestUsers" для запроса и установки данных по пользователям в постраничном выводе, передав значение
        актуальной текущей выбранной страницы, максимальное количество пользователей на одной странице в постраничном
        выводе и актуальные данные для фильтрации пользователей в постраничном выводе.*/
    },
        [] /*Второй параметр это пустой массив, так как мы хотим, чтобы все, что есть в первом параметре сработало
        только один раз после отрисовки компонента.*/
    );

    useEffect(() => { /*Используем хук "useEffect", чтобы синхронизировать данные для фильтрации пользователей в
    постраничном выводе и номер текущей выбранной страницы в постраничном выводе из глобального "state" с аналогичными
    данными из UI, чтобы указать эти данные в адресной строке в виде параметров. Это использование хука "useEffect"
    должно обязательно идти после предыдущего использования хука "useEffect", иначе будут затираться полученные из
    параметров адресной строки данные при отрисовке компонента, поскольку порядок хуков имеет значение.*/
        const query: QueryParamsType = {}; /*В рамках первого параметра создаем объект типа "QueryParamsType", который в
        дальнейшем будет хранить объект, сформированный на основе параметров адресной строки, который будет содержать
        свойства, обозначающие данные для фильтрации пользователей в постраничном выводе и номер текущей выбранной
        страницы в постраничном выводе.*/

        if (!!filter.term) {
            query.term = filter.term;
            setIsJustCreated(false);
            setIsNotJustCreated(true);
        }; /*Также в рамках первого параметра, если есть свойство "term" в объекте "filter", то добавляем его в наш
        объект "query". При помощи "!!" переводим значение "filter.term" в булевый тип. Также указываем, что успели
        указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции "setIsJustCreated" и
        функции "setIsNotJustCreated" из хуков "useState" выше.*/

        if (filter.friend !== null) {
            query.friend = String(filter.friend);
            setIsJustCreated(false);
            setIsNotJustCreated(true);
        }; /*Также в рамках первого параметра, если свойство "friend" в объекте "filter" не равно "null", то есть равно
        "true" или "false", то преобразовываем значение этого свойства в строку при помощи функции "String()" и
        добавляем преобразованное значение в наш объект "query". Также указываем, что успели указать данные для
        фильтрации пользователей в постраничном выводе при помощи вызова функции "setIsJustCreated" и функции
        "setIsNotJustCreated" из хуков "useState" выше.*/

        if (currentPage !== 1) {
            query.page = String(currentPage);
            setIsJustCreated(false);
            setIsNotJustCreated(true);
        }; /*Также в рамках первого параметра, если номер текущей выбранной страницы не равен "1", то сохраняем этот
        номер, переведя его в строку при помощи функции "String()", в наш объект "query". Также указываем, что успели
        указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции "setIsJustCreated" и
        функции "setIsNotJustCreated" из хуков "useState" выше.*/

        if (currentPage === 1 && isNotJustCreated) {
            query.page = String(currentPage);
            setIsJustCreated(false);
            setIsNotJustCreated(false);
        }; /*Также в рамках первого параметра, если номер текущей выбранной страницы равен "1" и мы успели уже указать
        данные для фильтрации пользователей в постраничном выводе, то сохраняем этот номер, переведя его в строку при
        помощи функции "String()", в наш объект "query". Также указываем, что успели указать данные для фильтрации
        пользователей в постраничном выводе при помощи вызова функции "setIsJustCreated" из хука "useState" выше, но в
        этот раз вызываем функцию "setIsNotJustCreated" из хука "useState" выше, чтобы изменить свойство
        "isNotJustCreated" в локальном "state" на "false", чтобы если мы после того, как мы совершим следующие операции:
        1) Отрисовать компонент "Users.tsx";
        2) Указать какие-либо параметры для фильтрации пользователей в постраничном выводе и сделать запрос
        пользователей;
        3) Сбросить все параметры (в том числе выбрать первую страницу) для фильтрации пользователей в постраничном
        выводе и сделать запрос пользователей;
        4) Отрисовать другой компонент;
        5) Еще раз отрисовать компонент "Users.tsx";
        мы не затриггерили функцию "push", чтобы библиотека "Ant Design" не свернула все подменю в навигационном меню,
        так как по стандартному поведению библиотеки "Ant Design" если мы взаимодействуем с некоторыми элементами UI
        (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все подменю.*/

        if (!isJustCreated) { /*Поскольку работа функции "push" по изменению адресной строки считается UI-фреймворком
        "Ant Design" за взаимодействие с UI, поэтому при первом нажатии на пункт "Users" сворачивается подменю "People",
        так как по стандартному поведению UI-фреймворка "Ant Design" если мы взаимодействуем с некоторыми элементами UI
        (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все подменю. Поэтому мы
        добавили проверку, чтобы выполнять эту функцию "push" только в том случае, когда какие-либо из данных в
        "state", которые используются для формирования параметров адресной строки, были изменены.*/
            history.push({ /*Также в рамках первого параметра вызываем функцию "push" объекта "history", который
            возвращается хуком "useHistory", для того, чтобы перенаправить нас на адрес по пути "/users", дописав к
            этому пути параметры адресной строки из свойства "search" объекта "history".*/
                pathname: '/users',
                search: queryString.stringify(query) /*Здесь при помощи функции "stringify()" из библиотеки
                "querystring" мы преобразовываем наш объект "query" в строку, в итоге, например, получая строку
                "?term=dad&friend=false&page=2". Аналогично мы могли бы не формировывать наш объект "query" сверху и
                написать здесь так: "search: `?term=${filter.term}&friend=${filter.friend}&page=${currentPage}`".*/
            });
        };
    },
        [filter, currentPage, isJustCreated] /*Второй параметр это данные для фильтрации пользователей в
        постраничном выводе, номер текущей выбранной страницы в постраничном выводе из глобального "state" и специальное
        свойство, которое показывает то, что мы еще не успели указать данные для фильтрации пользователей в постраничном
        выводе или успели. Последнее нам нужно, так как после первого выбора страницы по какой-то причине факт того, что
        "isJustCreated" становился "false" игнорировался и не было обновления параметров адресной строки. Если эти
        данные будут меняться, то будет срабатывать каждый раз все то, что указано в первом параметре.*/
    );

    const onPageChange = (pageNumber: number) => { /*Создали специальную функцию, которая будет вызываться при смене
    страницы в постраничном выводе пользователей. Эта функция принимает номер новой текущей выбранной страницы.*/
        dispatch(usersAC.setCurrentPage(pageNumber)); /*Вызываем AC "setCurrentPage" для установки значения текущей
        выбранной страницы в постраничном выводе пользователей в "state", передав номер новой текущей выбранной
        страницы.*/
        dispatch(requestUsers(pageNumber, pageSize, filter)); /*Вызываем TC "requestUsers" для запроса и установки
        данных по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы, максимальное
        количество пользователей на одной странице в постраничном выводе и данные для фильтрации пользователей в
        постраничном выводе.*/
    };

    const onFilterChange = (filter: UsersFilterType) => { /*Создали специальную функцию, которая будет вызываться при
    изменении данных по фильтрам для отображения пользователей в постраничном выводе пользователей. Эта функция
    принимает данные по фильтрам для отображения пользователей в постраничном выводе пользователей, которые должны быть
    типа "UsersFilterType", который мы создали и импортировали сюда.*/
        dispatch(requestUsers(1, pageSize, filter)); /*Вызываем TC "requestUsers" для запроса и установки
        данных по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы (указали "1",
        так как если бы передавали сюда последнюю текущую выбранную страницу, то могли бы быть случаи, когда мы уже
        вывели несколько страниц пользователей, перешли на какую-то страницу, кроме первой, потом сделали новый запрос
        пользователей с другими фильтрами, и нам в ответ могло прийти меньшее количество страниц пользователей, чем
        номер страницы, которую мы до этого выбрали, например, были на шестой странице, а пришло пять страниц, в итоге
        мы окажемся на пустой шестой странице, а указав "1", после каждого нового запроса пользователей нас будет всегда
        сбрасывать на первую страницу), максимальное количество пользователей на одной странице в постраничном выводе и
        данные для фильтрации пользователей в постраничном выводе.*/
        dispatch(usersAC.setCurrentPage(1)); /*Вызываем AC "setCurrentPage" для установки значения текущей
        выбранной страницы в постраничном выводе пользователей в "state", передав "1" как номер новой текущей выбранной
        страницы, чтобы избежать случая , когда мы уже вывели несколько страниц пользователей, перешли на какую-то
        страницу, кроме первой, потом сделали новый запрос пользователей с другими фильтрами, и нам в ответ могло прийти
        меньшее количество страниц пользователей, чем номер страницы, которую мы до этого выбрали, например, были на
        шестой странице, а пришло пять страниц, в итоге мы окажемся на пустой шестой странице, а указав "1", после
        каждого нового запроса пользователей нас будет всегда сбрасывать на первую страницу.*/
    };

    const unfollowCallback = (userID: number) => { /*Таким образом используем TC "unfollow" для передачи его в компонент
    "User" ниже. Этот синтаксис похож на тот, который мы использовали при создании "mapDispatchToProps" в самом начале
    (смотри компонент "DialogsContainer.tsx").*/
        dispatch(unfollow(userID));
    };

    const followCallback = (userID: number) => { /*Таким образом используем TC "follow" для передачи его в компонент
    "User" ниже. Этот синтаксис похож на тот, который мы использовали при создании "mapDispatchToProps" в самом начале
    (смотри компонент "DialogsContainer.tsx").*/
        dispatch(follow(userID));
    };

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            {isFetching ? <Preloader/> : null} {/*Если в "state" значение "isFetching" является "true", то показываем
            компонент "Preloader". Этот элемент "Preloader" и будет нашим корневым элементом. Если же компонент
            "Preloader" не отрисовывается, то далее отрисовываем компоненты "UsersSearchForm", "Paginator" и "User".*/}

            {/*Отрисовываем компонент "UsersSearchForm" и передаем ему через "props" необходимы для него данные. Этот
            компонент представляет из себя форму с фильтрами для поиска пользователей по различным критериям.*/}
            <UsersSearchForm onFilterChange={onFilterChange}/> {/*Функция "onFilterChange" для обновления данных по
            фильтрам для отображения пользователей в постраничном выводе пользователей при изменении этих данных.*/}

            {/*Далее отрисовываем компонент "Paginator" и передаем ему через "props" необходимы для него данные.*/}
            <Paginator totalItemsCount={totalUsersCount} /*Общее количество пользователей. Переименовали
                       в "totalItemsCount", так как компонент "Paginator" может использоваться для постраничного вывода
                       любых элементов, не только пользователей.*/
                       pageSize={pageSize} /*максимальное количество пользователей на одной странице
                       в постраничном выводе.*/
                       currentPage={currentPage} /*Номер текущей выбранной страницы в постраничном выводе.*/
                       onPageChange={onPageChange} /*Функция "onPageChange" для обновления данных при смене текущей
                       выбранной страницы в постраничном выводе.*/
                       portionSize={portionSize} /*Свойство, которое указывает какое максимальное количество
                       номеров страниц в постраничном выводе может отображаться в одной порции таких страниц. Это
                       сделано, чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность
                       выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими
                       порциями страниц.*/
            />

            {/*Далее в отдельном эдлементе "div" отрисовываем компонент "User" при помощи функции "map".*/}
            <div>
                {/*
                В JSX в массив можно вкладывать компоненты.
                В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде
                строки.
                "map" - это метод массива из JS, который позволяет создать новый массив на основе преобразования
                исходного массива.
                Метод "map" принимает стрелочную функцию.
                То есть в нашем случае будет сначала браться первый объект из исходного массива объектов
                и на основе данных этого объекта будет формироваться первый элемента нового массива, который
                будет из себя представлять JSX компонента, указанного в стрелочной функции.
                Потом будет браться следующий объект из исходного массива объектов
                и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который
                будет из себя представлять JSX компонента, указанного в стрелочной функции.
                И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.
                То есть переданная в метод "map" стрелочная функция вызывается столько раз, сколько элементов
                в изначальном массиве объектов.
                В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.
                Вызвав такой массив в JSX мы отобразим наши компоненты.
                В этом элементе <div> будут выводится компоненты "User", отображающие информацию о каждом пользователе
                в постраничном выводе пользователей.
                При использовании метода "map" нужно указывать атрибут "key" для избежания ошибок.
                */}
                {users.map(u => <User key={u.id} /*При использовании метода "map" нужно указывать атрибут "key" для
                                      избежания ошибок.*/
                                      user={u} /*Объект с данным по пользователю.*/
                                      WhoIsInFollowingProgress={WhoIsInFollowingProgress} /*Специальное свойство,
                                      которое содержит массив, который будет хранить "ID" пользователей, которые
                                      в какой-то определенный момент находятся в процессе анфолловинга/фолловинга,
                                      то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга
                                      от пользователя.*/
                                      unfollow={unfollowCallback} /*TC для анфолловинга пользователей.*/
                                      follow={followCallback} /*TC для фолловинга пользователей.*/
                />)}
            </div>
        </div>
    )
};