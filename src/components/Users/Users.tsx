/*Классовый компонент позволяет реализовывать локальный state (смотри компонент "ProfileStatus") и методы жизненного
цикла классового компонента, а функциональный компонент этого не может делать. Такие возможности классового компонента
были созданы благодаря тому, что React на основе класса создает объект и всякий раз взаимодействует с этим объектом. А
поскольку это объект, значит он может хранить такие вещи как state и методы. Функция же просто вызывается и возвращает
JSX, постоянное общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция
отработала и удалилась. Для решения этой проблемы в функциональных компонентах были созданы Hooks (хуки).

Hook - это функция, которая может делать side effects. React когда вызывает функциональную компоненту, в которой есть
хуки, он запоминает вызов этих хуков и этого функционального компонента для того, чтобы потом соотносить side effects,
созданные этими хуками. В отличие от классового компонента React запоминает эту информацию где-то на своей стороне, а не
внутри объекта, созданного на основе компонента. Хуки нельзя писать в условиях и циклах, так как это нарушает порядок
хуков, который является важным. Можно писать свои кастомные хуки.

Импортируем хук "useState()", который возвращает массив с двумя элементами. Первый элемент - это значение, которое
хранится в state. Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя первый
элемент мы заставляем React перерисовывать функциональный компонент. Хук "useState()" работает асинхронно, то есть если
мы изменяем какое-либо значение при помощи этого хука, то мы говорим, чтобы React изменил это значение как только
сможет, не обращая внимание на порядок соседних инструкций рядом с кодом, где мы меняем какое-то значение из локального
state. Нужно помнить, что если наш JSX в компоненте не зависит от хука "useState()", то нежелательно хранить какие-то
данные в таком хуке. При вызове нескольких вторых элементов из нескольких хуков "useState()" в асинхронных операциях
(например, в запросах на сервер), нужно обращать внимание на порядок этих вторых элементов из нескольких хуков
"useState()".

Импортируем хук "useEffect()", который принимает функцию первым параметром и выполняет ее, когда произойдет отрисовка
компонента, то есть после каждого вызова функции "render()". Вторым параметром этот хук принимает зависимости - зависимо
от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то этот хук сработает
только один раз. Этот хук используется для side effects. Хук "useEffect()" позволяет нам синхронизировать какие-то вещи
в программе между собой. Такая синхронизация нужна для динамического изменения верстки с целью отображения ее
актуального состояния пользователю. Синхронизация между двумя сторонами может работать двунаправленно. Синхронизация
происходит после отрисовки компонента, а не до. В хуке "useEffect()" на самом деле желательно избегать пустой
зависимости "[]" во втором параметре. Если не указать второй параметр в хуке "useEffect()" вообще, то он будет
срабатывать при каждой отрисовке компонента. В первом параметре хука "useEffect()" нельзя использовать ключевые слова
async/await.*/
import React, {useEffect, useState} from 'react';
import {useDispatch, useSelector} from 'react-redux';
/*Импортируем хук "useHistory()", который управляет данными, связанными с роутингом и маршрутами, например, с адресной
строкой (в виде объекта "history"). С похожими данными работает HOC "withRouter()".*/
import {useHistory} from 'react-router-dom';
/*Импортируем объект "queryString" из библиотеки querystring, чтобы оттуда использовать функцию "parse()" для парсинга
строки и преобразования ее в объект, и функцию "stringify()" для обратного преобразования.*/
import * as queryString from 'querystring';
/*Импортируем TC "requestUsers()", TC "follow()", TC "unfollow()".*/
import {requestUsers, follow, unfollow, UsersFilterType} from '../../redux/users-reducer';
/*Импортируем объект "usersAC", что использовать оттуда ACs.*/
import {usersAC} from '../../redux/users-reducer';
/*Импортируем селекторы "getCurrentPage", "getPageSize", "getTotalUsersCount", "getWhoIsInFollowingProgress",
"getUsers", "getPortionSize", "getUsersFilter" и "getIsFetching".*/
import {
    getCurrentPage, getPageSize, getTotalUsersCount, getWhoIsInFollowingProgress, getUsers, getPortionSize,
    getUsersFilter, getIsFetching
} from '../../redux/users-selectors';
/*Импортируем компонент "Paginator".*/
import {Paginator} from '../common/Paginator/Paginator';
/*Импортируем компонент "User".*/
import {User} from './User/User';
/*Импортируем компонент "UsersSearchForm".*/
import {UsersSearchForm} from './UsersSearchForm/UsersSearchForm';
/*Импортируем компонент "Preloader".*/
import {Preloader} from '../common/Preloader/Preloader';

type PropsType = {};

/*Создаем тип для сформированного на основе параметров адресной строки объекта, который будет содержать свойства,
обозначающие данные для фильтрации пользователей в постраничном выводе.*/
type QueryParamsType = {
    term?: string,
    friend?: string,
    page?: string
};

/*"Users" это функциональный компонент, который создан в виде стрелочной функции. "Users" является компонентом, который
отображает страницу с постраничным выводом пользователей.

Внутри компонента "Users" используются следующие компоненты:
1. "Preloader" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,
пока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.
2. "User" - компонент, который описывает, как должны выглядеть блоки с информацией о пользователе на странице с
постраничным выводом пользователей. Импортирован.
3. "UsersSearchForm" - компонент, который отображает форму с фильтрами для поиска пользователей на странице с
постраничным выводом пользователей. Импортирован.
4. "Paginator" - компонент, который содержит логику для высчитывания и отображения текущей страницы в постраничном
выводе пользователей. Импортирован.

Компонент "Users" импортируется в файле "App.tsx".*/
export const Users: React.FC<PropsType> = (props) => {
    /*При помощи хука "useSelector()", передав в него селектор "getTotalUsersCount()", получаем общее количество
    пользователей.*/
    const totalUsersCount = useSelector(getTotalUsersCount);
    /*При помощи хука "useSelector()", передав в него селектор "getCurrentPage()", получаем номер текущей выбранной
    страницы в постраничном выводе.*/
    const currentPage = useSelector(getCurrentPage);
    /*При помощи хука "useSelector()", передав в него селектор "getPageSize()", получаем максимальное количество
    пользователей на одной странице в постраничном выводе.*/
    const pageSize = useSelector(getPageSize);
    /*При помощи хука "useSelector()", передав в него селектор "getPortionSize()", получаем свойство, которое указывает
    какое максимальное количество номеров страниц в постраничном выводе может отображаться в одной порции таких страниц.
    Это сделано, чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность выбирать
    страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими порциями страниц.*/
    const portionSize = useSelector(getPortionSize);
    /*При помощи хука "useSelector()", передав в него селектор "getUsers()", получаем данные по пользователям для
    постраничного вывода.*/
    const users = useSelector(getUsers);
    /*При помощи хука "useSelector()", передав в него селектор "getWhoIsInFollowingProgress()", получаем специальное
    свойство, содержащее массив, хранящий ID пользователей, которые в какой-то определенный момент находятся в процессе
    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
    const WhoIsInFollowingProgress = useSelector(getWhoIsInFollowingProgress);
    /*При помощи хука "useSelector()", передав в него селектор "getUsersFilter()", получаем данные для фильтрации
    пользователей в постраничном выводе.*/
    const filter = useSelector(getUsersFilter);
    /*При помощи хука "useSelector()", передав в него селектор "getIsFetching()", получаем специальное свойство,
    обозначающее находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного вывода
    (если в процессе, то будет отрисовываться компонент-заглушка "Preloader").*/
    const isFetching = useSelector(getIsFetching);
    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый
    элемент из хука "useState()", этот элемент будет означать специальное свойство, которое показывает то, что мы успели
    уже указать данные для фильтрации пользователей в постраничном выводе или не успели (изначально false). Нам это
    нужно, чтобы затриггерить функцию "push()" в компоненте "Users", когда мы выбираем первую страницу после того как
    уже выбрали другую страницу в постраничном выводе. Вторая переменная будет хранить функцию из хука "useState()",
    которая будет изменять первый элемент (то есть указывать то, что мы успели уже указать данные для фильтрации
    пользователей в постраничном выводе или не успели). При помощи типизации указываем, что первый параметр должен быть
    булева типа.*/
    const [isNotJustCreated, setIsNotJustCreated] = useState<boolean>(false);
    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый
    элемент из хука "useState()", этот элемент будет означать специальное свойство, которое показывает то, что мы еще не
    успели указать данные для фильтрации пользователей в постраничном выводе или успели (изначально true). Нам это
    нужно, чтобы не затриггерить функцию "push()" в компоненте "Users" при первой отрисовке, то есть когда не указано
    параметров фильтрации пользователей и выбрана первая страница в постраничном выводе по умолчанию, так как
    UI-фреймворк Ant Design при взаимодействии с некоторыми элементами интерфейса (например, при нажатии на кнопки или
    при изменении параметров адресной строки) сворачивает все подменю, чего нам не хотелось бы видеть при первой
    отрисовке компонента. Вторая переменная будет хранить функцию из хука "useState()", которая будет изменять первый
    элемент (то есть указывать то, что мы еще не успели уже указать данные для фильтрации пользователей в постраничном
    выводе или успели). При помощи типизации указываем, что первый параметр должен быть булева типа.*/
    const [isJustCreated, setIsJustCreated] = useState<boolean>(true);
    const dispatch = useDispatch();
    /*Используем хук "useEffect()", чтобы получить данные по пользователям для постраничного вывода при отрисовке
    компонента. Первый параметр это TC "requestUsers()" для запроса и установки данных по пользователям в постраничном
    выводе, передав значение текущей выбранной страницы, максимальное количество пользователей на одной странице в
    постраничном выводе и данные для фильтрации пользователей в постраничном выводе. Второй параметр это пустой массив,
    так как мы хотим, чтобы TC "requestUsers()" из первого параметра сработал только один раз после создания
    компонента.*/
    useEffect(() => { dispatch(requestUsers(currentPage, pageSize, filter)) }, []);
    /*Сохраняем вызов хука "useHistory()" для более краткого использования хука "useHistory()".*/
    const history = useHistory();

    /*Используем хук "useEffect()", чтобы синхронизировать данные для фильтрации пользователей в постраничном выводе и
    номер текущей выбранной страницы в постраничном выводе, указанные в параметрах адресной строки, с аналогичными
    данными из глобального state при отрисовке компонента.*/
    useEffect(() => {
            /*Первым параметром мы получаем параметры, указанные в адресной строке (например, строку
            "?term=a&friend=true&page=2"), обращаясь к объекту "history", который возвращается хуком "useHistory()".
            Поскольку нам не нужен знак "?" в полученной строке, то мы используем функцию "substr()", передав в нее 1 в
            качестве параметра, чтобы считывалось все после первого символа.*/
            const search = history.location.search.substr(1);
            /*Также в рамках первого параметра, при помощи функции "parse()" из библиотеки querystring мы парсим строку
            с параметрами адресной строки, превращая ее в объект, например,
            "{term: "a", friend: "true", page: "1"}". Также указываем, чтобы этот объект воспринимался как объект типа
            "QueryParamsType".*/
            const parsed = queryString.parse(search) as QueryParamsType;
            /*Также в рамках первого параметра, получаем номер актуальной текущей выбранной страницы в постраничном
            выводе.*/
            let actualCurrentPage = currentPage;
            /*Также в рамках первого параметра, получаем актуальные данные для фильтрации пользователей в постраничном
            выводе.*/
            let actualFilter = filter;
            /*Также в рамках первого параметра, если в параметрах адресной строки была указана текущая выбранная
            страница, то ее номер запишется в переменную "actualCurrentPage". При помощи функции "Number()" приводим
            строку к числу. При помощи "!!" переводим значение "parsed.page" в булев тип.*/
            if (!!parsed.page) actualCurrentPage = Number(parsed.page);
            /*Также в рамках первого параметра, если в параметрах адресной строки был указан параметр "term", то
            значение этого параметра запишется в переменную "actualFilter". Делаем здесь глубокое копирование, чтобы
            соблюдать иммутабельность, поскольку работаем с объектом. Если мы укажем в адресной строке какой-либо
            параметр больше одного раза, то ни один из них не будет перезатирать других. И если мы получаем эти
            параметры в виде строки, переводя ее в объект, то этот параметр в объекте будет иметь значение массива со
            всеми значениями этого параметра, указанными в адресной строке, поэтому мы указываем, чтобы значение
            параметра "term" воспринималось как строка при помощи "as string". При помощи "!!" переводим значение
            "parsed.term" в булев тип.*/
            if (!!parsed.term) actualFilter = {...actualFilter, term: parsed.term as string};

            /*Также в рамках первого параметра, если в параметрах адресной строки был указан параметр "friend", то
            значение этого параметра запишется в переменную "actualFilter". Делаем здесь глубокое копирование, чтобы
            соблюдать иммутабельность, поскольку работаем с объектом. Используем здесь конструкцию "switch/case", чтобы
            преобразовывать строковые значения в булев тип или null.*/
            switch (parsed.friend) {
                case 'null': {
                    actualFilter = {...actualFilter, friend: null};
                    break;
                }

                case 'true': {
                    actualFilter = {...actualFilter, friend: true};
                    break;
                }

                case 'false': {
                    actualFilter = {...actualFilter, friend: false};
                    break;
                }
            }

            /*Также в рамках первого параметра вызываем AC "setCurrentPage()" для установки значения текущей выбранной
            страницы в постраничном выводе пользователей в state, передав номер актуальной текущей выбранной страницы,
            который был получен из параметров адресной строки.*/
            dispatch(usersAC.setCurrentPage(actualCurrentPage));
            /*Также в рамках первого параметра вызываем TC "requestUsers()" для запроса и установки данных по
            пользователям в постраничном выводе, передав значение актуальной текущей выбранной страницы, максимальное
            количество пользователей на одной странице в постраничном выводе и актуальные данные для фильтрации
            пользователей в постраничном выводе.*/
            dispatch(requestUsers(actualCurrentPage, pageSize, actualFilter));
        },
        /*Второй параметр это пустой массив, так как мы хотим, чтобы все, что есть в первом параметре сработало только
        один раз после отрисовки компонента.*/
        []
    );

    /*Используем хук "useEffect()", чтобы синхронизировать данные для фильтрации пользователей в постраничном выводе и
    номер текущей выбранной страницы в постраничном выводе из глобального state с аналогичными данными из UI, чтобы
    указать эти данные в адресной строке в виде параметров. Это использование хука "useEffect()" должно обязательно идти
    после предыдущего использования хука "useEffect()", иначе будут затираться полученные из параметров адресной строки
    данные при отрисовке компонента, поскольку порядок хуков имеет значение.*/
    useEffect(() => {
            /*В рамках первого параметра создаем объект типа "QueryParamsType", в дальнейшем хранящий объект,
            сформированный на основе параметров адресной строки, который будет содержать свойства, обозначающие данные
            для фильтрации пользователей в постраничном выводе и номер текущей выбранной страницы в постраничном выводе.*/
            const query: QueryParamsType = {};

            /*Также в рамках первого параметра, если есть свойство "term" в объекте "filter", то добавляем его в наш
            объект "query". При помощи "!!" переводим значение "filter.term" в булев тип. Также указываем, что успели
            указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции
            "setIsJustCreated()" и функции "setIsNotJustCreated()" из хуков "useState()" выше.*/
            if (!!filter.term) {
                query.term = filter.term;
                setIsJustCreated(false);
                setIsNotJustCreated(true);
            }

            /*Также в рамках первого параметра, если свойство "friend" в объекте "filter" не равно "null", то есть равно
            true или false, то преобразовываем значение этого свойства в строку при помощи функции "String()" и
            добавляем преобразованное значение в наш объект "query". Также указываем, что успели указать данные для
            фильтрации пользователей в постраничном выводе при помощи вызова функции "setIsJustCreated()" и функции
            "setIsNotJustCreated()" из хуков "useState()" выше.*/
            if (filter.friend !== null) {
                query.friend = String(filter.friend);
                setIsJustCreated(false);
                setIsNotJustCreated(true);
            }

            /*Также в рамках первого параметра, если номер текущей выбранной страницы не равен 1, то сохраняем этот
            номер, переведя его в строку при помощи функции "String()", в наш объект "query". Также указываем, что
            успели указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции
            "setIsJustCreated()" и функции "setIsNotJustCreated()" из хуков "useState()" выше.*/
            if (currentPage !== 1) {
                query.page = String(currentPage);
                setIsJustCreated(false);
                setIsNotJustCreated(true);
            }

            /*Также в рамках первого параметра, если номер текущей выбранной страницы равен 1 и мы успели уже указать
            данные для фильтрации пользователей в постраничном выводе, то сохраняем этот номер, переведя его в строку
            при помощи функции "String()", в наш объект "query". Также указываем, что успели указать данные для
            фильтрации пользователей в постраничном выводе при помощи вызова функции "setIsJustCreated()" из хука
            "useState()" выше, но в этот раз вызываем функцию "setIsNotJustCreated()" из хука "useState()" выше, чтобы
            изменить свойство "isNotJustCreated" в локальном state на false, чтобы если мы после того, как мы совершим
            следующие операции:

            1. отрисовать компонент "Users";
            2. указать какие-либо параметры для фильтрации пользователей в постраничном выводе и сделать запрос
            пользователей;
            3. сбросить все параметры (в том числе выбрать первую страницу) для фильтрации пользователей в постраничном
            выводе и сделать запрос пользователей;
            4. отрисовать другой компонент;
            5. еще раз отрисовать компонент "Users";

            мы не затриггерили функцию "push()", чтобы библиотека Ant Design не свернула все подменю в навигационном
            меню, так как по стандартному поведению библиотеки Ant Design если мы взаимодействуем с некоторыми
            элементами UI (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все
            подменю.*/
            if (currentPage === 1 && isNotJustCreated) {
                query.page = String(currentPage);
                setIsJustCreated(false);
                setIsNotJustCreated(false);
            }

            /*Поскольку работа функции "push()" по изменению адресной строки считается UI-фреймворком Ant Design за
            взаимодействие с UI, поэтому при первом нажатии на пункт "Users" свернется подменю "People", так как по
            стандартному поведению UI-фреймворка Ant Design если мы взаимодействуем с некоторыми элементами UI
            (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все подменю. Поэтому
            мы добавили проверку, чтобы выполнять эту функцию "push()" только в том случае, когда какие-либо из данных в
            state, которые используются для формирования параметров адресной строки, были изменены.*/
            if (!isJustCreated) {
                /*Также в рамках первого параметра вызываем функцию "push()" объекта "history", который возвращается
                хуком "useHistory()", для того, чтобы перенаправить нас на адрес по пути "/users", дописав к этому пути
                параметры адресной строки из свойства "search" объекта "history".*/
                history.push({
                    pathname: '/users',
                    /*Здесь при помощи функции "stringify()" из библиотеки querystring мы преобразовываем наш объект
                    "query" в строку, в итоге, например, получая строку "?term=dad&friend=false&page=2". Аналогично мы
                    могли бы не формировать наш объект "query" сверху и написать здесь так:
                    "search: `?term=${filter.term}&friend=${filter.friend}&page=${currentPage}`".*/
                    search: queryString.stringify(query)
                });
            }
        },
        /*Второй параметр это данные для фильтрации пользователей в постраничном выводе, номер текущей выбранной
        страницы в постраничном выводе из глобального state и специальное свойство, которое показывает то, что мы еще не
        успели указать данные для фильтрации пользователей в постраничном выводе или успели. Последнее нам нужно, так
        как после первого выбора страницы по какой-то причине факт того, что "isJustCreated" становился false,
        игнорировался и не было обновления параметров адресной строки. Если эти данные будут меняться, то будет
        срабатывать каждый раз все то, что указано в первом параметре.*/
        [filter, currentPage, isJustCreated]
    );

    /*Создаем специальную функцию, которая будет вызываться при смене страницы в постраничном выводе пользователей. Эта
    функция принимает номер новой текущей выбранной страницы.*/
    const onPageChange = (pageNumber: number) => {
        /*Вызываем AC "setCurrentPage()" для установки значения текущей выбранной страницы в постраничном выводе
        пользователей в state, передав номер новой текущей выбранной страницы.*/
        dispatch(usersAC.setCurrentPage(pageNumber));
        /*Вызываем TC "requestUsers()" для запроса и установки данных по пользователям в постраничном выводе, передав
        значение новой текущей выбранной страницы, максимальное количество пользователей на одной странице в
        постраничном выводе и данные для фильтрации пользователей в постраничном выводе.*/
        dispatch(requestUsers(pageNumber, pageSize, filter));
    };

    /*Создаем специальную функцию, которая будет вызываться при изменении данных по фильтрам для отображения
    пользователей в постраничном выводе пользователей. Эта функция принимает данные по фильтрам для отображения
    пользователей в постраничном выводе пользователей, имеющие тип "UsersFilterType", который мы создали и импортировали
    сюда.*/
    const onFilterChange = (filter: UsersFilterType) => {
        /*Вызываем TC "requestUsers()" для запроса и установки данных по пользователям в постраничном выводе, передав
        значение новой текущей выбранной страницы (указали 1, так как если бы передавали сюда последнюю текущую
        выбранную страницу, то могли бы быть случаи, когда уже вывели несколько страниц пользователей, затем перешли на
        какую-то страницу, кроме первой, потом сделали новый запрос пользователей с другими фильтрами, и в ответ могло
        прийти меньшее количество страниц пользователей, чем номер страницы, которую мы до этого выбрали, например,
        были на 6-й странице, а пришло 5 страниц, в итоге мы окажемся на пустой 6-й странице, а указав 1, после
        каждого нового запроса пользователей нас будет всегда сбрасывать на первую страницу), максимальное количество
        пользователей на одной странице в постраничном выводе и данные для фильтрации пользователей в постраничном
        выводе.*/
        dispatch(requestUsers(1, pageSize, filter));
        /*Вызываем AC "setCurrentPage()" для установки значения текущей выбранной страницы в постраничном выводе
        пользователей в state, передав 1 как номер новой текущей выбранной страницы, чтобы избежать случая, когда уже
        вывели несколько страниц пользователей, затем перешли на какую-то страницу, кроме первой, потом сделали новый
        запрос пользователей с другими фильтрами, и в ответ могло прийти меньшее количество страниц пользователей, чем
        номер страницы, которую мы до этого выбрали, например, были на 6-й странице, а пришло 5 страниц, в итоге мы
        окажемся на пустой 6-й странице, а указав 1, после каждого нового запроса пользователей нас будет всегда
        сбрасывать на первую страницу.*/
        dispatch(usersAC.setCurrentPage(1));
    };

    /*Таким образом используем TC "unfollow()" для передачи его в компонент "User" ниже.*/
    const unfollowCallback = (userID: number) => { dispatch(unfollow(userID)) };
    /*Таким образом используем TC "follow()" для передачи его в компонент "User" ниже.*/
    const followCallback = (userID: number) => { dispatch(follow(userID)) };

    return (
        <div>
            {/*Если в state значение "isFetching" является true, то показываем компонент "Preloader". Если же компонент
            "Preloader" не отрисовывается, то далее отрисовываем компоненты "UsersSearchForm", "Paginator" и "User".*/}
            {isFetching ? <Preloader/> : null}

            {/*Отрисовываем компонент "UsersSearchForm" и передаем ему через props необходимые для него данные. Этот
            компонент представляет собой форму с фильтрами для поиска пользователей по различным критериям. Функция
            "onFilterChange()" нужны для обновления данных по фильтрам для отображения пользователей в постраничном
            выводе пользователей при изменении этих данных.*/}
            <UsersSearchForm onFilterChange={onFilterChange}/>

            {/*Далее отрисовываем компонент "Paginator" и передаем ему через props необходимые для него данные.*/}
            <Paginator
                /*Общее количество пользователей. Переименовываем в "totalItemsCount", так как компонент "Paginator"
                может использоваться для постраничного вывода любых элементов, не только пользователей.*/
                totalItemsCount={totalUsersCount}
                /*Максимальное количество пользователей на одной странице в постраничном выводе.*/
                pageSize={pageSize}
                /*Номер текущей выбранной страницы в постраничном выводе.*/
                currentPage={currentPage}
                /*Функция "onPageChange()" для обновления данных при смене текущей выбранной страницы в постраничном
                выводе.*/
                onPageChange={onPageChange}
                /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может
                отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих
                огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до
                40) и переключаться между этими порциями страниц.*/
                portionSize={portionSize}
            />

            {/*Далее в отдельном элементе "div" отрисовываем компонент "User" при помощи функции "map()".*/}
            <div>
                {/*В этом элементе <div> будут выводиться компоненты "User", отображающие информацию о каждом
                пользователе в постраничном выводе пользователей. */}
                {users.map(u => <User
                    key={u.id}
                    /*Объект с данным по пользователю.*/
                    user={u}
                    /*Специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то
                    определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются
                    AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
                    WhoIsInFollowingProgress={WhoIsInFollowingProgress}
                    /*TC для анфолловинга пользователей.*/
                    unfollow={unfollowCallback}
                    /*TC для фолловинга пользователей.*/
                    follow={followCallback}
                />)}
            </div>
        </div>
    )
};