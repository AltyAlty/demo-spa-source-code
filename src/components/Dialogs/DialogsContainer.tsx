import React, {ComponentType} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
Импортируем "ComponentType" для типизации.
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Эта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/
import {compose} from 'redux';
/*
Функция "compose" из функционального программирования. Эта функция создает композицию обработчиков.
Библиотека "redux" содержит свою реализацию "compose". При помощи функции "compose" можно объеденять, например,
несколько обверток вокруг компонента и HOCs.
Обвертки и HOCs указываются снизу вверх. Функция "compose" вызывается дважды и работает схожим образом, как и метод
"connect" из библиотеки "react-redux".
*/

import Dialogs from './Dialogs'; /*Подключаем компонент "Dialogs".*/

import {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC "withAuthRedirect" для
добавления редиректа.*/

import {dialogsAC, InitialDialogsStateType} from '../../redux/dialogs-reducer'; /*Подключаем объект "dialogsAC", что
использовать оттуда AC "addMessageActionCreator" из "dialogs-reducer". Также подключаем типы оттуда.*/

import {AppStateType} from '../../redux/redux-store'; /*Подключаем типы.*/


/*Создаем тип для "MapStateToProps". "MapStateToProps" в этом компоненте должен обязательно содержать следующие поля с
указанными типами.*/
type MapStateToPropsType = {
    dialogsPage: InitialDialogsStateType /*Поскольку передаем в этот компонент весь "state" из "dialogs-reducer.ts",
    то указываем тип "InitialDialogsStateType" - это тип всего этого "state".*/
};

/*Создаем тип для "MapDispatchToProps". "MapDispatchToProps" в этом компоненте должен обязательно содержать следующие
поля с указанными типами.*/
type MapDispatchToPropsType = {
    addMessage: (newMessageText: string) => void /*AC для добавления нового исходящего сообщения, который принимает
    строковой параметр и ничего не возвращает.*/
};


/*
"DialogsContainer" это не классовый компонент и не функциональный компонент.
"DialogsContainer" является только контейнерным компонентом для компонента "Dialogs".
В отличии от классового компонента, этот компонент не имеет методов жизненного цикла.
Контейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.
Эти данные в нашем приложении контейнерные компоненты получают из контекста,
созданного при помощи "Provider" (указан в "App.tsx") из библиотеки "react-redux".
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
Этот компонент подключается в компоненте "App".
В этом компоненте мы просто создаем "mapStateToProps" и "mapDispatchToProps", тем самым формируя "props"
для презентационной компоненты "Dialogs". Поэтому нам не нужно создавать классовый компонент для этого.
Таким же образом созданы контейнерные компоненты "MyPostsContainer", "NavbarContainer".
*/


const mapStateToProps = (state: AppStateType): MapStateToPropsType => { /*Здесь указываются данные из "state", которые
необходимо передать в компонент "Dialogs". Эта функция возвращает указанные данные в виде объекта. На входе
"mapStateToProps" принимает "state" с типом "AppStateType", который мы создали и импортировали сюда, а на выходе выдает
данные с типом "MapStateToPropsType".*/
    return {
        dialogsPage: state.dialogsPage,
    }
};


export default compose<ComponentType>( /*При помощи функции "compose" объеденяем HOCs "withAuthRedirect" и "connect",
возвращая итоговый компонент "DialogsContainer". Здесь мы уточнили тип только одним параметром, так как согласно файлу
декларации функции "compose" (раздел "rest"), нам нужно уточнить только такой компонент, свойства "props" которого не
будут переданы в этот компонент функциями, которые были переданы внутрь функции "compose", то есть функциями "connect" и
"withRouter", то есть никакие свойства, так как мы не передаем извне ничего в компонент "Dialogs".*/
    connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps,
        {addMessage: dialogsAC.addMessage}), /*При помощи метода "connect" создаем контейнерный
        компонент, и тем самым передаем нужные данные BLL и DAL компоненту "Dialogs". Поскольку метод "connect"
        является "generic", то его можно уточнить: первым в "<>" указан тип для "MapStateToProps", вторым для
        "MapDispatchToProps", третьим для "собственных props" компонента, четвертым для "state". Эти параметры мы узнали
        перейдя в файл декларации метода "connect", "Ctrl+click" в "WebStorm".*/
    withAuthRedirect /*При помощи HOC "withAuthRedirect" добавляем логику по редиректу в компонент.*/
)(Dialogs);
/*А также экспортируем получившийся в итоге компонент, который будет использоваться в нашем проекте под именем
"DialogsContainer", по default, экспорт необходим для импорта.*/

/*----------------------------------------------------------------------------------------------------*/

/*Это старый вариант "mapDispatchToProps". Сейчас АС "addMessage" мы используем в функции "connect".
Здесь указываются данные ("callbacks - "AC" или "TC") "dispatch", которые необходимо передать в компонент "Dialogs".
Эта функция возвращает указанные данные в виде объекта.
Функция "mapDispatchToProps" работает следующим образом:
1) Компонент вызывает callback функцию "addMessage".
2) Компонент передает этой функции параметр "newMessageText".
3) Далее этот параметр передается в AC "addMessageActionCreator".
4) Этот AC вызывается.
5) Создается объект "action".
6) Этот объект "action" диспатчится в "dialogsReducer" в "dialogs-reducer.js".*/
/*const mapDispatchToProps = (dispatch) => {
    return {
        addMessage: (newMessageText) => {
            dispatch(dialogsAC.addMessage(newMessageText));
        }
    }
};*/