import React, {useState} from 'react';
/*Сlassnames - это библиотека для простого условного объединения имен классов. Для этого мы здесь используем функцию
"cn()" из этой библиотеки.
Как можно добавить два класса:
className = {styles.first + ' ' + styles.second} (без библиотеки "classnames")
className = {`${styles.first} ${styles.second}`} (без библиотеки "classnames")
className = {cn(styles.second, styles.first)} (с библиотекой "classnames")
Также при использовании этой библиотеки можно добавлять условия:
className = {cn(
                styles.first,
                {[styles.second] : true}
                )
            };*/
import cn from 'classnames';
import styles from './Paginator.module.css';

type PropsType = {
    /*Общее количество элементов для постраничного вывода должно быть числом.*/
    totalItemsCount: number
    /*Максимальное количество элементов на одной странице в постраничном выводе должно быть числом.*/
    pageSize: number
    /*Текущая выбранная страница в постраничном выводе должна быть числом.*/
    currentPage: number
    /*Метод для обновления данных при смене текущей выбранной страницы в постраничном выводе должен быть функцией,
    которая принимает числовой параметр и ничего не возвращает.*/
    onPageChange: (p: number) => void
    /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может отображаться
    в одной порции таких страниц, должно быть числом. Не является обязательным.*/
    portionSize?: number
};

/*"Paginator" это функциональный компонент, который создан в виде стрелочной функции. "Paginator" является компонентом,
который содержит логику для высчитывания и отображения текущей страницы в постраничном выводе пользователей. Этот
компонент можно использовать и для постраничного вывода любых других элементов.

Компонент "Paginator" импортируется в файле "Users.tsx".

При помощи деструктуризации props указываем какие именно props мы получаем:
1. "totalItemsCount" - общее количество элементов для постраничного вывода.
2. "pageSize" - максимальное количество элементов на одной странице в постраничном выводе.
3. "currentPage" - текущая выбранная страница в постраничном выводе.
4. "onPageChange" - метод для обновления данных при смене текущей выбранной страницы в постраничном выводе.
5. "portionSize" - свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может
отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное
количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между
этими порциями страниц. Если значение этого свойства не будет указано, то по умолчанию оно будет равно 10.*/
export const Paginator: React.FC<PropsType> = ({
                                                   totalItemsCount,
                                                   pageSize,
                                                   currentPage,
                                                   onPageChange,
                                                   portionSize = 10
                                               }) => {
    /*Высчитываем сколько страниц пользователей нам нужно (делим общее количество элементов на максимальное количество
    элементов на одной странице) и помещаем результат в переменную "pagesCount". Метод "Math.ceil()" округляет в большую
    сторону.*/
    const pagesCount = Math.ceil(totalItemsCount / pageSize);
    /*Создаем массив, содержащий такое количество элементов (например, номера страниц: 1, 2, 3 и так далее), которое
    будет равно количеству страниц в постраничном выводе пользователей "pagesCount". Далее мы будем мапить этот массив,
    чтобы вывести список номеров страниц для навигации по постраничному выводу элементов. Этот массив имеет тип массива
    чисел.*/
    const pages: Array<number> = [];
    /*Заполняем массив "pages" путем перебора "pagesCount". При помощи метода "push()" добавляем в конец массива "pages"
    каждый "i".*/
    for (let i = 1; i <= pagesCount; i++) pages.push(i);

    /*"portionCount" - количество порций страниц, которое мы имеем.
    "portionSize" - максимальное количество страниц в одной порции, берем из state.
    "lowerLimitOfCurrentPortion" - номер страницы, который является нижней границей текущей порции страниц.
    "upperLimitOfCurrentPortion" - номер страницы, который является верхней границей текущей порции страниц.
    "currentPortionNumber" - номер текущей порции страниц, используется в хуке "useState()".
    "setCurrentPortionNumber" - функция, меняющая номер текущей порции страниц, используется в хуке "useState()".*/

    /*Вычисляем количество порций страниц, путем деления количества всех страниц с пользователями на максимальное
    количество страниц в одной порции.*/
    const portionCount = Math.ceil(pagesCount / portionSize);
    /*При помощи деструктуризирующего присваивания создали две переменные. Первая переменная будет хранить первый
    элемент из хука "useState()", этот элемент будет означать номер текущей порции страниц (изначально 1). Вторая
    переменная будет хранить функцию из хука "useState()", которая будет изменять первый элемент (то есть менять номер
    текущей порции страниц).*/
    const [currentPortionNumber, setCurrentPortionNumber] = useState(1);
    /*Высчитываем номер страницы, который является нижней границей текущей порции страниц. Изначально это будет
    (1 - 1) + 1 = 1.*/
    const lowerBoundOfCurrentPortion = (currentPortionNumber - 1) * portionSize + 1;
    /*Высчитываем номер страницы, который является верхней границей текущей порции страниц. Изначально это будет
    1 * 20 = 20.*/
    const upperBoundOfCurrentPortion = currentPortionNumber * portionSize;

    return (
        <div className={styles.paginator}>
            {/*Если текущий номер порции страниц больше 1, то отрисовываем элемент "button", при нажатии на который
            будет уменьшаться текущий номер порции страниц на 1, то есть мы будем переходить назад на предыдущую порцию
            страниц (например, с "от 21 до 40" до "1 до 20"). Соответственно, изначально это кнопка не отрисовывается,
            так как мы по дефолту находимся на 1-й порции страниц.*/}
            {currentPortionNumber > 1 &&
                <button onClick={() => {
                    setCurrentPortionNumber(currentPortionNumber - 1)
                }}>
                    {/*Текст кнопки "предыдущая порция страниц".*/}
                    PREV
                </button>}

            {pages
                /*Из массива "pages" берем только те номера страниц, которые больше или равны нижней границе текущей
                порции страниц и меньше или равны верхней границе текущей порции страниц.*/
                .filter(p => p >= lowerBoundOfCurrentPortion && p <= upperBoundOfCurrentPortion)
                /*Далее мапим отфильтрованный массив "pages".*/
                .map(p => {
                    /*Здесь возвращаем JSX в виде "span" элементов. Количество этих "span" элементов будет равно
                    количеству элементов в массиве "pages". Это будет список номеров страниц для навигации в
                    постраничном выводе пользователей.*/
                    return (
                        <span
                            /*Будет применяться особый стиль к странице "p", номер которой равен номеру текущей
                            выбранной страницы в постраничном выводе из state, благодаря использованию функции "cn()".*/
                            className={cn({[styles.selectedPage]: currentPage === p}, styles.pageNumber)}
                            key={p}
                            /*Это анонимная функция, которая будет вызываться при событии нажатия на элемент. Эта
                            анонимная функция будет вызывать наш метод "onPageChange()" и передавать в него номер
                            страницы, на которую мы нажали. В результате мы изменим текущую выбранную страницу в
                            постраничном выводе в state.*/
                            onClick={() => { onPageChange(p) }}>
                            {/*Выводим текст самого номера страницы в элементе "span".*/}
                            {p}
                        </span>
                    )
                })
            }

            {/*Если количество порций страниц больше текущего номера порции страниц, то отрисовываем элемент "button",
            при нажатии на который будет увеличиваться текущий номер порции страниц на 1, то есть мы будем переходить
            вперед на следующую порцию страниц (например, с "от 1 до 20" до "21 до 40"). Соответственно, на последней
            порции страниц это кнопка не отрисовывается, так как текущая порция страниц, которая является последней
            порцией страниц, равна максимальному количеству порций страниц.*/}
            {portionCount > currentPortionNumber &&
                <button onClick={() => { setCurrentPortionNumber(currentPortionNumber + 1) }}>
                    {/*Текст кнопки "следующая порция страниц".*/}
                    NEXT
                </button>}
        </div>
    )
};