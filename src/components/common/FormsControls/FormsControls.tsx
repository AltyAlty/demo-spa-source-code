import React from 'react';
/*Импортируем тип "WrappedFieldMetaProps", который мы нашли в файле декларации компонента "Field" и используем его для
указания типа созданного нами компонента "FormControl". Импортируем тип "WrappedFieldProps", который мы нашли в файле
декларации компонента "Field" и используем его для указания типа созданных нами компонентов "Textarea" и "Input".*/
import {Field, WrappedFieldMetaProps, WrappedFieldProps} from 'redux-form';
import styles from './FormsControls.module.css';
/*Импортируем тип "FieldValidatorType".*/
import {FieldValidatorType} from '../../../utils/validators/validators';

/*Типизируем props для компонента "FormControl".*/
type FormControlPropsType = {
    /*Объект "meta" с мета-данными, приходящий к нам сверху из компонента "Field" из библиотеки Redux Form, должен иметь
    тип "WrappedFieldMetaProps".*/
    meta: WrappedFieldMetaProps
};

/*Следующий тип мы создаем специально, чтобы мы не могли допустить ошибок при указании свойства "name" в функции
"createField()". Это свойство важно для формирования имен свойств "formData", то есть данных формы. Для этого мы строим
свой generic, чтобы можно было уточнить функцию "createField()". Нужные нам имена свойств уже должны быть перечислены в
каком-то другом типе, чтобы мы при помощи "keyof" получали ключи из этого типа. Далее при помощи Extract (берется из
Typescript) берем из этих ключей, только те, которые могут быть назначены как строка. И на основе этого создаем тип. Для
большего количество деталей смотри реализацию функции "createField()" в этом файле.*/
export type GetValuesKeysType<T> = Extract<keyof T, string>;

/*"FormControl" это функциональный компонент, который создан в виде стрелочной функции. "FormControl" является
компонентом, который содержит общую логику для графического отображения срабатывания валидаторов независимо от типа
элемента.

Компонент "FormControl" используется в компонентах "Textarea" и "Input" в этом же файле.

Компонент "FormControl" получает на входе мета-данные, содержащие информацию касались ли мы элемента и есть ли
какая-либо ошибка (вроде, это все берется из библиотеки Redux Form, а текст ошибки, вроде, берется из того, что
возвращают валидаторы при срабатывании и передают это в компонент "Field", собственно от компонента "Field" этот
компонент и будет получать эти данные при помощи замыкания), а также получает информацию о дочернем элементе.*/
const FormControl: React.FC<FormControlPropsType> =
    ({meta: {touched, error}, children}) => {
        /*Создаем специальную константу для удобства, которая содержит условие, что в мета-данных указано, что мы
        касались элемента ("meta.touched") и что присутствует какая-то ошибка ("meta.error"). Только здесь может быть
        проблема, если мы не касались какого-то поля, то нам разрешат отправить, например, пустой пост на странице
        профиля. Этот объект "meta" с мета-данными придет к нам сверху из компонента "Field".*/
        const hasError = touched && error;

        return (
            /*Этот компонент возвращает JSX, содержащий элемент "div", внутри которого будет меняться CSS в зависимости
            от значения константы "hasError". То есть будет два варианта:
            1. "styles.formControl styles.error"
            2. "styles.formControl"*/
            <div className={styles.formControl + ' ' + (hasError ? styles.error : '')}>
                {/*Внутри отрисовываем еще один элемент "div". "children" это ключевое слово в React. При помощи этого
                слова этот элемент "div" будет отрисовывать потомков, которые будут указаны в месте вызова компонента
                "FormControl".*/}
                <div>
                    {children}
                </div>

                {/*Также внутри отрисовываем еще один элемент "div". В этом элементе будет отображаться элемент "span"
                с текстом ошибки, указанного в валидаторе.*/}
                <div>
                    {hasError && <span>{error}</span>}
                </div>
            </div>
        )
    };

/*Компонент "Textarea" это функциональный компонент, который создан в виде стрелочной функции. "Textarea" является
компонентом, который используется для отрисовки элементов "textarea" в других местах, где в таких элементах требуется
валидация.

Внутри компонента "Textarea" используются следующие компоненты:
1. "FormControl" - компонент, который содержит общую логику для графического отображения срабатывания валидаторов
независимо от типа элемента. Из этого же файла.

Компонент "Textarea" импортируется в файлах "Dialogs.tsx", "MyPosts.tsx" и "ProfileDataReduxEditForm.tsx".*/
export const Textarea: React.FC<WrappedFieldProps> = (props) => {
    /*Таким образом при помощи деструктуризации мы создаем константы:
    1. "const input = props.input" - здесь внутри есть "input.value", что является тем, что введено в поле, создается
    компонентом "Field" из библиотеки Redux Form.
    2. "const meta = props.meta" - это мета-данные, создаваемые компонентом "Field" из библиотеки Redux Form, внутри
    которых есть "touched" или "error", используемые в компоненте "FormControl".
    3. "...restProps" это остальные props (в виде объекта), которые в дальнейшем можно передавать как "...restProps",
    например, там будет "placeholder" для элементов "textarea" или "input".*/
    const {input, meta, ...restProps} = props;
    /*Этот компонент возвращает компонент "FormControl", который получит props свыше и деструктуризирует их, а затем
    передаст их дочерним элементам. А в качестве дочернего элемента этот компонент будет иметь элемент "textarea",
    внутри которого будет при помощи деструктуризации передано:
    1. "input.value" - то, что введено в поле.
    2. остальные "input." свойства.
    3. и объект с остальными props.

    То есть поскольку компонент "Textarea" будет использоваться в компоненте "Field" из библиотеки Redux Form (цепочка
    будет такая: компонент "Field" -> компонент "Textarea" -> компонент "FormControl" -> элемент "textarea"), то значит,
    что компонент "FormControl" получит "сверху" "props.meta.touched" и "props.meta.error" при помощи библиотеки Redux
    Form, которые ему необходимы для работы. А также компонент "FormControl" получит информацию о своем дочернем
    элементе "textarea", так как использует ключевое слово "children" из React, поэтому он сможет передать этому
    дочернему элементу необходимые для него props, например "placeholder" (то есть при помощи замыкания будет доступ к
    props из компонента "Field", компонента "Textarea" и компонента "FormControl").*/
    return <FormControl {...props}><textarea {...input} {...restProps}/></FormControl>
};

/*Компонент "Input" это функциональный компонент, который создан в виде стрелочной функции. "Input" является
компонентом, который используется для отрисовки элементов "input" в других местах, где в таких элементах требуется
валидация.

Внутри компонента "Input" используются следующие компоненты:
1. "FormControl" - компонент, который содержит общую логику для графического отображения срабатывания валидаторов
независимо от типа элемента. Из этого же файла.

Компонент "Input" импортируется в файлах "Login.tsx" и "ProfileDataReduxEditForm.tsx".*/
export const Input: React.FC<WrappedFieldProps> = (props) => {
    /*Таким образом при помощи деструктуризации мы создаем константы:
    1. "const input = props.input" - здесь внутри есть "input.value", что является тем, что введено в поле, создается
    компонентом "Field" из библиотеки Redux Form.
    2. "const meta = props.meta" - это мета-данные, создаваемые компонентом "Field" из библиотеки Redux Form, внутри
    которых есть "touched" или "error", используемые в компоненте "FormControl".
    3. "...restProps" это остальные props (в виде объекта), которые в дальнейшем можно передавать как "...restProps",
    например, там будет "placeholder" для элементов "textarea" или "input".*/
    const {input, meta, ...restProps} = props;
    /*Этот компонент возвращает компонент "FormControl", который получит props свыше и деструктуризирует их, а затем
    передаст их дочерним элементам. А в качестве дочернего элемента этот компонент будет иметь элемент "input", внутри
    которого будет при помощи деструктуризации передано:
    1. "input.value" - то, что введено в поле;
    2. остальные "input." свойства;
    3. и объект с остальными props;

    То есть поскольку компонент "Input" будет использоваться в компоненте "Field" из библиотеки Redux Form (цепочка
    будет такая: компонент "Field" -> компонент "Input" -> компонент "FormControl" -> элемент "input"), то значит, что
    компонент "FormControl" получит "сверху" "props.meta.touched" и "props.meta.error" при помощи библиотеки Redux Form,
    которые ему необходимы для работы. А также компонент "FormControl" получит информацию о своем дочернем элементе
    "input", так как использует ключевое слово "children" из React, поэтому он сможет передать этому дочернему элементу
    необходимые для него props, например "placeholder" (то есть при помощи замыкания будет доступ к props из компонента
    "Field", компонента "Input" и компонента "FormControl").*/
    return <FormControl {...props}><input {...input} {...restProps}/></FormControl>
};

/*Создаем функцию "createField()", которая принимает параметры и создает элементы формы. Функция "createField()"
используется для создания формы как аналог компонента "Field" из библиотеки Redux Form.

Функция "createField()" импортируется в файлах "Dialogs.tsx", "Login.tsx", "MyPosts.tsx" и
"ProfileDataReduxEditForm.tsx".

Указываем, что функция "createField()" теперь обобщенная, то есть generic. Если бы мы описали эту функцию стрелочным
синтаксисом, то у нас так не получилось бы ее сделать generic. То есть теперь мы можем уточнять эту функцию при ее
использовании, а точнее мы будем уточнять свойство "name", поэтому указываем придуманный нами тип "FormKeysType" здесь и
в самом "name" дальше.

При помощи "extends string" указываем, что этот тип экстендится от типа строки (то есть должен совпадать со строкой),
хотя и может быть более сложным. Последнее нам нужно, чтобы не было ошибки ниже в "name={name}", так как там по сути
ожидается строка.*/
export function createField<FormKeysType extends string>(
    /*Текст "placeholder". Должен быть строкой или undefined, то есть отсутствовать вовсе, а не быть пустым.*/
    placeholder: string | undefined,
    /*Имя данных, которые будут вводиться в это поле. Имеют тип "FormKeysType", то есть здесь указываются какие-то
    ключи, но какие именно мы должны указывать сами в каждой форме. Нам это нужно для того, чтобы проводить типизацию в
    целях избежания ошибок при указании свойства "name" при использовании функции "createField()" в компонентах. Это
    свойство важно для формирования имен свойств "formData", то есть данных формы.*/
    name: FormKeysType,
    /*Какой компонент отрисовываем (например, "Textarea" или "Input" из этого файла). Указали при помощи "React.FC<>",
    что "props" в этих функциональных компонентах имеют тип "WrappedFieldProps".*/
    component: React.FC<WrappedFieldProps>,
    /*Валидаторы. Должны быть в виде массива элементов с типом "FieldValidatorType".*/
    validators: Array<FieldValidatorType>,
    /*Любые другие "props".*/
    props = {},
    /*Текст, который необходим некоторым элементам (например, "Remember me?" для чек-бокса "Запомнить меня?"). Должно
    быть по умолчанию строкой.*/
    text = ''
) {
    return (
        /*В итоге функция создает отдельный элемент "div", в котором внутри есть компонент "Field" из библиотеки Redux
        Form. Что из себя будет представлять этот компонент "Field" будет зависеть от параметров выше.*/
        <div>
            <Field
                placeholder={placeholder}
                name={name}
                component={component}
                validate={validators}
                {...props}
            /> {text}
        </div>
    )
};