import React, {useState, useEffect} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".

Классовый компонент позволяет реализовать локальный "state" (смотри "ProfileStatus") и методы
жизненного цикла ("componentDidMount" и т.д.), а функциональный компонент этого не может делать.
Такие возможности классового компонента были созданы благодаря тому, что "React" на основе класса
создает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может
хранить такие вещи как "state" и методы. Функция же просто вызывается и возвращает "JSX", постоянное
общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала
и удалилась. Для решения этой проблемы в функциональных компонентах были созданы "Hooks" (хуки).
"Hook" - это функция, которая может делать side effects.
"React" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и
этой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента
"React" запоминает эту информацию где-то на своей стороне, а не внутри объекта.
Хуки нельзя писать в условиях и циклах, так как это нарушает порядок хуков, который является важным.
Можно писать свои кастомные хуки.

Подключаем хук "useState", который возвращает массив с двуми элементами. Первый элемент - это значение,
которое хранится в "state". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя
первый элемент мы заставляем "React" перерисовывать функциональный компонент.
Хук "useState" работает асинхронно, то есть если мы изменяем какое-либо значение при помощи этого хука, то мы говорим,
чтобы "ReactJS" изменил это значение как только сможет, не обращая внимание на порядок соседних инструкций рядом с
кодом, где мы меняем какое-то значение из локального "state".
Нужно помнить, что если наш JSX в компоненте не зависит от хука "useState", то нежелательно хранить какие-то данные в
таком хуке "useState".
При вызове нескольких вторых элементов из нескольких хуков "useState" в асинхронных операциях (например, в запросах на
сервер), нужно обращать внимание на порядок этих вторых элементов из нескольких хуков "useState".

Подключаем хук "useEffect", который принимает функцию первым параметром и выполняет ее, когда произойдет
отрисовка компонента, то есть после каждого вызова "render". Вторым параметром этот хук принимает зависимости -
зависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то
этот хук сработает только один раз. Этот хук используется для side effects.
Хук "useEffect" позволяет нам синхронизировать какие-то вещи в программе между собой. Такая синхронизация нужна для
динамического изменения верстки с целью отображения ее актуального состояния пользователю. Синхронизация между двумя
сторонами может работать двунаправленно. Синхронизация происходит после отрисовки компонента, а не до.
В хуке "useEffect" на самом деле желательно избегать пустой зависимости "[]" во втором параметре.
Если не указать второй параметр в хуке "useEffect" вообще, то он будет срабатывать при каждой отрисовке компонента.
В первом параметре хука "useEffect" нельзя использовать "async/await".
*/

import {selectedGitHubUserDetailsType} from '../../UseEffectTheory'; /*Импортируем типы.*/

import styles from './Timer.module.css'; /*Подключаем стили из CSS-модуля.*/


/*Создаем тип для "props". "Props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.
Все это нужно для указания типа "props" в функциональном компоненте.*/
type PropsType = {
    selectedGitHubUserDetails: selectedGitHubUserDetailsType | null /*Детали профиля выбранного пользователя GitHub
    должны быть типа "selectedGitHubUserDetailsType", который мы импортировали сюда, или "null".*/
    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void
    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа
    "selectedGitHubUserDetailsType", который мы сюда импортировали, или "null", и ничего не возвращает.*/
    timerKey: number /*ID выбранного пользователя GitHub должно быть числом.*/
};


/*
"Timer" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется из
памяти.
Функциональный компонент можно создать еще и таким образом: function Timer(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"Timer" является компонентом, который используется для отображения таймера для просмотра профиля пользователя GitHub.
Этот компонент подключается в компоненте "UserInfo".
*/
export const Timer: React.FC<PropsType> = ({
                                               selectedGitHubUserDetails,
                                               setSelectedGitHubUserDetails,
                                               timerKey
                                           }) => { /*При помощи деструктуризации "props" указываем какие именно "props"
мы получаем, чтобы не писать далее "props.selectedGitHubUserDetails" и так далее. Такое мы делаем только в
функциональных компонентах. Указали при помощи "React.FC<>", что "props" в этом функциональном компоненте имеют тип
"PropsType". Также указали, что экспортируем этот компонент.*/

    console.log('RENDERING TIMER');

    const initialSecondsToLive = 60; /*Изначальное время таймера.*/

    let [secondsToLive, setSecondsToLive] = useState(initialSecondsToLive); /*При помощи деструктуризирующего
    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент
    будет означать секунды в таймере (изначально берется из переменной "initialSecondsToLive"). Вторая переменная будет
    хранить функцию из хука "useState", которая будет изменять первый элемент (то есть менять секунды в таймере).*/

    useEffect(() => { /*Используем хук "useEffect" для реализации отсчета секунд в таймере.*/
            console.log('INITIALIZING TIMER');

            const intervalID = setInterval(() => {
                setSecondsToLive((prev) => prev - 1);
            }, 1000);
            /*Здесь можно было использовать функцию "setTimeout()" и указать вторым параметром в этом хуке "useEffect"
            секунды таймера, но мы решили так не делать, чтобы не перезапускать эту функцию "setTimeout()" каждую
            секунду.

            Поэтому мы использовали потом функцию "setInterval()" без указания зависимости в хуке "useEffect". Но это
            приводило к тому, что хоть секунды и менялись в хуке "useState", значение для отображения застревало на
            одном и том же месте после отсчета одной секунды. Так происходило из-за замыкания. Изначально таймер
            фиксировал у себя значение 60 секунд в локальном "state". Дальше фиксировался хук "useEffect", но не
            запускался. Потом происходила отрисовка 60 секунд. После этой отрисовки запускалась функция "setInterval()"
            из этого хука "useEffect". Эта функция "setInterval()" обращалась к секундам таймера, которых у нее самой
            нет, поэтому она пыталась взять их через замыкание у родителя - у хука "useEffect", но поскольку и у этого
            хука не было секунд таймера, то в итоге эти секунду брались через замыкание у функции "Timer". Брались они
            из первой отрисовки, то есть из первого вызова функции "Timer". После первой отрисовки функция
            "setInterval()" срабатывала и количество секунд становилось 59, то есть менялось значение в локальном
            "state", что вызывало еще одну отрисовку функции "Timer" и отрисовывалось уже 59 секунд. Но поскольку не
            было указано зависимостей в этом хуке "useEffect", то при второй и последующих отрисовках регистрации этого
            хука "useEffect" уже не происходило, поэтому запуска и пересинхронизации функции "setInterval()" с новой
            отрисовкой тоже не происходило. То есть далее когда в локальном "state" становилось 58 секунд, поскольку
            больше не происходило регистрации этого хука "useEffect" и соотвественно больше не пересинхронизировалась
            функция "setInterval()" c новыми отрисовками, то этой функцией "setInterval()" каждый раз бралось значение
            60 секунд из первой отрисовки функции "Timer". Поэтому мы и видели только 59 секунд в таймере.

            Чтобы этого избежать, поскольку наше новое значение секунд таймера зависит от старого значения секунд
            таймера из локального "state", то вместо "() => {setSecondsToLive(secondsToLive - 1)}" в качестве параметра
            функции "setInterval()" мы использовали "() => {setSecondsToLive((prev) => prev - 1)}", то есть мы
            использовали функцию "(prev) => prev - 1", которая при помощи "React" рассчитывала именно актуальное
            значение секунд таймера. То есть использование такого написания функции позволит нам брать актуальные
            значения из хука "useState".*/

            return () => {
                clearInterval(intervalID);
            }; /*Хоть мы в хуке "useEffect" ниже и "убиваем" компонент "UserInfo", что в итоге скрывает и компонент
            "Timer", сам таймер продолжает тикать и меняется значение в локальном "state". Чтобы подчистить это нам
            нужна функция зачистки (clean up). Эта функция будет вызываться, когда компонент "будет" умирать или каждый
            раз когда будет меняться второй параметр хука "useEffect", чтобы подчистить мусор перед новым запуском.
            Такую функцию нужно поместить в "return". В данном случае нам нужно отключить функцию "setInterval()",
            поэтому для этого есть специальная функция "clearInterval()", в которой нужно указать ID этой функции
            "setInterval()", для чего мы ее обвернули в отдельную переменную "intervalID", в которую функция
            "setInterval()" отдаст на выходе свой ID. Такие функции зачистки нужны еще, например, для функции
            "setTimeout()", для отписки от DOM-библиотек (яндекс карты, google карты и т.д.), для отписки от событий,
            для закрытия WS и так далее.*/
        },
        [timerKey] /*Если это значение будет меняться, то будет срабатывать каждый раз функция из первого
        параметра. Если вторым параметром здесь ничего не указывать, то секундомер будет работать, но при переключении
        профилей таймер будет сбрасываться на изначальное значение, но первая секунда будет длиться короче, так как она
        будет сливаться с последней секундой предыдущего таймера. Чтобы этого избежать мы будем получать некий параметр
        извне и сделаем его зависимостью в этом хуке "useEffect". В данном случае мы будет получать ID пользователя
        GitHub (можно на самом деле получать любые данные профиля пользователя, суть работы не поменяется), которого
        выбрали. То есть когда мы будем получать такой ID, соотвественно когда мы загружаем новый профиль и хотим, чтобы
        таймер полностью сбросился, этот хук "useEffect" будет полностью перезапускать функцию из своего первого
        параметра при помощи нашей функции зачистки, что в итоге поможет нам избежать случаев "склеивания" первой
        секунды нового таймера и последней секунды старого таймера.*/
    );

    useEffect(() => { /*Используем хук "useEffect", чтобы сбрасывать таймер при переключении профилей
    пользователей GitHub.*/
            console.log('RESETTING TIMER');

            setSecondsToLive(initialSecondsToLive); /*Используем функцию "setSecondsToLive" из хука "useState", чтобы
            сбрасывать секунды таймера в изначальное состояние.*/
        },
        [selectedGitHubUserDetails] /*Второй параметр это детали профиля выбранного пользователя GitHub. Если эти
        детали будут меняться, то будет срабатывать каждый раз функция из первого параметра.*/
    );

    useEffect(() => { /*Используем хук "useEffect", чтобы отключать таймер и закрывать профиль пользователя
    GitHub, когда истекает сам таймер.*/
            console.log('TRYING TO TURN TIMER OFF');

            if (secondsToLive < 1) { /*Когда время таймера истечет, мы сбрасываем данные профился пользователя GitHub,
            тем самым отключая компонент "UserInfo", в котором также содержится и компонент "Timer".*/
                setSelectedGitHubUserDetails(null);
                console.log('TURNING TIMER OFF');
            }
            ;
        },
        [secondsToLive] /*Второй параметр это секунды в таймере. Если это значение будет меняться, то будет
        срабатывать каждый раз функция из первого параметра.*/
    );

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div className={styles.timerSeconds}> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            {secondsToLive} {/*Отображаем секунды таймера из хука "useState".*/}
        </div>
    );
};