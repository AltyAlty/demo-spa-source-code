import React, {useState, useEffect} from 'react';
import styles from './Timer.module.css';
/*Импортируем тип "selectedGitHubUserDetailsType".*/
import {selectedGitHubUserDetailsType} from '../../UseEffectTheory';

type PropsType = {
    /*Детали профиля выбранного пользователя GitHub должны быть типа "selectedGitHubUserDetailsType" или null.*/
    selectedGitHubUserDetails: selectedGitHubUserDetailsType | null
    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа
    "selectedGitHubUserDetailsType" или null, и ничего не возвращает.*/
    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void
    /*ID выбранного пользователя GitHub должно быть числом.*/
    timerKey: number
};

/*"Timer" это функциональный компонент, который создан в виде стрелочной функции. "Timer" является компонентом, который
используется для отображения таймера для просмотра профиля пользователя GitHub.

Компонент "Timer" импортируется в файле "UserInfo.tsx".*/
export const Timer: React.FC<PropsType> = ({selectedGitHubUserDetails, setSelectedGitHubUserDetails, timerKey}) => {
    console.log('RENDERING THE TIMER');
    /*Изначальное время таймера.*/
    const initialSecondsToLive = 60;
    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый
    элемент из хука "useState()", этот элемент будет означать секунды в таймере (изначально берется из переменной
    "initialSecondsToLive"). Вторая переменная будет хранить функцию из хука "useState()", которая будет изменять первый
    элемент (то есть менять секунды в таймере).*/
    const [secondsToLive, setSecondsToLive] = useState(initialSecondsToLive);

    /*Используем хук "useEffect()" для реализации отсчета секунд в таймере.*/
    useEffect(
        () => {
            console.log('INITIALIZING THE TIMER');
            /*Здесь можно было использовать функцию "setTimeout()" и указать вторым параметром в этом хуке "useEffect()"
            секунды таймера, но мы решили так не делать, чтобы не перезапускать эту функцию "setTimeout()" каждую
            секунду.

            Поэтому мы использовали потом функцию "setInterval()" без указания зависимости в хуке "useEffect()". Но это
            приводило к тому, что хоть секунды и менялись в хуке "useState()", значение для отображения застревало на
            одном и том же месте после отсчета одной секунды.

            Так происходило из-за замыкания. Изначально таймер фиксировал у себя значение 60 секунд в локальном state.
            Дальше фиксировался хук "useEffect()", но не запускался. Потом происходила отрисовка 60 секунд. После этой
            отрисовки запускалась функция "setInterval()" из этого хука "useEffect()". Эта функция "setInterval()"
            обращалась к секундам таймера, которых у нее самой нет, поэтому она пыталась взять их через замыкание у
            родителя - у хука "useEffect()", но поскольку и у этого хука не было секунд таймера, то в итоге эти секунду
            брались через замыкание у функции "Timer()" (наш функциональный компонент). Брались они из первой отрисовки
            компонента "Timer", то есть из первого вызова функции "Timer()". После первой отрисовки компонента "Timer"
            функция "setInterval()" срабатывала и количество секунд становилось 59, то есть менялось значение в
            локальном state, что вызывало еще одну отрисовку компонента "Timer", то есть вызов функции "Timer()", и
            отрисовывалось уже 59 секунд.

            Но поскольку не было указано зависимостей в этом хуке "useEffect()", то при второй и последующих отрисовках
            компонента "Timer" регистрации этого хука "useEffect()" уже не происходило, поэтому запуска и
            пересинхронизации функции "setInterval()" с новой отрисовкой компонента "Timer" тоже не происходило. То есть
            далее когда в локальном state становилось 58 секунд, поскольку больше не происходило регистрации этого хука
            "useEffect()" и, соответственно, больше не пересинхронизировалась функция "setInterval()" c новыми
            отрисовками компонента "Timer", то этой функцией "setInterval()" каждый раз бралось значение 60 секунд из
            первой отрисовки компонента "Timer", то есть первого вызова функции "Timer()". Поэтому мы и видели только 59
            секунд в таймере.

            Чтобы этого избежать, поскольку наше новое значение секунд таймера зависит от старого значения секунд
            таймера из локального state, то вместо "() => {setSecondsToLive(secondsToLive - 1)}" в качестве параметра
            функции "setInterval()" мы используем "() => {setSecondsToLive((prev) => prev - 1)}", то есть мы используем
            функцию "(prev) => prev - 1", которая при помощи React рассчитывает именно актуальное значение секунд
            таймера. То есть использование такого написания функции позволяет нам брать актуальные значения из хука
            "useState()".*/
            const intervalID = setInterval(() => {setSecondsToLive((prev) => prev - 1)}, 1000);
            /*Хоть мы в хуке "useEffect()" ниже и "убиваем" компонент "UserInfo", что в итоге скрывает и компонент
            "Timer", сам таймер продолжает тикать и меняется значение в локальном state. Чтобы подчистить это нам нужна
            функция зачистки (cleanup-функция). Эта cleanup-функция будет вызываться, когда компонент будет "умирать"
            или каждый раз когда будет меняться второй параметр хука "useEffect()", чтобы подчистить мусор перед новым
            запуском.

            Такую функцию нужно поместить в return. В данном случае нам нужно отключить функцию "setInterval()", поэтому
            для этого есть специальная функция "clearInterval()", в которой нужно указать ID этой функции
            "setInterval()", для чего мы ее оборачиваем в отдельную переменную "intervalID" выше, в которую функция
            "setInterval()" отдает на выходе свой ID. Такие функции зачистки нужны еще, например, для функции
            "setTimeout()", для отписки от DOM-библиотек (например, yandex карты или google карты), для отписки от
            событий, для закрытия WebSocket-каналов и так далее.*/
            return () => { clearInterval(intervalID) };
        },
        /*Если это значение будет меняться, то будет срабатывать каждый раз функция из первого параметра. Если вторым
        параметром здесь ничего не указывать, то секундомер будет работать, но при переключении профилей таймер будет
        сбрасываться на изначальное значение, но первая секунда будет длиться короче, так как она будет сливаться с
        последней секундой предыдущего таймера.

        Чтобы этого избежать мы будем получать некий параметр извне и сделаем его зависимостью в этом хуке
        "useEffect()". В данном случае мы будем получать ID пользователя GitHub (можно на самом деле получать любые
        данные профиля пользователя, суть работы не поменяется), которого выбрали. То есть когда мы будем получать такой
        ID, соответственно, когда мы загружаем новый профиль и хотим, чтобы таймер полностью сбросился, этот хук
        "useEffect()" будет полностью перезапускать функцию из своего первого параметра при помощи нашей функции
        зачистки, что в итоге поможет нам избежать случаев "склеивания" первой секунды нового таймера и последней
        секунды старого таймера.*/
        [timerKey]
    );

    /*Используем хук "useEffect()", чтобы сбрасывать таймер при переключении профилей пользователей GitHub.*/
    useEffect(
        () => {
            console.log('RESETTING THE TIMER');
            /*Используем функцию "setSecondsToLive()" из хука "useState()", чтобы сбрасывать секунды таймера в
            изначальное состояние.*/
            setSecondsToLive(initialSecondsToLive);
        },
        /*Второй параметр это детали профиля выбранного пользователя GitHub. Если эти детали будут меняться, то будет
        срабатывать каждый раз функция из первого параметра.*/
        [selectedGitHubUserDetails]
    );

    /*Используем хук "useEffect()", чтобы отключать таймер и закрывать профиль пользователя GitHub, когда истекает сам
    таймер.*/
    useEffect(
        () => {
            console.log('TRYING TO TURN THE TIMER OFF');

            /*Когда время таймера истечет, мы сбрасываем данные профиля пользователя GitHub, тем самым отключая
            компонент "UserInfo", в котором также содержится и компонент "Timer".*/
            if (secondsToLive < 1) {
                setSelectedGitHubUserDetails(null);
                console.log('TURNING TIMER OFF');
            }
        },
        /*Второй параметр это секунды в таймере. Если это значение будет меняться, то будет срабатывать каждый раз
        функция из первого параметра.*/
        [secondsToLive]
    );

    return (
        <div className={styles.timerSeconds}>
            {/*Отображаем секунды таймера из хука "useState()".*/}
            {secondsToLive}
        </div>
    );
};