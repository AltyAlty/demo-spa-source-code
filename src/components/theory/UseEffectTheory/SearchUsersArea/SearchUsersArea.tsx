import React, {useState, useEffect} from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".

Классовый компонент позволяет реализовать локальный "state" (смотри "ProfileStatus") и методы
жизненного цикла ("componentDidMount" и т.д.), а функциональный компонент этого не может делать.
Такие возможности классового компонента были созданы благодаря тому, что "React" на основе класса
создает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может
хранить такие вещи как "state" и методы. Функция же просто вызывается и возвращает "JSX", постоянное
общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала
и удалилась. Для решения этой проблемы в функциональных компонентах были созданы "Hooks" (хуки).
"Hook" - это функция, которая может делать side effects.
"React" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и
этой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента
"React" запоминает эту информацию где-то на своей стороне, а не внутри объекта.
Хуки нельзя писать в условиях и циклах, так как это нарушает порядок хуков, который является важным.
Можно писать свои кастомные хуки.

Подключаем хук "useState", который возвращает массив с двуми элементами. Первый элемент - это значение,
которое хранится в "state". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя
первый элемент мы заставляем "React" перерисовывать функциональный компонент.
Хук "useState" работает асинхронно, то есть если мы изменяем какое-либо значение при помощи этого хука, то мы говорим,
чтобы "ReactJS" изменил это значение как только сможет, не обращая внимание на порядок соседних инструкций рядом с
кодом, где мы меняем какое-то значение из локального "state".
Нужно помнить, что если наш JSX в компоненте не зависит от хука "useState", то нежелательно хранить какие-то данные в
таком хуке "useState".
При вызове нескольких вторых элементов из нескольких хуков "useState" в асинхронных операциях (например, в запросах на
сервер), нужно обращать внимание на порядок этих вторых элементов из нескольких хуков "useState".

Подключаем хук "useEffect", который принимает функцию первым параметром и выполняет ее, когда произойдет
отрисовка компонента, то есть после каждого вызова "render". Вторым параметром этот хук принимает зависимости -
зависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то
этот хук сработает только один раз. Этот хук используется для side effects.
Хук "useEffect" позволяет нам синхронизировать какие-то вещи в программе между собой. Такая синхронизация нужна для
динамического изменения верстки с целью отображения ее актуального состояния пользователю. Синхронизация между двумя
сторонами может работать двунаправленно. Синхронизация происходит после отрисовки компонента, а не до.
В хуке "useEffect" на самом деле желательно избегать пустой зависимости "[]" во втором параметре.
Если не указать второй параметр в хуке "useEffect" вообще, то он будет срабатывать при каждой отрисовке компонента.
В первом параметре хука "useEffect" нельзя использовать "async/await".
*/

import axios from 'axios';
/*
Библиотека "axios" нужна для работы с запросами на сервер.
Запросы осуществляются на "endpoints", которые представляют из себя URL.
Здесь мы испольузем API гитхаба, чтобы получать данные о пользователях гитхаба.
У каждого API сервера есть базовый URL, в данном случае это "https://api.github.com/".
К базовому URL дописываются определенные элементы (например, "/users"), чтобы получить какую-то категорию данных.
В запросе "GET" мы не можем передавать какую-либо информацию, кроме URL.
В нашем случае мы получаем ответы в формате JSON.
Существует подход "API first": сначала создается API, а потом уже front-end и back-end.
В библиотеке "axios" любой запрос "GET", "POST" или "PUT" являются "generic" и возвращают промис, который можно уточнить
при помощи "TypeScript".
*/

import {SelectedGitHubUserType, GitHubSearchResult, selectedGitHubUserDetailsType} from '../UseEffectTheory';
/*Импортируем типы.*/

import styles from './SearchUsersArea.module.css'; /*Подключаем стили из CSS-модуля.*/


/*Создаем тип для "props". "Props" в этом компоненте должны обязательно содержать следующие поля с указанными типами.
Все это нужно для указания типа "props" в функциональном компоненте.*/
type PropsType = {
    setGitHubUsers: (gitHubUsers: SelectedGitHubUserType[]) => void /*Callback-функция для установки массива с
    пользователями GitHub, которая принимает массив с элементами типа "SelectedGitHubUserType", который мы импортировали
    сюда, и ничего не возвращает.*/
    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void
    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа
    "selectedGitHubUserDetailsType", который мы сюда импортировали, или "null", и ничего не возвращает.*/
    selectedGitHubUserDetails: selectedGitHubUserDetailsType | null /*Детали профиля выбранного пользователя GitHub
    должны быть типа "selectedGitHubUserDetailsType", который мы импортировали сюда, или "null".*/
    setIsRequestingGitHubUsers: (isRequestingGitHubUsers: boolean) => void /*Callback-функция для установки значения,
    которое показывает идет ли сейчас запрос пользователей GitHub или нет, которая принимает параметр булева типа и
    ничего не возвращает.*/
};


/*
"SearchUsersArea" это функциональный компонент, который создан в виде стрелочной функции.
При взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.
React вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется
из памяти.
Функциональный компонент можно создать еще и таким образом: function SearchUsersArea(props) {тело}.
Компонент это функция, которая возвращает JSX.
JSX совмещает в себе JS и HTML.
В JSX для указания класса в стилях нужно использовать "className" вместо "class".
В JSX скобки {} позволяют использовать JS-код внутри HTML-кода.
Каждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.
Теги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.
Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.
Если параметры не указаны, то им все равно передается пустой объект в качестве параметров.
Принято объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.
"SearchUsersArea" является компонентом, который используется для создания поля для ввода текста, по которому будет
осуществляться поиск пользователя GitHub.
Этот компонент подключается в компоненте "UseEffectTheory".
*/
export const SearchUsersArea: React.FC<PropsType> = ({
                                                         setGitHubUsers,
                                                         setSelectedGitHubUserDetails,
                                                         selectedGitHubUserDetails,
                                                         setIsRequestingGitHubUsers
                                                     }) => { /*При помощи деструктуризации "props" указываем какие
именно "props" мы получаем, чтобы не писать далее "props.setGitHubUsers" и так далее. Такое мы делаем только в
функциональных компонентах. Указали при помощи "React.FC<>", что "props" в этом функциональном компоненте имеют тип
"PropsType". Также указали, что экспортируем этот компонент.*/

    console.log('RENDERING SEARCH AREA');

    const initialSearchText = 'alty'; /*Изначальный текст для поиска.*/
    const resetSearchText = 'Enter something'; /*Текст для поиска после сброса.*/
    const resetSearchText2 = 'Enter somethin'; /*Текст для поиска после сброса.*/
    const initialTabName = 'React App'; /*Изначальное имя вкладки*/

    let [localSearchTerm, setLocalSearchTerm] = useState(initialSearchText); /*При помощи деструктуризирующего
    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент
    будет означать то, что введено в данным момент в строку поиска пользователей GitHub (изначально берется из
    переменной "initialSearchText") для осуществления FLUX-круговорота в этой строке поиска. Вторая переменная будет
    хранить функцию из хука "useState", которая будет изменять первый элемент (то есть указывать, что должно быть
    введено в строку поиска пользователей GitHub).*/

    let [gitHubSearchTerm, setGitHubSearchTerm] = useState(initialSearchText); /*При помощи деструктуризирующего
    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука "useState", этот элемент
    будет означать текст, по которому будет отправлен запрос поиска пользователей GitHub (изначально берется из
    переменной "initialSearchText"). Вторая переменная будет хранить функцию из хука "useState", которая будет изменять
    первый элемент (то есть указывать текст, по которому будет отправлен запрос поиска пользователей GitHub).*/

    useEffect(() => { /*Используем хук "useEffect", чтобы при каждом изменении текста, по которому будет отправлен
    запрос поиска пользователей GitHub, вызывать такой запрос.*/
            console.log('REQUESTING USERS');

            setIsRequestingGitHubUsers(true); /*Указываем, что идет запрос пользователей GitHub,
            чтобы в компоненте "SearchUsersAreaResults" отобразить компонент "Preloader" пока запрос не завершится.*/

            axios
                .get<GitHubSearchResult>(`https://api.github.com/search/users?q=${gitHubSearchTerm}`)
                .then(response => {
                    setGitHubUsers(response.data.items);
                    setIsRequestingGitHubUsers(false); /*Указываем, что запрос пользователей GitHub
                    больше не идет, чтобы в компоненте "SearchUsersAreaResults" отключить компонент "Preloader".*/
                }); /*Первый параметр это функция для запроса поиска пользователей GitHub.*/
        },
        [gitHubSearchTerm] /*Второй параметр это текст, по которому будет отправлен запрос поиска пользователей
        GitHub, из хука "useState". Если это значение будет меняться, то будет срабатывать каждый раз функция из первого
        параметра.*/
    );

    /*
    Здесь после return в компоненте начинается HTML разметка.
    Нужно помнить, что в этой разметке должен быть только один корневой элемент.
    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.
    */
    return (
        <div className={styles.searchUsersArea}> {/*Этот элемент "div" и есть наш корневой элемент.*/}
            <input className={styles.searchUsersAreaInput}
                   placeholder='Enter a GitHub username'
                   value={localSearchTerm} /*Это поле берет значение из "localSearchTerm" из хука "useState". Мы не
                   можем напрямую ввести в это поле текст, только через FLUX-круговорот.*/
                   onChange={(e) => {
                       setLocalSearchTerm(e.currentTarget.value)
                   }}/> {/*При изменении нами текста в поле будет вызываться "setLocalSearchTerm" из хука "useState",
                   чтобы осуществлять FLUX-круговорот текста в этом поле.*/}

            <button className={styles.searchUsersAreaButton}
                    onClick={() => {
                        setGitHubSearchTerm(localSearchTerm);
                        {/*При нажатии на эту кнопку при помощи
                        "setGitHubSearchTerm" из хука "useState" мы устанавливаем текст, по которому будет отправлен
                        запрос поиска пользователей GitHub. Будет подхватываться из "localSearchTerm" из хука
                        "useState".*/
                        }
                    }}>
                Find
            </button>

            <button className={styles.searchUsersAreaResetButton}
                    onClick={() => {
                        setGitHubSearchTerm(resetSearchText2); /*При нажатии на эту кнопку при помощи
                        "setGitHubSearchTerm" из хука "useState" мы устанавливаем текст, по которому будет отправлен
                        запрос поиска пользователей GitHub. Нужно для сброса текста, который указан в переменной
                        "resetSearchText2".*/
                        setLocalSearchTerm(resetSearchText); /*При нажатии на эту кнопку при помощи
                        "setLocalSearchTerm" из хука "useState" мы устанавливаем текст, который будет введен в поле
                        ввода текста, по которому в дальнейшем будет запрос поиска пользователей GitHub. Нужно для
                        сброса текста, который указан в переменной "resetSearchText".*/
                        if (selectedGitHubUserDetails !== null) {
                            setSelectedGitHubUserDetails(null);
                        }; /*При нажатии на эту кнопку при помощи "setSelectedGitHubUserDetails" из хука "useState" мы
                        сбрасываем детали профиля выбранного пользователя GitHub.*/
                        document.title = initialTabName; /*При нажатии на эту кнопку сбрасываем заголовок страницы.*/
                        setGitHubUsers([]); /*При нажатии на эту кнопку при помощи "setGitHubUsers" из хука
                        "useState" мы сбрасываем массив с пользователями GitHub, чтобы очистить список.*/
                    }}>
                Reset
            </button>
        </div>
    );
};