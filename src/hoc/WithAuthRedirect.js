/*
Это специальной созданный нами HOC для добавления редиректа в наш проект.
HOC (ХОК) - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
*/

import React from 'react';
/*
Подключаем сам "ReactJS", необходим везде, где мы что-то из него используем (например, JSX).
"WebPack" уже встроен в "ReactJS".
*/
import {connect} from 'react-redux';
/*
Библиотека "react-redux" является прослойкой между UI (react) и BLL (redux).
Это прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.
Библиотека "react-redux" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.
Метод "connect" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.
HOC (ХОК) - high order component (компонента высшего порядка).
HOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и
на выходе возвращает другой компонент.
HOC позволяет создавать однообразные контейнерные компоненты.
Метод "connect" используется для создания компонентов и контейнеров.
Метод "connect" знает о нашем "store" из "redux" и сам передает данные оттуда в указанный компонент.
Метод "connect" упрощает перекидывание "props".
Метод "connect" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть "Virtual DOM".
При помощи метода "connect" можно удобно создавать контейнерные компоненты.
У метода "connect" есть свои аналоги "getState", "subscribe", "callSubscriber", "dispatch".
Метод "connect" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных "state" (функция
"mapStateToProps") и "dispatch" (наши callbacks - "AC" или "TC", функция "mapDispatchToProps"), причем в первую функцию
метод "connect" закинет весь "state" из "store", а во вторую функцию закинет "store.dispatch.bind(store)", т.е. наши
callbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде
указанного компонента. При каждом изменении "state" вызывается функция "mapStateToProps", формируется новый объект
с данными из "state" и сравнивается со старым объектом с данными из "state" (их внутренности).
Если были изменения в нужной для компонента части "state", которая указана в функции "mapStateToProps",
то метод "connect" перерисовывает компонент. Именно поэтому в "reducers" мы создаем копии "state". Если создается копия
"state", то получается, что идет ссылка на другой объект. Исходя из этого "connect" считает, что были изменения.
Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,
AC или TC в контейнерной компоненте это ссылки на AC или TC из "reducers". Учитывая это, в метод "connect" можно сразу
указывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг
AC или TC, как это делается в функции "mapDispatchToProps". И тогда функцию "mapDispatchToProps" можно не писать.
"Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL.
*/
import {Redirect} from 'react-router-dom';
/*
Библиотека "react-router-dom" необходима для создания роутинга и маршрутов в приложении.
"Redirect" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется
атрибут "to".
Маршрут для пути редиректа уже должен быть создан.
*/


const mapStateToPropsForRedirect = (state) => ({ /*Здесь мы таким образом создали "props" необходимые для работы
редиректа.*/
    isAuth: state.auth.isAuth /*Свойство, которое указывает залогинен ли пользователь.*/
});

export const withAuthRedirect = (Component) => { /*Это и есть наш HOC, который в качестве параметра принимает
какой-либо компонент.*/
    class RedirectComponent extends React.Component { /*После получения компонента в качестве параметра, создается
    другой классовый компонент "RedirectComponent".*/
        render() { /*Свойственный для классовых компонентов метод "render".*/
            if (!this.props.isAuth) return <Redirect to={'/login/'}/> /*Внутри этого классового компонента
            "RedirectComponent" добавляем в компонент из параметров следующую логику: если пользователь не залогинен,
            то происходит редирект по пути "/login/", где находится форма для логинизации.*/

            return <Component {...this.props}/> /*А затем этот классовый компонент "RedirectComponent" возвращает
            компонент из параметров, снабдив его "props", используя деструктуризацию.*/
        }
    }

    let ConnectedAuthRedirectComponent = connect(mapStateToPropsForRedirect)(RedirectComponent); /*Далее в свою очередь
    классовый компонент "RedirectComponent" обворачивается при помощи метода "connect", чтобы получить необходимые
    "props" для проверки залогинен ли пользователь или нет. Метод "connect" вернет новый компонент
    "ConnectedAuthRedirectComponent".*/

    return ConnectedAuthRedirectComponent; /*И в конце концов HOC "withAuthRedirect" возвращает итоговый
    компонент "ConnectedAuthRedirectComponent".*/
}
