/*Импортируем компонент "Suspense" для реализации lazy loading, больше об этом в файле "WithSuspense.tsx". Также
импортируем тип "ComponentType" для типизации.*/
import React, {Suspense, ComponentType} from 'react';
/*Библиотека React Router DOM необходима для создания роутинга и маршрутов в приложении.

Импортируем компонент "Route" для создания маршрутов. В каждом компоненте "Route" указывается путь в атрибуте "path",
который будет прослушиваться. Также в каждом компоненте "Route" указывается в атрибуте "render" компонент, который
отрисовывается если активируется какой-то прослушиваемый путь. Чтобы маршруты компонентов "Route" работали их нужно всех
обернуть в корневой компонент "BrowserRouter".

Для перемещения по маршрутам в компонентах "Route" может использоваться компонент "NavLink". Хотя в этом компоненте мы
его не используем, но используем в некоторых других.

Функция "withRouter()" это HOC. HOC - это High Order Component (компонент высшего порядка). HOC - это функция, которая
принимает на входе один компонент, оборачивает его, чтобы передать компоненту какие-то данные, и на выходе возвращает
другой компонент. HOC позволяет создавать однообразные контейнерные компоненты.

Поскольку URL также является источником данных, то компоненту иногда могут понадобиться эти данные. Чтобы их получить,
можно воспользоваться HOC "withRouter()". HOC "withRouter()" принимает в качестве параметра компонент и передает ему
через props данные из URL, чтобы компонент знал где он находиться, то есть знал какой у него маршрут. Если подключить на
самом высоком уровне дерева компонентов этот HOC, например, в файле "App.tsx", то данные URL будут доступны в дочерних
компонентах.

При использовании функции "connect()" роутинг сбивается. Чтобы решить эту проблемы мы оборачиваем функцию "connect()"
при помощи HOC "withRouter()". Но сейчас вроде и без этого все работает.

Компонент "Redirect" позволяет осуществлять редирект. Для указания пути редиректа используется атрибут "to". Маршрут для
пути редиректа уже должен быть создан.

Компонент "Switch" - это аналог для реализации атрибута "exact" (смотри в коде ниже). Работает по принципу
"switch/case", то есть как только нашли компонент "Route" с подходящим путем, то его сразу и отрисовываем.

Компонент "HashRouter" используем только для сборки билда приложения для его последующего развертывания на GitHub.*/
import {Route, BrowserRouter, HashRouter, withRouter, Redirect, Switch} from 'react-router-dom';
/*Библиотека React Redux является прослойкой между UI (React) и BLL (Redux). Эта прослойка необходима потому, что UI
нежелательно общаться с BLL напрямую. Библиотека React Redux предоставляет продвинутые инструкции по созданию
контейнерных компонентов и контекста.

Функция "connect()" это HOC. Точнее она возвращает HOC, а этот HOC получает компонент и обрабатывает его. Функция
"connect()" используется для создания компонентов и контейнеров. Функция "connect()" знает о нашем store из Redux и сама
передает данные оттуда в указанный компонент. Функция "connect()" упрощает перекидывание props. Функция "connect()"
имеет улучшенную оптимизацию перерисовки, так как она перерисовывает только нужную часть Virtual DOM. При помощи функции
"connect()" можно удобно создавать контейнерные компоненты.

У функции "connect()" есть свои аналоги функций "getState()", "subscribe()", "callSubscriber()" и "dispatch()".

Функция "connect()" вызывается дважды. Первый раз она вызывается с параметрами в виде двух функций, которые она вызовет:
1. Данные state, в виде функции "mapStateToProps()".
2. Функция "dispatch()", в виде наших callback-функций - AC, TC и функция "mapDispatchToProps().
Причем функция "connect()" в первую функцию закинет весь state из store, а во вторую функцию закинет
"store.dispatch.bind(store)", то есть наши callback-функции. Затем функция "connect()" вернет другую функцию, тот самый
HOC, после чего вызовется этот HOC с параметрами в виде какого-то указанного компонента.

При каждом изменении state вызывается функция "mapStateToProps()", формируется новый объект с данными из state и
сравнивается со старым объектом с данными из state (их внутренностями). Если были изменения в нужной для компонента
части state, которая указана в функции "mapStateToProps()", то функция "connect()" перерисовывает компонент. Именно
поэтому в редьюсерах мы создаем копии state. Если создается копия state, то получается, что создается ссылка на другой
объект. Исходя из этого функция "connect()" считает, что произошли изменения.

Когда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например, AC
или TC в контейнерном компоненте это ссылки на AC или TC из редьюсеров. Учитывая это, в функции "connect()" можно сразу
указывать AC или TC, так как функция "connect()" создает контейнерный классовый компонент и сама может создавать
callback-функции вокруг AC или TC, как это делается в функции "mapDispatchToProps()". И тогда можно не писать функцию
"mapDispatchToProps()".

Компонент "Provider" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные
BLL и DAL. Компонент "Provider" позволяет указать компонент, в нашем случае это компонент "AppContainer", который будет
поставщиком данных BLL и DAL для всех его дочерних компонентов. Так же использование компонента "Provider" избавляет нас
от обязанности прокидывать указанные данные через все дерево компонентов.*/
import {connect, Provider} from 'react-redux';
/*Функция "compose()" из функционального программирования. Эта функция создает композицию обработчиков. Библиотека
Redux содержит свою реализацию функции "compose()". При помощи функции "compose()" можно объединять, например, несколько
оберток вокруг компонента и HOC-ов. Обертки и HOCs указываются снизу вверх. Функция "compose()" вызывается дважды и
работает схожим образом, как и функция "connect()" из библиотеки React Redux.*/
import {compose} from 'redux';
/*Импортируем наш store из Redux. Также Импортируем тип "AppStateType" оттуда.*/
import store, {AppStateType} from './redux/redux-store';
/*Импортируем TC "initializeApp()".*/
import {initializeApp} from './redux/app-reducer';
/*Импортируем CSS-стили из UI-фреймворка Ant Design.*/
import 'antd/dist/antd.css';
/*Импортируем из UI-фреймворка Ant Design компонент "Layout" для получения из него объектов компонентов "Content" и
"Footer", чтобы использовать их как теги для реализации основного содержания страницы и футера.*/
import {Layout} from 'antd';
/*Импортируем файл CSS.*/
import './App.css';
/*Импортируем компонент "Preloader".*/
import {Preloader} from './components/common/Preloader/Preloader';
/*Импортируем компонент "Header".*/
import {Header} from './components/Header/Header';
/*Импортируем компонент "Navbar".*/
import {Navbar} from './components/Navbar/Navbar';
/*Импортируем компонент "Users".*/
import {Users} from './components/Users/Users';
/*Импортируем компонент "Music".*/
import {Music} from './components/Music/Music';
/*Импортируем компонент "News".*/
import {News} from './components/News/News';
/*Импортируем компонент "Settings".*/
import {Settings} from './components/Settings/Settings';
/*Импортируем компонент "Friends".*/
import {Friends} from './components/Friends/Friends';
/*Импортируем компонент "Login".*/
import {Login} from './components/Login/Login';
/*Импортируем компонент "UseStateTheory".*/
import {UseStateTheory} from './components/theory/UseStateTheory/UseStateTheory';
/*Импортируем компонент "UseStateTheory".*/
import {UseEffectTheory} from './components/theory/UseEffectTheory/UseEffectTheory';
/*Импортируем компонент "UseStateTheory1".*/
import {UseEffectTheory1} from './components/theory/UseEffectTheory/UseEffectTheory1';
/*Импортируем HOC "withSuspense()" с целью реализации lazy loading для компонентов "ProfileContainer" и "ChatPage".*/
import {withSuspense} from './hoc/WithSuspense';
/*Здесь вместо стандартного импорта компонентов "DialogContainer", "ProfileContainer" и "ChatPage" в целях реализации
lazy loading, то есть чтобы они не попали в бандлы, мы используем функцию "React.lazy()". Ниже в роутах мы оборачиваем
эти компоненты в компонент "Suspense" или в наш HOC "withSuspense()" для реализации lazy loading. Также здесь нужно
помнить, что надо делать экспорт компонентов по DEFAULT при использовании функции "React.lazy()", иначе придется писать
дополнительный код.*/
const DialogsContainer = React.lazy(() => import('./components/Dialogs/DialogsContainer'));
const ProfileContainer = React.lazy(() => import('./components/Profile/ProfileContainer'));
const ChatPage = React.lazy(() => import('./pages/ChatPage/ChatPage'));

/*Создаем тип для функции "MapStateToProps()". Любой тип указывает, какие поля и какого-то типа должна содержать
какая-то сущность или какого типа она сама должны быть.*/
type MapStateToPropsType = {
    /*Свойство, которое показывает инициализировано ли приложение, должно быть булева типа.*/
    initialized: boolean
};

/*Создаем тип для функции "MapDispatchToPropsType()".*/
type MapDispatchToPropsType = {
    /*TC для инициализации приложения должен быть функцией, которая ничего не принимает и ничего не возвращает.*/
    initializeApp: () => void
};

/*Создаем отдельный тип для объекта "location" из HOC "withRouter()" из библиотеки React Router DOM. Эти данные мы
передаем в компонент "Navbar" ниже.*/
type PathnameType = {
    location: {
        pathname: string
    }
};

/*Создаем общий тип для всех props путем комбинации трех созданных выше типов. Все это нужно для указания типа props в
классовом компоненте "App".*/
type PropsType = MapStateToPropsType & MapDispatchToPropsType & PathnameType;

/*Оборачиваем вызов HOC "withSuspense(ProfileContainer)" в отдельную переменную "ProfileContainerWithSuspense", чтобы
это можно было использовать как тег ниже в маршруте "/profile/:userID?". Мы это делаем после типизации HOC
"withSuspense()", нам из-за этого пришлось добавить в этот маршрут "() => ", поскольку HOC "withSuspense()" возвращает
новый компонент, но не отрисовывает его. Поэтому для отрисовки нам теперь там нужен тег (в маршруте "/dialogs/" мы уже
использовали тег так-то).*/
const ProfileContainerWithSuspense = withSuspense(ProfileContainer);
/*Оборачиваем вызов HOC "withSuspense(ChatPage)" в отдельную переменную "ChatPageWithSuspense", чтобы это можно было
использовать как тег ниже в маршруте "/chat/". Мы это делаем после типизации HOC "withSuspense()", нам из-за этого
пришлось добавить в этот маршрут "() => ", поскольку HOC "withSuspense()" возвращает новый компонент, но не отрисовывает
его. Поэтому для отрисовки нам теперь там нужен тег (в маршруте "/dialogs/" мы уже использовали тег так-то).*/
const ChatPageWithSuspense = withSuspense(ChatPage);

/*"App" это классовый компонент, который создан в виде класса. "App" является главным корневым компонентом, к которому в
дереве компонентов подключаются остальные компоненты древовидным способом.

Внутри компонента "App" используются следующие компоненты:
1. "Preloader" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,
пока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.
2. "Header" - компонент, который отрисовывает хэдер нашего сайта, содержащий логотип сайта и отдельный блок,
отображающий ссылку на форму логина или имя залогиненного пользователя с кнопкой логаута. Импортирован.
3. "Navbar" - компонент, который отрисовывает меню навигации нашего сайта. Импортирован.
4. "Users" - компонент, который отображает страницу с постраничным выводом пользователей. Импортирован.
5. "Music" - компонент, который отображает музыку пользователя. Импортирован.
6. "News" - компонент, который отображает новости пользователя. Импортирован.
7. "Settings" - компонент, который отображает настройки сайта. Импортирован.
8. "Friends" - компонент, который отображает друзей пользователя. Импортирован.
9. "Login" - компонент, который представляет собой финальную страницу с формой логинизации. Импортирован.
10. "DialogsContainer" - контейнерный компонент для компонента "Dialogs". Импортирован.
11. "ProfileContainer" - контейнерный компонент для компонента "Profile". Импортирован.
12. "ChatPage" - компонент, который собирает компоненты для реализации чата в нашем приложении. Импортирован.
13. "UseStateTheory" - компонент, который используется для рассмотрения работы хука "useState()" из React. Импортирован.
14. "UseEffectTheory" - компонент, который используется для рассмотрения работы хука "useEffect()" из React. Аналог
компонента "UseEffectTheory1". Импортирован.
15. "UseEffectTheory1" - компонент, который используется для рассмотрения работы хука "useEffect()" из React.Аналог
компонента "UseEffectTheory". Импортирован.

Этот компонент оборачивается в этом же файле компонентом "AppContainer", который в свою очередь оборачивается
компонентом "AppMain". Последний экспортируется по default для импортирования в файле "index.js".

Классы нужны для того, чтобы создавать однотипные объекты на основе этих классов, благодаря чему можно реализовывать
концепции ООП. React определяет классовый компонент и на его основе создает экземпляр класса, и далее уже
взаимодействует с этим экземпляром класса (использует его свойства и методы). Этот объект хранится постоянно в памяти и
React с ним постоянно взаимодействует. Например, у него можно постоянно запрашивать JSX. При переходе по разным
маршрутам компонентов "Route" экземпляры классовых компонентов удаляются из памяти.

Классовые компоненты могут содержать side effects. Для этого используются методы жизненного цикла.

В React при создании класса мы наследуем и расширяем некий базовый класс "React.Component" при помощи ключевого слова
"extends".

Каждый компонент это новый тег в React, и эти теги используются для вызова этих компонентов. Теги компонентов можно
вкладывать друг в друга, тем самым образуя дерево компонентов. Каждый компонент желательно помещать в отдельный файл.
Каждый компонент всегда вызывается с объектом, внутри которого есть какие-то параметры. Если параметры не указаны, то им
все равно передается пустой объект в качестве параметров. Принято такой объект с параметрами именовать как "props".
Вызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.

Компонент это функция, которая возвращает JSX. JSX совмещает в себе JS и HTML. В JSX для указания класса в стилях нужно
использовать "className" вместо "class". В JSX скобки {} позволяют использовать JS-код внутри HTML-кода. У классового
компонента всегда есть метод "render()", который возвращает JSX.

Указываем, что props в этом классовом компоненте имеют тип "PropsType". Еще здесь можно указать тип state, но мы не
делаем этого.*/
class App extends React.Component<PropsType/*, StateType*/> {
    /*Далее идет код, который отлавливает отклоненные промисы. "promiseRejectionEvent" - это перехватчик событий.
    Желательно вместо функции "alert()" сделать красивый вывод ошибки.

    Внизу в методе жизненного цикла классового компонента "componentDidMount()" совместно с методом жизненного цикла
    классового компонента "componentWillUnmount()" есть еще одна реализация перехвата отклоненных промисов. В данный
    момент мы не используем ни один из этих способов, так как используем для перехвата ошибок конструкцию try/catch в
    TC "updateUserStatus()" в файле "profile-reducer.ts", что будет мешать работать прослушиванию событий (хотя возможно
    первый способ будет работать).*/
    // catchAllUnhandledErrors = (promiseRejectionEvent: promiseRejectionEvent) => { alert('some error occurred') };

    /*"componentDidMount()" - это метод жизненного цикла классового компонента. Он вызывается в момент первой отрисовки
    (монтирования) компонента.*/
    componentDidMount() {
        /*При монтировании компонента вызывается TC "initializeApp()" для инициализации приложения. Поскольку это
        происходит в компоненте "App", который является точкой входа (то есть мы всегда видим его), то это будет
        работать и во всем приложении.*/
        this.props.initializeApp();

        /*Еще одна реализация перехвата отклоненных промисов, продолжение ниже в методе жизненного цикла классового
        компонента "componentWillUnmount()". Вызов метода "window.addEventListener()" - это side effects, где мы
        подписываемся на прослушивание событий типа "unhandledrejection". Когда происходит такое событие, то вызывается
        метод "this.catchAllUnhandledErrors()".*/
        /*window.addEventListener("unhandledrejection", this.catchAllUnhandledErrors);*/
    };

    /*"componentWillUnmount()" - это метод жизненного цикла классового компонента. Он вызывается в момент, когда
    компонент перестает быть отрисованным. Здесь при демонтировании компонента мы отписываемся от прослушивания событий,
    указанного в методе жизненного цикла классового компонента "componentDidMount()".*/

    // componentWillUnmount() { window.removeEventListener("unhandledrejection", this.catchAllUnhandledErrors) };

    render() {
        /*Пока мы не убедимся, что приложение инициализировано, будем показывать компонент "Preloader", тем самым
        избегая мигания сайта из-за редиректов.*/
        if (!this.props.initialized) return <Preloader/>;
        /*При помощи деструктуризации берем компоненты "Content" и "Footer" из компонента "Layout" из UI-фреймворка Ant
        Design, чтобы использовать их как теги внутри для реализации основного содержания страницы и футера.*/
        const {Content, Footer} = Layout;

        /*Здесь после return в компоненте начинается JSX. Нужно помнить, что в этом JSX должен быть только один корневой
        элемент. Все возвращаемое помещено в круглые скобки, так как то, что возвращается return указано с новой
        строки.*/
        return (
            /*Этот компонент "Layout" и есть наш корневой элемент. Компонент "Layout" - это макет, то есть это самая
            внешняя структура проекта, обычно состоящая из навигации, футера, сайдбара, уведомлений и содержания.*/
            <Layout>
                {/*Отрисовываем компонент "Header", указывая его тег в JSX.*/}
                <Header/>

                {/*Компонент "Content" - это элемент для включения в него содержания страницы. В данном случае мы
                включаем все содержимое страницы в этот элемент.*/}
                <Content className='main-content'>
                    <Layout>
                        {/*Отрисовываем компонент "Navbar". Передаем в этот компонент информацию о пути, на котором
                        сейчас находимся.*/}
                        <Navbar location={this.props.location}/>

                        {/*Этот компонент "Content" содержит основной контент нашего приложения.*/}
                        <Content className='actual-content'>
                            <Switch>
                                {/*Создаем маршрут для пути '/'. Атрибут "exact" говорит о том, что путь должен
                                совпадать точь-в-точь, то есть если, например, будет какой-то подпуть, то такой путь не
                                подойдет.

                                Атрибут "render" содержит анонимную функцию из библиотеки React Router Dom, которую
                                вызовет компонент "Route" при совпадении пути. Эта функция позволяет передавать
                                параметры. В данном случае произойдет редирект на путь '/profile'.*/}
                                <Route exact path='/' render={() => <Redirect to='/profile'/>}/>

                                {/*Это еще одна версия вышеуказанного компонента "Route" при помощи компонента
                                "Redirect". Оба варианта рабочие, если они обернуты в компонент <Switch>.*/}
                                {/*<Route exact path='/'>*/}
                                {/*    <Redirect to='/profile'/>*/}
                                {/*</Route>*/}

                                {/*Создаем маршрут для пути '/dialogs/'.*/}
                                <Route path='/dialogs/'
                                       render={() => <Suspense fallback={<Preloader/>}><DialogsContainer/></Suspense>}/>
                                {/*Здесь мы используем компонент "Suspense", чтобы реализовать lazy loading без нашего
                                HOC "withSuspense()". Также здесь указываем, что пока будет идти загрузка компонента
                                будет показываться компонент-заглушка "Preloader".*/}

                                {/*Создаем маршрут для пути '/profile/:userID?'. ":userID" означает, что у пути может
                                быть какое-то дополнение по типу ID пользователя, что не является параметром запроса.
                                "?" в конце означает, что это дополнение является опциональным, если это не указать, то
                                просто переход в "/profile" не отрисует компонент.

                                Здесь мы используем компонент c HOC-ом "withSuspense()" для реализации lazy loading.*/}
                                <Route path='/profile/:userID?' render={() => <ProfileContainerWithSuspense/>}/>

                                {/*Далее представлен еще один способ реализации lazy loading для компонентов
                                "DialogsContainer" и "ProfileContainer" без использования нашего HOC "withSuspense().
                                Здесь мы сразу несколько компонентов "Route" оборачиваем в компонент "Suspense". В
                                данный момент этот вариант не используется в нашем приложении.*/}
                                {/*<Suspense fallback={<Preloader/>}>*/}
                                {/*    <Route path='/dialogs/'*/}
                                {/*        render={() => <DialogsContainer/>}/>*/}
                                {/*    <Route path='/profile/:userID?'*/}
                                {/*        render={() => <ProfileContainer/>}/>*/}
                                {/*</Suspense>*/}

                                {/*Создаем маршрут для пути '/users/'.*/}
                                <Route path='/users/' render={() => <Users/>}/>

                                {/*Создаем маршрут для пути '/news/'.*/}
                                <Route path='/news/' render={() => <News/>}/>

                                {/*Создаем маршрут для пути '/music/'.*/}
                                <Route path='/music/' render={() => <Music/>}/>

                                {/*Создаем маршрут для пути '/settings/'.*/}
                                <Route path='/settings/' render={() => <Settings/>}/>

                                {/*Создаем маршрут для пути '/friends/'.*/}
                                <Route path='/friends/' render={() => <Friends/>}/>

                                {/*Создаем маршрут для пути '/login/'. Если нужно, чтобы в компонент "Login" можно было
                                попасть только по одному адресу, то нужно использовать атрибуты "exact path='/login/'".
                                Тогда, например, если перейти по пути '/login/facebook', то мы не попадем в этот
                                компонент. Аналогичный результат можно получить, если обернуть все компоненты "Route" в
                                компонент "Switch".*/}
                                <Route path='/login/' render={() => <Login/>}/>

                                {/*Создаем маршрут для пути '/usestatetheory/'.*/}
                                <Route path='/usestatetheory/' render={() => <UseStateTheory/>}/>

                                {/*Создаем маршрут для пути '/usestatetheory/'.*/}
                                <Route path='/useeffecttheory/' render={() => <UseEffectTheory/>}/>

                                {/*Создаем маршрут для пути '/chat/'.*/}
                                <Route path='/chat/' render={() => <ChatPageWithSuspense/>}/>

                                {/*Создаем маршрут для пути '*'. Этот путь обозначает неверный URL, то есть любой путь
                                отличающийся от путей указанных нами в маршрутах. Нужно для отображения "404" в таких
                                случаях. Чтобы это работало нужно обернуть все компоненты "Route" в компонент
                                "Switch".*/}
                                <Route path='*' render={() => <div>404 NOT FOUND</div>}/>
                            </Switch>
                        </Content>
                    </Layout>
                </Content>

                {/*Отрисовываем футер при помощи элемента "Footer".*/}
                <Footer className='main-footer'>It's 2021 and there is a footer here</Footer>
            </Layout>
        );
    }
};

/*При помощи функции "mapStateToProps()" указываются данные из state, которые необходимо передать в компонент "App". Эта
функция возвращает указанные данные в виде объекта. На входе функция "mapStateToProps()" принимает state с типом
"AppStateType", который мы создали и импортировали сюда, а на выходе выдает данные с типом "MapStateToPropsType".*/
const mapStateToProps = (state: AppStateType): MapStateToPropsType => ({
    /*Свойство, которое показывает инициализировано ли приложение.*/
    initialized: state.app.initialized
});

/*Поскольку мы не можем оборачивать компонент "App" в файле "index.js", мы это делаем здесь. Создаем внутри этого файла
контейнерный компонент "AppContainer", который оборачивает наш компонент "App" при помощи функции "compose()". При
помощи функции "compose()" объединяем HOC "withRouter()" и функцию "connect()", возвращая контейнерный компонент
"AppContainer".

Здесь мы уточняем тип только одним параметром, так как согласно файлу декларации функции "compose()" (Ctrl+click в
WebStorm, раздел "rest"), нам нужно уточнить только такой компонент, свойства props которого не будут переданы в этот
компонент функциями, переданными внутрь функции "compose()", то есть HOC-ом "withRouter()" и функцией "connect()", а это
никакие свойства, так как мы не передаем извне ничего в компонент "AppContainer" снизу, когда оборачиваем компонент
"AppContainer" компонентом "AppMain".*/
const AppContainer = compose<ComponentType>(
    /*При помощи HOC "withRouter()" передаем в этот контейнерный компонент данные из URL.*/
    withRouter,
    /*При помощи функции "connect()" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL
    компоненту "App".*/
    connect(mapStateToProps, {initializeApp})
)(App);

/*Далее мы оборачиваем созданный выше контейнерный компонент "AppContainer" в компоненты "Provider" и "BrowserRouter".
Получившийся итоговый компонент "AppMain" экспортируется, чтобы использоваться в файле "index.js". При помощи
компонентов "AppContainer" и "AppMain" мы избавились от оберток вокруг компонента "App" в файле "index.js".

Также указываем, что компонент "AppMain" имеет тип "React.FC", без уточнения типов props, так как ничего внутрь не
передаем.*/
const AppMain: React.FC = () => {
    return (
        /*Оборачиваем компонент "AppContainer" в компонент "BrowserRouter", чтобы работали маршруты компонентов "Route"
        в компоненте "App". Для развертывания нашего приложения на GitHub Pages нужно заменить компонент "BrowserRouter"
        на компонент "HashRouter".*/
        <BrowserRouter>
            {/*Оборачиваем компонент "AppContainer" в компонент "Provider", чтобы указать, что этот компонент будет
            поставщиком данных BLL и DAL для дочерних компонентов, то есть для создания контекста, из которого
            контейнерные компоненты смогут брать указанные данные. Также в компоненте "Provider" указываем наш store.*/}
            <Provider store={store}>
                <AppContainer/>
            </Provider>
        </BrowserRouter>
    )
};

/*Экспортируем компонент "AppMain" по default и будем его использовать в нашем проекте под именем "AppMain". Ключевое
слово export необходима для импорта чего-то в других файлах.*/
export default AppMain;