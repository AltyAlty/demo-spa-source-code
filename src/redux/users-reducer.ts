/*Импортируем вспомогательную функцию, которая содержит общую логику для "FOLLOW" и "UNFOLLOW" в редьюсере.*/
import {updateObjectInArray} from '../utils/helpers/object-helpers';
/*Импортируем блок запросов, связанных со страницей с постраничным выводом пользователей.*/
import {usersAPI} from '../api/users-api';
/*Импортируем списки кодов ответов от сервера.*/
import {ResponseWithDataType, ResultCodeEnum} from '../api/api';
/*Импортируем тип "UserType".*/
import {UserType} from '../types/types';
/*Импортируем типы "InferActionsTypes", "BaseThunkType" и "BaseDispatchType".*/
import {InferActionsTypes, BaseThunkType, BaseDispatchType} from './redux-store';

export type InitialUsersStateType = typeof initialState;

/*Создаем отдельный тип для данных из state, которые отвечают за фильтрацию пользователей в постраничном выводе.*/
export type UsersFilterType = typeof initialState.filter;

let initialState = {
    /*Свойство, которое будет хранить объекты с информацией о пользователях для постраничного вывода, полученные с
    сервера. Указываем, что этот массив объектов имеет тип массива элементов с типом "UserType".*/
    users: [] as Array<UserType>,
    /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводиться на одной
    странице в постраничном выводе пользователей.*/
    pageSize: 30,
    /*Свойство, которое хранит значение, обозначающее общее количество пользователей. Получается с сервера.*/
    totalUsersCount: 0,
    /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в постраничном выводе
    пользователей.*/
    currentPage: 1,
    /*Специальное свойство, обозначающее находится ли в процессе запрос на сервер на получение данных по пользователям
    для постраничного вывода. Если в процессе, то будет отрисовываться компонент-заглушка "Preloader".*/
    isFetching: false,
    /*Специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то определенный момент
    находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга
    от пользователя. Указываем, что это свойство имеет тип массива элементов с типом числа.*/
    WhoIsInFollowingProgress: [] as Array<number>,
    /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может отображаться
    в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное количество, а
    имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими
    порциями страниц.*/
    portionSize: 20,
    /*Свойство, содержащее объект, внутри которого указываются фильтры для выборки пользователей в постраничном выводе.
    Это свойство будет использоваться в форме, которая была создана при помощи библиотеки Formik, а для этой библиотеки
    не обязательно хранить значения формы в store из библиотеки Redux. Но мы это делаем, так как эти фильтры будут
    применяться как параметры адресной строки, то есть будут являться данными BLL.*/
    filter: {
        /*Свойство, содержащее значение для фильтра в виде строкового значения, которое будет получать сервер и искать
        наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких пользователей.*/
        term: '',
        /*Свойство, содержащее значение для фильтра булева типа. Если указать в нем true, то сервер выберет только тех
        пользователей, которых мы фолловим, если указать false - только тех, кого мы не фолловим, если указать null или
        вообще не указывать, то выберет всех пользователей.*/
        friend: null as null | boolean
    }
};

/*Создаем редьюсер, отвечающий за страницу постраничного вывода пользователей.*/
export const usersReducer = (state = initialState, action: ActionsType): InitialUsersStateType => {
    switch (action.type) {
        /*Меняем флаг у пользователя, чтобы указать, что мы его теперь фолловим.*/
        case 'demo-spa/users-reducer/FOLLOW': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Вызываем вспомогательную функцию "updateObjectInArray()" и передаем ей:
                1. "state.users" - информация о пользователях для постраничного вывода из state.
                2. "action.userID" - ID пользователя для фолловинга из action-объекта.
                3. 'id' - имя свойства в объектах, по которому идет проверка сравнением в функции
                "updateObjectInArray()".
                4. "{followed: true}" - объект со свойствами и их значениями, который нужно подменить на место старого
                в найденном объекте.

                В результате получаем новый измененным массив объектов с информацией о пользователях для постраничного
                вывода, в котором у одного из пользователей свойство "followed" станет true, что будет означать, что
                мы его теперь фолловим.*/
                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>
                (state.users, action.userID, 'id', {followed: true})
            };
        }

        /*Меняем флаг у пользователя, чтобы указать, что мы больше его не фолловим.*/
        case 'demo-spa/users-reducer/UNFOLLOW': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Вызываем вспомогательную функцию "updateObjectInArray()" и передаем ей:
                1. "state.users" - информация о пользователях для постраничного вывода из state.
                2. "action.userID" - ID пользователя для фолловинга из action-объекта.
                3. 'id' - имя свойства в объектах, по которому идет проверка сравнением в функции
                "updateObjectInArray()".
                4. "{followed: false}" - объект со свойствами и их значениями, который нужно подменить на место старого
                в найденном объекте.

                В результате получаем новый измененным массив объектов с информацией о пользователях для постраничного
                вывода, в котором у одного из пользователей свойство "followed" станет false, что будет означать, что
                мы его больше не фолловим.*/
                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>
                (state.users, action.userID, 'id', {followed: false})
            };
        }

        /*Добавляем данные о пользователях "users" в state, полученные с сервера.*/
        case 'demo-spa/users-reducer/SET-USERS': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Добавляем данные о пользователях "users" в state. Здесь мы не добавляем к существующим данным новые.
                Мы затираем старые данные, добавляя новые. Здесь мы не делаем глубокую копию, так как работаем с
                примитивом.*/
                users: action.users
            };
        }

        /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей в state.*/
        case 'demo-spa/users-reducer/SET-CURRENT-PAGE': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей. Здесь мы не
                делаем глубокую копию, так как работаем с примитивом.*/
                currentPage: action.currentPage,
            };
        }

        /*Устанавливаем общее количество пользователей в state.*/
        case 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Устанавливаем общее количество пользователей. Здесь мы не делаем глубокую копию, так как работаем с
                примитивом.*/
                totalUsersCount: action.count
            };
        }

        /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного
        вывода. Если в процессе, то будет отрисовываться компонент-заглушка "Preloader".*/
        case 'demo-spa/users-reducer/TOGGLE-IS-FETCHING': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для
                постраничного вывода. Здесь мы не делаем глубокую копию, так как работаем с примитивом.*/
                isFetching: action.isFetching
            };
        }

        /*Оперируем массивом "WhoIsInFollowingProgress" для указания находятся ли или нет какие-либо пользователи в
        процессе анфолловинга/фолловинга.*/
        case 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Если свойство "isFollowingInProgress" является true, то делаем глубокую копию и помещаем ID
                пользователя, который находится в процессе анфолловинга/фолловинга в массив "WhoIsInFollowingProgress".
                Иначе если свойство "isFollowingInProgress" является false, то делаем глубокую копию и удаляем ID этого
                пользователя из массива "WhoIsInFollowingProgress" при помощи метода "filter()", который создает новый
                массив (тем самым мы делаем копию), в который войдут только те элементы, которые не равны ID указанного
                пользователя.*/
                WhoIsInFollowingProgress: action.isFollowingInProgress
                    ? [...state.WhoIsInFollowingProgress, action.userID]
                    : state.WhoIsInFollowingProgress.filter(id => id !== action.userID)
            };
        }

        /*Устанавливаем данные по фильтрам для отображения пользователей в постраничном выводе пользователей в state.
        Здесь благодаря деструктуризации мы сможем передать нужные значения свойств из "payload" в нужные свойства state
        при совпадении имен свойств.*/
        case 'demo-spa/users-reducer/SET-FILTER': {
            return {
                /*Делаем поверхностную копию state.*/
                ...state,
                /*Action-объект будет иметь объект "payload", который содержит объект "filter" со свойствами "term" и
                "friend". Делаем глубокую копию, чтобы установить эти данные в state, деструктуризируя этот объект
                "payload".*/
                filter: action.payload
            };
        }

        default: {
            return state;
        }
    }
};

type ActionsType = InferActionsTypes<typeof usersAC>;

export const usersAC = {
    /*AC для указания того, что мы зафолловили пользователя. На входе получает "userID", которое должно быть числом.*/
    followSuccess: (userID: number) => ({
        type: 'demo-spa/users-reducer/FOLLOW',
        /*ID пользователя, которого мы фолловим.*/
        userID
    } as const),

    /*AC для указания того, что мы заанфолловили пользователя. На входе получает "userID", которое должно быть числом.*/
    unfollowSuccess: (userID: number) => ({
        type: 'demo-spa/users-reducer/UNFOLLOW',
        /*ID пользователя, которого мы анфолловим.*/
        userID
    } as const),

    /*AC для установки данных пользователей "users" в state, которые получены с сервера. На входе получает "users",
    которое должно быть массивом с объектами типа "UserType".*/
    setUsers: (users: Array<UserType>) => ({
        type: 'demo-spa/users-reducer/SET-USERS',
        /*Данные по пользователям для постраничного вывода пользователей, полученные с сервера.*/
        users
    } as const),

    /*AC для установки значения текущей выбранной страницы в постраничном выводе пользователей в state. На входе
    получает "currentPage", которое должно быть числом.*/
    setCurrentPage: (currentPage: number) => ({
        type: 'demo-spa/users-reducer/SET-CURRENT-PAGE',
        /*Номер выбранной текущей страницы в постраничном выводе пользователей.*/
        currentPage
    } as const),

    /*AC для установки общего количество пользователей в state. На входе получает "totalUsersCount", которое должно быть
    числом.*/
    setTotalUsersCount: (totalUsersCount: number) => ({
        type: 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT',
        /*Значение обозначающее общее количество пользователей.*/
        count: totalUsersCount
    } as const),

    /*AC для указания находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного
    вывода. Если в процессе, то будет отрисовываться компонент-заглушка "Preloader". На входе получает "isFetching",
    которое должно быть булева типа.*/
    toggleIsFetching: (isFetching: boolean) => ({
        type: 'demo-spa/users-reducer/TOGGLE-IS-FETCHING',
        /*Специальное свойство, обозначающее находится ли в процессе запрос на сервер на получение данных по
        пользователям для постраничного вывода.*/
        isFetching
    } as const),

    /*AC для указания находится ли в процессе анфолловинга/фолловинга какой-либо пользователь. Если в процессе, то
    кнопка для анфолловинга/фолловинга будет отключена. На входе получает "isFollowingInProgress", которое должно быть
    булева типа. Также на входе получает "userID", которое должно быть числом.*/
    toggleIsFollowingInProgress: (isFollowingInProgress: boolean, userID: number) => ({
        type: 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS',
        /*Специальное свойство, указывающее находится ли какой-либо пользователь в процессе анфолловинга/фолловинга.*/
        isFollowingInProgress,
        /*Специальное свойство, указывающее ID пользователя по которому идет проверка находится ли он в процессе
        анфолловинга/фолловинга.*/
        userID
    } as const),

    /*AC для установки фильтров для отображения пользователей в постраничном выводе пользователей в state. На входе
    получает "filter", которое должно быть типа "UsersFilterType".*/
    setFilter: (filter: UsersFilterType) => ({
        type: 'demo-spa/users-reducer/SET-FILTER',
        /*Объект с данными по фильтрам для отображения пользователей в постраничном выводе пользователей. Далее мы его
        деструктуризируем в редьюсере "usersReducer()".*/
        payload: filter
    } as const)
};

/*Создаем тип для dispatch-функции, передается в thunks и TC.*/
type DispatchType = BaseDispatchType<ActionsType>;
/*Создаем тип для thunks.*/
type ThunkType = BaseThunkType<ActionsType>;

/*Это TC для запроса и установки данных по пользователям в постраничном выводе.*/
export const requestUsers = (
    /*Номер текущей выбранной страницы в постраничном выводе пользователей, который должен быть числом.*/
    currentPage: number,
    /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводиться на одной
    странице в постраничном выводе пользователей. Это свойство должно быть числом.*/
    pageSize: number,
    /*Свойство, хранящее данные по фильтрам для отображения пользователей в постраничном выводе пользователей, которое
    должны быть типа "UsersFilterType".*/
    filter: UsersFilterType
): ThunkType => async (dispatch) => {
    /*Включаем компонент-заглушку "Preloader" перед началом запроса на сервер.*/
    dispatch(usersAC.toggleIsFetching(true));
    /*При помощи AC "setFilter()" устанавливаем данные по фильтрам для отображения пользователей в постраничном выводе
    пользователей в state.*/
    dispatch(usersAC.setFilter(filter));
    /*Делаем запрос на сервер для получения данных по пользователям для постраничного вывода и ждем ответа от сервера.*/
    const response = await usersAPI.getUsers(currentPage, pageSize, filter.term, filter.friend);
    /*После получения ответа от сервера, отключаем компонент-заглушку "Preloader".*/
    dispatch(usersAC.toggleIsFetching(false));
    /*При помощи AC "setUsers()" устанавливаем данные по пользователям для постраничного вывода в state.*/
    dispatch(usersAC.setUsers(response.items));
    /*Устанавливаем общее количество пользователей в state.*/
    dispatch(usersAC.setTotalUsersCount(response.totalCount));
};

/*Это вспомогательный TC для осуществления анфолловинга/фолловинга пользователей "_followUnfollowFlow()". Он вызывается
внутри TC "unfollow()" или "follow()". Для своей работы он принимает следующие параметры:
метод "dispatch" (обязателен для "thunk", "store" из "redux" его сам закинет),
"ID" пользователя для анфолловинга/фолловинга,
запрос на сервер для анфолловинга/фолловинга,
AC для анфолловинга/фолловинга.
Эти параметры он получает от TC "unfollow()" или "follow()".*/
const _followUnfollowFlow = async (
    /*Dispatch-функция (обязательна для thunk, store из Redux его сам закинет), которая должна быть типа
    "DispatchType".*/
    dispatch: DispatchType,
    /*ID пользователя для анфолловинга/фолловинга, которое должно быть числом.*/
    id: number,
    /*На входе принимает метод API являющийся функцией, на входе принимающей числовой параметр, а на выходе выдающей
    промис, который резольвится данными типа "ResponseWithDataType". Такая типизация сделана на основе запросов
    "follow()" и "unfollow()" в файле "users-api.ts".*/
    apiMethod: (id: number) => Promise<ResponseWithDataType>,
    /*AC, который должен быть функцией, на входе принимающей числовой параметр, а на выходе ранее возвращающей
    action-объекты либо с типом "FollowSuccessActionType", либо с типом "UnfollowSuccessActionType", оба эти типа
    были созданы нами, но затем были удалены, поэтому сейчас эти action-объекты временно должны быть общего типа для
    всех action-объектов - "ActionsType".*/
    actionCreator: (id: number) => ActionsType
) => {
    /*Указываем, что находимся в процессе попытки зафолловить/заанфолловить какого-то пользователя.*/
    dispatch(usersAC.toggleIsFollowingInProgress(true, id));
    /*Делаем запрос на сервер на анфолловинг/фолловинг и ждем ответа от сервера.*/
    const response = await apiMethod(id);
    /*Если в ответе от сервера в свойстве "resultCode" указано "0", то есть операция прошла успешно, то диспатчим AC на
    анфолловинг/фолловинг, передав в этот AC ID пользователя, которого анфолловим/фолловим.*/
    if (response.resultCode === ResultCodeEnum.Success) dispatch(actionCreator(id));
    /*Указываем, что больше не находимся в процессе попытки зафолловить/заанфолловить какого-то пользователя.*/
    dispatch(usersAC.toggleIsFollowingInProgress(false, id));
};

/*Далее идут два основных TC для осуществления анфолловинга/фолловинга пользователей "unfollow()" и "follow()". Все, что
они делают так это вызывают вспомогательный TC для осуществления анфолловинга/фолловинга пользователей
"_followUnfollowFlow()" и передают ему ряд параметров для его работы.*/

/*Это TC для осуществления анфолловинга какого-либо пользователя. На входе принимает ID пользователя для анфолловинга,
которое должно быть числом.*/
export const unfollow = (id: number): ThunkType => async (dispatch) => {
    /*Так как мы берем метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли
    этот метод какие-нибудь свойства с контекстом this и так далее, поэтому мы используем здесь функцию "bind()", чтобы
    не потерять контекст this. Но вроде и без этого должно работать.*/
    await _followUnfollowFlow(dispatch, id, usersAPI.unfollow.bind(usersAPI), usersAC.unfollowSuccess);
};

/*Это TC для осуществления фолловинга какого-либо пользователя. На входе принимает "ID" пользователя для фолловинга,
которое должно быть числом.*/
export const follow = (id: number): ThunkType => async (dispatch) => {
    /*Так как мы берем метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли
    этот метод какие-нибудь свойства с контекстом this и так далее, поэтому мы используем здесь функцию "bind()", чтобы
    не потерять контекст this. Но вроде и без этого должно работать.*/
    await _followUnfollowFlow(dispatch, id, usersAPI.follow.bind(usersAPI), usersAC.followSuccess);
};