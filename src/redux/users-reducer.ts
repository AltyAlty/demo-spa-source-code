/*
Это файл "reducer", отвечающего за страницу постраничного вывода пользователей. Каждый "reducer" состоит из:
- констант, содержащих значения для свойства "type" объекта "action"
- "initialState" - своей части "state"
- самой функции "reducer"
- "Action Creators" или "AC"
- "Thunk Creators" или "TC".
*/

import {usersAPI} from '../api/users-api'; /*Импортируем блок запросов, связанных со страницей с постраничным выводом
пользователей.*/

import {updateObjectInArray} from '../utils/helpers/object-helpers'; /*Импортируем вспомогательную функцию, которая
содержит общую логику для "FOLLOW" и "UNFOLLOW" в "reducer".*/

import {ResponseWithDataType, ResultCodeEnum} from '../api/api'; /*Импортируем списки кодов ответов от сервера.*/

import {UserType} from '../types/types'; /*Подключаем типы.*/
import {InferActionsTypes, BaseThunkType, BaseDispatchType} from './redux-store'; /*Подключаем типы.*/


/*Создаем тип "state" из самого "state" при помощи "typeof".*/
export type InitialUsersStateType = typeof initialState;

/*Создали отдельный тип для данных из "state", которые отвечают за фильтрацию пользователей в постраничном выводе.*/
export type UsersFilterType = typeof initialState.filter;


/*Создаем сам "state".*/
let initialState = {
    users: [] as Array<UserType>, /*Свойство, которое будет хранить объекты с информацией о пользователях для
    постраничного вывода, полученные с сервера. Указываем, что этот массив объектов имеет тип массива элементов с
    типом "UserType". Тип "UserType" был создан нами и импортирован сюда.*/
    pageSize: 30, /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводится
    на одной странице в постраниченом выводе пользователей.*/
    totalUsersCount: 0, /*Свойство, которое хранит значение, обозначающее общее количество пользователей.
    Получается с сервера.*/
    currentPage: 1, /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в постраничном
    выводе пользователей.*/
    isFetching: false, /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение
    данных по пользователям для постраничного вывода. Если в процессе, то будет отрисовываться
    компонент-заглушка "Preloader".*/
    WhoIsInFollowingProgress: [] as Array<number>, /*Специальное свойство, которое содержит массив, который будет
    хранить "ID" пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга,
    то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя. Указываем, что это свойство
    имеет тип массива элементов с типом "number" (число).*/
    portionSize: 20, /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе
    может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное
    количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться
    между этими порциями страниц.*/
    filter: { /*Свойство, которое содержит объект, внутри которого указываются фильтры для выборки пользователей в
    постраничном выводе. Это свойство будет использоваться в форме, которая была создана при помощи библиотеки
    "formik", а для этой библиотеки не обязательно хранить значения формы в "store" из библиотеки "redux". Но мы это
    делаем, так как эти фильтры будут применяться как параметры адресной строки, то есть будут являться данными BLL.*/
        term: '', /*Свойство, которое содержит значение для фильтра в виде строкового значения, которое будет получать
        сервер и искать наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких
        пользователей.*/
        friend: null as null | boolean /*Свойство, которое содержит значение для фильтра булева типа, если указать в нем
        "true", то сервер выберет только тех пользователей, которых мы фолловим, если указать "false" - только тех, кого
        мы не фолловим, если указать "null" или вообще не указывать, то выберет всех пользователей.*/
    },
    isNotJustCreated: false /*Специальное свойство, которое показывает то, что мы успели уже указать данные для
    фильтрации пользователей в постраничном выводе или не успели. Нам это нужно, чтобы затриггерить функцию "push" в
    компоненте "Users.tsx", когда мы выбираем первую страницу после того как уже выбрали другую страницу в постраничном
    выводе.*/
};


/*
Это "reducer" - чистая функция, которая принимает объект "action" и копию части "state".
Потом "reducer" изменяет (или не изменяет, если объект "action" не подошел) определенную часть "state" и возвращает ее.
После этого все возвращенные части "state" всех "reducers" собираются в новый "state".
*/
const usersReducer = (state = initialState, action: ActionsType): InitialUsersStateType => { /*Указываем, что тип
"state" на выходе имеет тот же тип "InitialUsersStateType", что и "state" на входе. На входе объекты "action" имеют тип
"ActionsType", созданный нами ниже.*/
    switch (action.type) {
        case 'demo-spa/users-reducer/FOLLOW':
            return { /*Меняем флаг у пользователя, что мы его теперь фоллловим.*/
                ...state, /*Делаем поверхностную копию "state".*/
                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>
                (state.users, action.userID, 'id', {followed: true})
                /*
                Вызываем вспомогательную функцию "updateObjectInArray" и передаем ей:
                "state.users" - информацию о пользователях для постраничного вывода из "state".
                "action.userID" - "ID" пользователя для фолловинга из объекта "action".
                "'id'" - имя свойство в объектах, по которому идет проверка сравнением в "updateObjectInArray".
                "{followed: true}" - объект со свойствами и их значениями, который нужно подменить на место старого
                в найденном объекте.
                В результате получим новый измененным массив объектов с информацией о пользователях для постраничного
                вывода, в котором у одного из пользователей свойство "followed" станет "true", что будет означать, что
                мы его зафолловили.
                */
            };

        case 'demo-spa/users-reducer/UNFOLLOW':
            return { /*Меняем флаг у пользователя, что мы больше его не фоллловим.*/
                ...state, /*Делаем поверхностную копию "state".*/
                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>
                (state.users, action.userID, 'id', {followed: false})
                /*
                Вызываем вспомогательную функцию "updateObjectInArray" и передаем ей:
                "state.users" - информацию о пользователях для постраничного вывода из "state".
                "action.userID" - "ID" пользователя для анфолловинга из объекта "action".
                "'id'" - имя свойство в объектах, по которому идет проверка сравнением в "updateObjectInArray".
                "{followed: false}" - объект со свойствами и их значениями, который нужно подменить на место старого
                в найденном объекте.
                В результате получим новый измененным массив объектов с информацией о пользователях для постраничного
                вывода, в котором у одного из пользователей свойство "followed" станет "false", что будет означать, что
                мы его больше не фолловим.
                */
            };

        case 'demo-spa/users-reducer/SET-USERS':
            return { /*Добавляем данные о пользователях "users" в "state", полученные с сервера.*/
                ...state, /*Делаем поверхностную копию "state".*/
                users: action.users /*Добавляем данные о пользователях "users" в "state". Здесь мы не добавляем к
                существующим данным новые. Мы затираем старые данные, добавляя новые. Здесь мы не делаем глубокую копию,
                так как работаем с примитивом.*/
            };

        case 'demo-spa/users-reducer/SET-CURRENT-PAGE':
            return { /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей в"state".*/
                ...state, /*Делаем поверхностную копию "state".*/
                currentPage: action.currentPage, /*Устанавливаем значение текущей выбранной страницы в постраничном
                выводе пользователей. Здесь мы не делаем глубокую копию, так как работаем с примитивом.*/
            };

        case 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT':
            return { /*Устанавливаем общее количество пользователей в"state".*/
                ...state, /*Делаем поверхностную копию "state".*/
                totalUsersCount: action.count /*Устанавливаем общее количество пользователей. Здесь мы не делаем
                глубокую копию, так как работаем с примитивом.*/
            };

        case 'demo-spa/users-reducer/TOGGLE-IS-FETCHING':
            return { /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для
            постраничного вывода. Если в процессе, то будет отрисовываться компонент-заглушка "Preloader".*/
                ...state, /*Делаем поверхностную копию "state".*/
                isFetching: action.isFetching /*Указываем находится ли в процессе запрос на сервер на получение данных
                по пользователям для постраничного вывода. Здесь мы не делаем глубокую копию, так как работаем
                с примитивом.*/
            };

        case 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS':
            return { /*Оперируем массивом "WhoIsInFollowingProgress" для указания находятся ли или нет какие-либо
            пользователи в процессе анфолловинга/фолловинга.*/
                ...state, /*Делаем поверхностную копию "state".*/
                WhoIsInFollowingProgress: action.isFollowingInProgress /*Если свойство "isFollowingInProgress" (нужен
                только для того, чтобы попасть в первую или вторую строку)*/
                    ? [...state.WhoIsInFollowingProgress, action.userID] /*является "TRUE", то делаем глубокую копию и
                    помещаем "ID" пользователя, который находится в процессе анфолловинга/фолловинга
                    в массив "WhoIsInFollowingProgress",*/
                    : state.WhoIsInFollowingProgress.filter(id => id !== action.userID) /*иначе если является "FALSE",
                    то делаем глубокую копию и удаляем "ID" этого пользователя из массива "WhoIsInFollowingProgress"
                    при помощи метода "filter()", который создает новый массив (тем самым мы делаем копию), в который
                    войдут только те элементы, которые не равны "ID" указанного пользователя.*/
            };

        case 'demo-spa/users-reducer/SET-FILTER': /*Устанавливаем данные по фильтрам для отображения пользователей в
        постраничном выводе пользователей в "state".*/
            return { /*Здесь благодаря деструктуризации мы сможем передать нужные значения свойств из "payload" в нужные
            свойства "state" при совпадении имен свойств.*/
                ...state, /*Делаем поверхностную копию "state".*/
                filter: action.payload /*Объект "action" будет иметь объект "payload", который содержит объект "filter"
                со свойствами "term" и "friend". Делаем глубокую копию, чтобы установить эти данные в "state",
                деструктурируя этот объект "payload".*/
            };

        case 'demo-spa/users-reducer/TOGGLE-IS-NOT-JUST-CREATED':
            return { /*Указываем в "state" то, что мы успели уже указать данные для фильтрации пользователей в
            постраничном выводе или не успели.*/
                ...state, /*Делаем поверхностную копию "state".*/
                isNotJustCreated: action.isNotJustCreated /*Указываем то, что мы успели уже указать данные для
                фильтрации пользователей в постраничном выводе или не успели. Здесь мы не делаем глубокую копию, так как
                работаем с примитивом.*/
            };

        default: /*Если объект "action" никуда не подошел, то по default возвращается тот же "state", чтобы не вызвать
        перерисовку.*/
            return state;
    }
};


/*Создаем типы для объектов "action".*/
type ActionsType = InferActionsTypes<typeof usersAC>; /*Здесь мы все созданные раннее типы для объектов "action"
объеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип "InferActionsTypes" для
определения типов всех объектов "action" у упакованных в единый объект "usersAC" AC.*/

/*
Action Creators.
AC создает объект, который передается в reducer.
Этот объект как минимум должен иметь свойство "type", которое определяет, что необходимо выполнить в reducer.
*/
export const usersAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные
раннее на основе каждого AC. Также вверху удалили все константы со значениями для "type" и указывываем их сразу в AC,
так как "TypeScript" не даст нам допустить ошибку при указании этих "types" в "reducer". Согласно модульному паттерну
"Redux Ducks", чтобы избежать случаев одиноковых значений свойств "type" из-за чего один и тот же объект "action" может
сработать в нескольких "reducers", в значениях свойств "type" в объекте "action" указываются
"имя-проекта/имя-файла/имя-объекта-action". Также в конце везде добавили "as const", чтобы "reducer" адекватно
воспринимал объекты "action". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных
типов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/
    followSuccess: (userID: number) => ({ /*AC для указания того, что мы зафолловили пользователя. На входе получает
    "userID", которое дожно быть числом.*/
        type: 'demo-spa/users-reducer/FOLLOW', /*Обязательно свойство "type" для AC.*/
        userID /*Это равносильно "userID: userID". "ID" пользователя, которого мы фолловим.*/
    } as const),

    unfollowSuccess: (userID: number) => ({ /*AC для указания того, что мы анфолловили пользователя. На входе получает
    "userID", которое дожно быть числом.*/
        type: 'demo-spa/users-reducer/UNFOLLOW', /*Обязательно свойство "type" для AC.*/
        userID /*Это равносильно "userID: userID". "ID" пользователя, которого мы анфолловим.*/
    } as const),

    setUsers: (users: Array<UserType>) => ({ /*AC для установки данных пользователей "users" в "state", которые получены
    с сервера. На входе получает "users", которое дожно быть массивом с объектами типа "UserType", созданного нами и
    импортированного сюда.*/
        type: 'demo-spa/users-reducer/SET-USERS', /*Обязательно свойство "type" для AC.*/
        users /*Это равносильно "users: users". Данные по пользователям для постраничного вывода пользователей,
        полученные с сервера.*/
    } as const),

    setCurrentPage: (currentPage: number) => ({ /*AC для установки значения текущей выбранной страницы в постраничном
    выводе пользователей в "state". На входе получает "currentPage", которое дожно быть числом.*/
        type: 'demo-spa/users-reducer/SET-CURRENT-PAGE', /*Обязательно свойство "type" для AC.*/
        currentPage /*Это равносильно "currentPage: currentPage". Номер выбранной текущей страницы в постраничном
        выводе пользователей.*/
    } as const),

    setTotalUsersCount: (totalUsersCount: number) => ({ /*AC для установки общего количество пользователей в "state". На
    входе получает "totalUsersCount", которое дожно быть числом.*/
        type: 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT', /*Обязательно свойство "type" для AC.*/
        count: totalUsersCount /*Значение обозначающее общее количество пользователей.*/
    } as const),

    toggleIsFetching: (isFetching: boolean) => ({ /*AC для указания находится ли в процессе запрос на сервер на
    получение данных по пользователям для постраничного вывода. Если в процессе, то будет отрисовываться
    компонент-заглушка "Preloader". На входе получает "isFetching", которое дожно быть булева типа.*/
        type: 'demo-spa/users-reducer/TOGGLE-IS-FETCHING', /*Обязательно свойство "type" для AC.*/
        isFetching /*Это равносильно "isFetching: isFetching". Специальное свойство, которое обозначает находится ли в
        процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/
    } as const),

    toggleIsFollowingInProgress: (isFollowingInProgress: boolean, /*На входе получает "isFollowingInProgress",
                                  которое дожно быть булева типа.*/
                                  userID: number /*На входе получает "userID", которое дожно быть числом.*/
    ) => ({ /*AC для указания находится ли в процессе анфолловинга/фолловинга какой-либо пользователь. Если в процессе,
    то кнопка для анфолловинга/фолловинга будет отключена.*/
        type: 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS', /*Обязательно свойство "type" для AC.*/
        isFollowingInProgress, /*Это равносильно "isFollowingInProgress: isFollowingInProgress". Специальное свойство,
        которое указывает находится ли какой-либо пользователь в процессе анфолловинга/фолловинга.*/
        userID /*Это равносильно "userID: userID". Специальное свойство, которое указывает "ID" пользователя по которому
        идет проверка находится ли он в процессе анфолловинга/фолловинга.*/
    } as const),

    setFilter: (filter: UsersFilterType) => ({ /*AC для установки фильтров для отображения пользователей в постраничном
    выводе пользователей в "state". На входе получает "filter", которое дожно быть типа "UsersFilterType", который мы
    создали выше.*/
        type: 'demo-spa/users-reducer/SET-FILTER', /*Обязательно свойство "type" для AC.*/
        payload: filter /*Объект с данными по фильтрам для отображения пользователей в постраничном выводе
        пользователей. Далее мы его деструктурируем в "usersReducer".*/
    } as const),

    toggleIsNotJustCreated: (isNotJustCreated: boolean) => ({ /*AC для указания того, что мы успели уже указать данные
    для фильтрации пользователей в постраничном выводе или не успели. На входе получает "isNotJustCreated", которое
    дожно быть булева типа.*/
        type: 'demo-spa/users-reducer/TOGGLE-IS-NOT-JUST-CREATED', /*Обязательно свойство "type" для AC.*/
        isNotJustCreated /*Это равносильно "isNotJustCreated: isNotJustCreated". Специальное свойство, которое
        показывает то, что мы успели уже указать данные для фильтрации пользователей в постраничном выводе или не
        успели.*/
    } as const)
};


/*Создаем типы для "Thunk Creators".*/
type DispatchType = BaseDispatchType<ActionsType>; /*Создали тип для "dispatch", передается в "thunks" и TC.*/

type ThunkType = BaseThunkType<ActionsType>; /*Создали тип для "thunks".
*/


/*
Thunk creators.
"Thunk" это функция, которая может выполнять AJAX-запросы и "dispatch".
Поскольку "reducers" нужны объекты "action" и "reducers" работают синхронно (AJAX-запросы несинхронные, поэтому будут
замедлять этот процесс),
а также "reducers" являются чистыми функциями, то мы не можем напрямую диспатчить "thunk".
В таком случае, "thunk" должен сначала сам запуститься, внутри него задиспатчаться объекты "action" и
в дальнейшем будут раскиданы по "reducers".
В параметрах "thunk" всегда приходит функция "dispatch".
"store" из "Redux" запускает "thunk" и закидывает в него функцию "dispatch" потому, что она у него есть.
Но, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в "thunk" нам нужно
использовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то
дополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет
доступ к данным 1-й функции. Этой 1-й родительской функцией является "Thunk creator" (по аналогии с "Action creator").
В TC передается текст сообщения, а сам "thunk" возьмет это сообщения из замыкания. В итоге мы диспатчм "TC",
а не сам "thunk". Также для этого нам нужен некий промежуточный слой "thunk middleware" между "store.dispatch" и
"reducers". Если в "store" придет объект "action", то "thunk middleware" передаст его в "reducers". Если же в "store"
придет "thunk", то "thunk middleware" запустить этот "thunk", закинет в него функцию "dispatch" и на выходе будет
объект "action", который затем будет передан в "reducers". Если в "thunk" будет несколько AC, то сначала отправится
первый AC в "thunk middleware", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть
замыкание. Для установки "thunk middleware" нам нужна библиотека "redux-thunk". Установка происходит в файле со "store"
из "redux". В TC мы диспатчим не сам AC, а их вызовы.
*/
export const requestUsers = (currentPage: number, /*На входе принимает номер текущей выбранной страницы в постраничном
                             выводе пользователей, который должен быть числом.*/
                             pageSize: number, /*На входе принимает свойство, которое хранит значение, обозначающее
                             сколько пользователей может максимально выводится на одной странице в постраниченом выводе
                             пользователей, которое должно быть числом.*/
                             filter: UsersFilterType /*На входе принимает свойство, которое хранит данные по фильтрам
                             для отображения пользователей в постраничном выводе пользователей, которые должны быть типа
                             "UsersFilterType", который мы создали выше.*/
): ThunkType => async (dispatch) => {
/*Это TC для запроса и установки данных по пользователям в постраничном выводе. Здесь вместо использования ".then"
мы используем "async/await". Промис будет ожидаться в "await". "async" делает TC асинхронным. Этот TC на выходе
возвращает "thunk", который имеет тип "ThunkType", созданный нами выше. Мы могли здесь также указать тип "dispatch",
"getState()" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть "thunk", мы также типизировали,
что в "thunk" будет передаваться дальше, то есть те самые "dispatch", "getState()" и дополнительные аргументы.*/

    dispatch(usersAC.toggleIsFetching(true)); /*Включаем компонент-заглушку "Preloader" перед началом
    запроса на сервер.*/

    dispatch(usersAC.setFilter(filter)); /*При помощи AC "setFilter" устанавливаем данные по фильтрам для отображения
    пользователей в постраничном выводе пользователей в "state".*/

    const response = await usersAPI.getUsers(currentPage, pageSize, filter.term, filter.friend); /*Делаем запрос на
    сервер для получения данных по пользователям для постраничного вывода и ждем ответа от сервера. Здесь будет
    ожидаться промис. Когда он зарезольвиться, он сохраниться в "response". Здесь "return" не нужен, так как асинхронная
    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/

    dispatch(usersAC.toggleIsFetching(false)); /*После получения ответа от сервера, отключаем
    компонент-заглушку "Preloader".*/
    dispatch(usersAC.setUsers(response.items)); /*При помощи AC "setUsers" устанавливаем данные по пользователям
    для постраничного вывода в "state".*/
    dispatch(usersAC.setTotalUsersCount(response.totalCount)); /*Устанавливаем общее количество пользователей в
    "state".*/
};

/*Это вспомогательный TC для осуществления анфолловинга/фоллофинга пользователей "_followUnfollowFlow". Он вызывается
внутри TC "unfollow" или "follow". Для своей работы он принимает следующие параметры: метод "dispatch" (обязателен для
"thunk", "store" из "redux" его сам закинет), "ID" пользователя для анфолловинга/фолловинга, запрос на сервер для
анфолловинга/фолловинга, AC для анфолловинга/фолловинга. Эти параметры он получает от TC "unfollow" или "follow".
Здесь вместо использования ".then" мы используем "async/await". Промис будет ожидаться в "await". "async" делает TC
асинхронным.*/
const _followUnfollowFlow = async (dispatch: DispatchType, /*На входе принимает "dispatch", который должен быть типа
                                   "DispatchType", который мы создали выше.*/
                                   id: number, /*На входе принимает "ID" пользователя, которого мы фолловим/анфолловим,
                                   которое должно быть числом.*/
                                   apiMethod: (id: number) => Promise<ResponseWithDataType>, /*На входе принимает метод
                                   API, который должен быть функцией, которая на входе принимает числовой параметр, а на
                                   выходе выдаед промис, который резольвится данными типа "ResponseWithDataType". Такая
                                   типизация сделана на основе запросов "follow" и "unfollow" из "users-api.ts".*/
                                   actionCreator: (id: number) => ActionsType
                                   /*На входе принимает AC, который должен быть функцией, которая на входе принимает
                                   числовой параметр, а на выходе ранее возвращала объекты "action" либо с типом
                                   "FollowSuccessActionType", либо с типом "UnfollowSuccessActionType", оба эти типа
                                   были созданы нами, но затем удалены, поэтому сейчас эти объекты "action" временно
                                   должны быть общего типа для всех объектов "action" - "ActionsType".*/
) => {

    dispatch(usersAC.toggleIsFollowingInProgress(true, id)); /*Указываем, что находимся в процессе
    попытки зафолловить/заанфолловить какого-то пользователя.*/

    const response = await apiMethod(id); /*Делаем запрос на сервер на анфолловинг/фолловинг и ждем ответа от сервера.
    Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в "response". Здесь "return" не нужен, так как
    асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/

    if (response.resultCode === ResultCodeEnum.Success) { /*Если в ответе от сервера в свойстве "resultCode" указано "0"
    (т.е. операция прошла успешно), то диспатчим AC на анфолловинг/фолловинг, передав в этот AC "ID" пользователя,
    которого анфолловим/фолловим.*/
        dispatch(actionCreator(id))
    }

    dispatch(usersAC.toggleIsFollowingInProgress(false, id)); /*Указываем, что больше не находимся в
    процессе попытки зафолловить/заанфолловить какого-то пользователя.*/
}

/*Далее идут два основных TC для осуществления анфолловинга/фоллофинга пользователей "unfollow" и "follow". Все, что они
делают это вызывают вспомогательный TC для осуществления анфолловинга/фоллофинга пользователей "_followUnfollowFlow" и
передают ему ряд параметров для его работы: метод "dispatch" (обязателен для "thunk", "store" из "redux" его сам
закинет), "ID" пользователя для анфолловинга/фолловинга, запрос на сервер для анфолловинга/фолловинга, AC для
анфолловинга/фолловинга. Здесь вместо использования ".then" мы используем "async/await". Промис будет ожидаться
в "await". "async" делает TC асинхронным.*/
export const unfollow = (id: number): ThunkType => async (dispatch) => {
/*Это TC для осуществления анфолловинга какого-либо пользователя. На входе принимает "ID" пользователя, которого мы
анфолловим, которое должно быть числом. Этот TC на выходе возвращает "thunk", который имеет тип "ThunkType", созданный
нами выше. Мы могли здесь также указать тип "dispatch", "getState()" и дополнительных аргументов, но типизируя то, что
возвращает TC, то есть "thunk", мы также типизировали, что в "thunk" будет передаваться дальше, то есть те самые
"dispatch", "getState()" и дополнительные аргументы.*/
    await _followUnfollowFlow(dispatch, id, usersAPI.unfollow.bind(usersAPI), usersAC.unfollowSuccess); /*Так как мы
    берем метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли этот метод
    какие-нибудь свойства с "this" и т.д., поэтому мы используем здесь "bind()", чтобы не потерять контекст "this". Но
    вроде и без этого должно работать.*/
};

export const follow = (id: number): ThunkType => async (dispatch) => {
/*Это TC для осуществления фолловинга какого-либо пользователя. На входе принимает "ID" пользователя, которого мы
фолловим, которое должно быть числом. Этот TC на выходе возвращает "thunk", который имеет тип "ThunkType", созданный
нами выше. Мы могли здесь также указать тип "dispatch", "getState()" и дополнительных аргументов, но типизируя то, что
возвращает TC, то есть "thunk", мы также типизировали, что в "thunk" будет передаваться дальше, то есть те самые
"dispatch", "getState()" и дополнительные аргументы.*/
    await _followUnfollowFlow(dispatch, id, usersAPI.follow.bind(usersAPI), usersAC.followSuccess); /*Так как мы берем
    метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли этот метод
    какие-нибудь свойства с "this" и т.д., поэтому мы используем здесь "bind()", чтобы не потерять контекст "this". Но
    вроде и без этого должно работать.*/
};


export default usersReducer; /*Экспортируем "usersReducer" по default и будем его использовать в нашем проекте под
именем "usersReducer", экспорт необходим для импорта.*/