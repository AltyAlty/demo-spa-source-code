/*Импортируем объект "usersAC" откуда будем брать различные AC. Также импортируем весь редьюсер "usersReducer()" и тип
"InitialUsersStateType".*/
import {usersReducer, InitialUsersStateType, usersAC} from './users-reducer';

/*Создаем общие входные данные для тестов. Эти данные представляют собой state из файла "users-reducer.ts", имеющие тип
"InitialUsersStateType".*/
let state: InitialUsersStateType;

/*Какой-то из тестов может изменить этот state перед использованием этого state другим тестом (например, когда запускаем
набор тестов). Чтобы избежать таких случаев мы используем функцию "beforeEach()" из библиотеки Jest, указывая в ней
функцию, которая возвращает state со всеми его внутренними данными, чтобы перед каждым тестом мы могли инициализировать
state заново.*/
beforeEach(() => {
    state = {
        /*Свойство, которое будет хранить объекты с информацией о пользователях для постраничного вывода, полученные
        с сервера.*/
        users: [
            {id: 0, name: 'Beep', followed: false, photos: {large: 'link1', small: 'link2'}, status: 'keek'},
            {id: 1, name: 'Boop', followed: false, photos: {large: 'link3', small: 'link4'}, status: 'kook'},
            {id: 2, name: 'Bop', followed: true, photos: {large: 'link5', small: 'link6'}, status: 'kok'},
            {id: 3, name: 'Bep', followed: true, photos: {large: 'link7', small: 'link8'}, status: 'kek'}
        ],
        /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводиться на одной
        странице в постраничном выводе пользователей.*/
        pageSize: 30,
        /*Свойство, которое хранит значение, обозначающее общее количество пользователей. Получается с сервера.*/
        totalUsersCount: 0,
        /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в постраничном выводе
        пользователей.*/
        currentPage: 1,
        /*Специальное свойство, обозначающее находится ли в процессе запрос на сервер на получение данных по
        пользователям для постраничного вывода. Если в процессе, то будет отрисовываться компонент-заглушка
        "Preloader".*/
        isFetching: false,
        /*Специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то определенный момент
        находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для
        анфолловинга/фолловинга от пользователя.*/
        WhoIsInFollowingProgress: [],
        /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может
        отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное
        количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и
        переключаться между этими порциями страниц.*/
        portionSize: 20,
        /*Свойство, содержащее объект, внутри которого указываются фильтры для выборки пользователей в постраничном
        выводе. Это свойство будет использоваться в форме, которая была создана при помощи библиотеки Formik, а для этой
        библиотеки не обязательно хранить значения формы в store из библиотеки Redux. Но мы это делаем, так как эти
        фильтры будут применяться как параметры адресной строки, то есть будут являться данными BLL.*/
        filter: {
            /*Свойство, содержащее значение для фильтра в виде строкового значения, которое будет получать сервер и
            искать наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких
            пользователей.*/
            term: '',
            /*Свойство, содержащее значение для фильтра булева типа, если указать в нем true, то сервер выберет только
            тех пользователей, которых мы фолловим, если указать false - только тех, кого мы не фолловим, если указать
            null или вообще не указывать, то выберет всех пользователей.*/
            friend: null
        }
    }
});

describe('tests for usersReducer', () => {
    /*Тест №1. После того как зафолловили одного из пользователей, другой пользователь, которого мы не фолловили до
    этого, должен остаться незафолловенным.*/
    test('after following a user, another unfollowed user should remain unfollowed', () => {
        /*Указываем входные данные конкретно для этого теста. Получаем action-объект при помощи AC "followSuccess()",
        передав ему ID пользователя со значением 1*/
        const action = usersAC.followSuccess(1);
        /*Шаги теста. Получаем новый state при помощи редьюсера "usersReducer()", передав в него state из общих входных
        данных для тестов и action-объект, созданный выше в этом тесте. То есть должен сработать AC "followSuccess()" в
        редьюсере "usersReducer()" и поменять свойство "followed" на значение true у объекта, который является вторым
        элементом в массиве "users" в переданном state, так как именно этот объект содержит свойство "id: 1".*/
        const newState = usersReducer(state, action);
        /*Ожидаемый результат. Ожидается, что свойство "followed" у объекта, являющегося первым элементом в массиве
        "users", то есть объект, который содержит свойство "id: 0", останется со значением false.*/
        expect(newState.users[0].followed).toBeFalsy();
        /*Ожидается, что свойство "followed" у объекта, являющегося вторым элементом в массиве "users", то есть объект,
        который содержит свойство "id: 1", станет со значением true.*/
        expect(newState.users[1].followed).toBeTruthy();
    });


    /*Тест №2. После того как заанфолловили одного из пользователей, другой пользователь, которого мы фолловили до
    этого, должен остаться зафолловенным.*/
    test('after unfollowing a user, another followed user should remain followed', () => {
        /*Указываем входные данные конкретно для этого теста. Получаем action-объект при помощи AC "unfollowSuccess()",
        передав ему ID пользователя со значением 3.*/
        const action = usersAC.unfollowSuccess(3);
        /*Шаги теста. Получаем новый state при помощи редьюсера "usersReducer()", передав в него state из общих входных
        данных для тестов и action-объект, созданный выше в этом тесте. То есть должен сработать AC "unfollowSuccess()"
        в редьюсере "usersReducer()" и поменять свойство "followed" на значение false у объекта, который является
        четвертым элементом в массиве "users" в переданном state, так как именно этот объект содержит свойство "id: 3".*/
        const newState = usersReducer(state, action);
        /*Ожидаемый результат. Ожидается, что свойство "followed" у объекта, являющегося третьим элементом в массиве
        "users", то есть объект, который содержит свойство "id: 2", останется со значением true.*/
        expect(newState.users[2].followed).toBeTruthy();
        /*Ожидается, что свойство "followed" у объекта, являющегося четвертым элементом в массиве "users", то есть
        объект, который содержит свойство "id: 3", станет со значением false.*/
        expect(newState.users[3].followed).toBeFalsy();
    });
});