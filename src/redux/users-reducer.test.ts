/*
Это файл с тестами для "users-reducer.ts".
Тесты в "TDD" пишутся заранее, чтобы программа им соответствовала.
Тесты обязуют нас писать правильно структурированную программу.
Тесты работают точечно, то есть нам не надо каждый раз запускать программу полностью, чтобы ее протестировать.
Unit-тесты тестируют отдельные части приложения (например, модули, компоненты, функции, селекторы и т.д.)
В "App.test.js" уже есть тест, который можно запустить прямо из "WebStorm" или через консоль "npm run test".
".test." в названии файла сообщает настроенной системе "Webpack" и тестовой среде разработки (это скрыто в
"react-scripts" (используется библиотека "JEST"), "create-react-app" скрыл эти детали), что такой файл содержит тесты и
IDE будет их запускать. Желательно, чтобы каждый тест проверял что-то одно.
*/

import usersReducer, {InitialUsersStateType, usersAC} from './users-reducer'; /*Импортировали из "users-reducer.ts"
объект "usersAC" откуда будем брать различные AC. Также импортировали весь "reducer" и тип "InitialUsersStateType" из
"users-reducer.ts".*/


/*Создали общие входные данные для тестов. Эти данные представляют из себя "state" из "users-reducer.ts", которые имеют
тип "InitialUsersStateType", которые был создан нами и импортирован сюда.*/
let state: InitialUsersStateType;

/*Так как какой-то из тестов может изменить этот "state" перед использованием этого "state" другим тестом (например,
когда запускаем набор тестов), то чтобы избежать таких случаев мы используем функцию "beforeEach" из библиотеки "JEST",
указав в ней функцию, которая возвращает "state" со всеми его внутренними данными, чтобы перед каждым тестом мы
могли инициализировать "state" заново.*/
beforeEach(() => {
    state = {
        users: [
            {id: 0, name: 'Beep', followed: false, photos: {large: 'link1', small: 'link2'}, status: 'keek'},
            {id: 1, name: 'Boop', followed: false, photos: {large: 'link3', small: 'link4'}, status: 'kook'},
            {id: 2, name: 'Bop', followed: true, photos: {large: 'link5', small: 'link6'}, status: 'kok'},
            {id: 3, name: 'Bep', followed: true, photos: {large: 'link7', small: 'link8'}, status: 'kek'}
        ], /*Свойство, которое будет хранить объекты с информацией о пользователях для постраничного вывода, полученные
        с сервера.*/
        pageSize: 30, /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально
        выводится на одной странице в постраниченом выводе пользователей.*/
        totalUsersCount: 0, /*Свойство, которое хранит значение, обозначающее общее количество пользователей.
        Получается с сервера.*/
        currentPage: 1, /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в
        постраничном выводе пользователей.*/
        isFetching: false, /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на
        получение данных по пользователям для постраничного вывода. Если в процессе, то будет отрисовываться
        компонент-заглушка "Preloader".*/
        WhoIsInFollowingProgress: [], /*Специальное свойство, которое содержит массив, который будет хранить "ID"
        пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по
        ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
        portionSize: 20 /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном
        выводе может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц,
        коих огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40)
        и переключаться между этими порциями страниц.*/
    }
});


describe('tests for usersReducer', () => { /*"describe" позволит определить IDE, что это группа
тестов.*/
    /*Тест №1. После того как зафолловили одного из пользователей, другой пользователь, которого мы не фолловили до
    этого, должен остаться незафолловенным.*/
    test('after following a user, another unfollowed user should remain unfollowed', () => { /*"test" позволит
    определить IDE, что это тест.*/
        /*Указываем входные данные конкретно для этого теста.*/
        const action = usersAC.followSuccess(1); /*Получаем объект "action" при помощи AC "followSuccess", передав
        ему "ID" пользователя со значением "1".*/

        /*Шаги теста.*/
        const newState = usersReducer(state, action); /*Получаем новый "state" при помощи "usersReducer", передав в него
        "state" из общих входных данных для тестов и объект "action", созданный выше в этом тесте. То есть должен
        сработать AC "followSuccess" в "usersReducer" и поменять свойство "followed" на значение "true" у объекта,
        который является вторым элементом в массиве "users" в переданном "state", так как именно этот объект содержит
        свойство "id: 1".*/

        /*Ожидаемый результат. "expect" позволит определить IDE, что это ожидаемый результат в тесте.*/
        expect(newState.users[0].followed).toBeFalsy(); /*Ожидается, что свойство "followed" у объекта, который является
        первым элементом в массиве "users", то есть объект, который содержит свойство "id: 0", останется со значением
        "false".*/
        expect(newState.users[1].followed).toBeTruthy(); /*Ожидается, что свойство "followed" у объекта, который
        является вторым элементом в массиве "users", то есть объект, который содержит свойство "id: 1", станет со
        значением "true".*/
    });


    /*Тест №2. После того как заанфолловили одного из пользователей, другой пользователь, которого мы фолловили до
    этого, должен остаться зафолловенным.*/
    test('after unfollowing a user, another followed user should remain followed', () => { /*"test" позволит
    определить IDE, что это тест.*/
        /*Указываем входные данные конкретно для этого теста.*/
        const action = usersAC.unfollowSuccess(3); /*Получаем объект "action" при помощи AC "unfollowSuccess",
        передав ему "ID" пользователя со значением "3".*/

        /*Шаги теста.*/
        const newState = usersReducer(state, action); /*Получаем новый "state" при помощи "usersReducer", передав в него
        "state" из общих входных данных для тестов и объект "action", созданный выше в этом тесте. То есть должен
        сработать AC "unfollowSuccess" в "usersReducer" и поменять свойство "followed" на значение "false" у объекта,
        который является четвертым элементом в массиве "users" в переданном "state", так как именно этот объект содержит
        свойство "id: 3".*/

        /*Ожидаемый результат. "expect" позволит определить IDE, что это ожидаемый результат в тесте.*/
        expect(newState.users[2].followed).toBeTruthy(); /*Ожидается, что свойство "followed" у объекта, который
        является третьим элементом в массиве "users", то есть объект, который содержит свойство "id: 2", останется со
        значением "true".*/
        expect(newState.users[3].followed).toBeFalsy(); /*Ожидается, что свойство "followed" у объекта, который является
        четвертым элементом в массиве "users", то есть объект, который содержит свойство "id: 3", станет со значением
        "false".*/
    });
});
