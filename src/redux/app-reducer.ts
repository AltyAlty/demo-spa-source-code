/*Импортируем TC "getAuthUserData()" для запроса и установки данных залогиненного пользователя в state.*/
import {getAuthUserData} from './auth-reducer';
/*Импортируем типы "InferActionsTypes" и "BaseThunkType".*/
import {InferActionsTypes, BaseThunkType} from './redux-store';

/*Создаем тип state из самого state при помощи typeof.*/
type InitialAppStateType = typeof initialState;

/*Создаем сам state. Указываем, что "initialState" имеет тип "InitialStateType", созданный нами выше.*/
let initialState = {
    /*Свойство, которое показывает инициализировано ли приложение.*/
    initialized: false
};

/*Создаем редьюсер, отвечающий за страницу профиля.

Reducer - это чистая функция, которая принимает action-объект и копию части state. Потом редьюсер изменяет (или не
изменяет, если action-объект не подошел) определенную часть state и возвращает ее. После этого все возвращенные части
state всех редьюсеров собираются в новый state.

Каждый reducer состоит из:
1. констант, содержащих значения для свойства "type" объекта "action";
2. "initialState" - своей части state;
3. самой функции-редьюсера;
4. Action Creators или AC
5. Thunk Creators или TC.

Нам нужен этот редьюсер, чтобы избежать моргания страницы (кроме страницы профиля) после F5, так как после каждого
обновления страницы отправляется запрос на логинизацию, и пока осуществляется этот запрос мы будем считаться
незалогиненными, соответственно, будем видеть страницу логинизации, а когда запрос на логинизацию завершится мы увидим
страницу профиля вместо нужной нам страницы. И чтобы этого не допустить, мы не будем ничего показывать, пока не убедимся
что мы залогинены.

Указываем, что тип state на выходе имеет тот же тип "InitialAppStateType", что и state на входе. На входе action-объекты
имеют тип "ActionsType", созданный нами ниже.*/
export const appReducer = (state = initialState, action: ActionsType): InitialAppStateType => {
    switch (action.type) {
        /*Указываем, что приложение успешно инициализировано.*/
        case 'demo-spa/app-reducer/INITIALIZATION-SUCCESSFUL': {
            return {
                /*Делаем поверхностную копию state. На данный момент этого не требуется, так как далее мы меняем
                примитив.*/
                ...state,
                /*Меняем свойство, показывающее инициализировано ли приложение.*/
                initialized: true
            };
        }

        /*Если action-объект никуда не подошел, то по default возвращается тот же state, чтобы не вызвать перерисовку.*/
        default: {
            return state;
        }
    }
};

/*Создаем типы для action-объектов. Здесь мы все раннее созданные типы для action-объектов объединяем в один тип. Мы его
получаем следующим образом: используем тип "InferActionsTypes" для определения типов всех action-объектов, возвращаемых
АС-ми, упакованными в единый объект "appAC".*/
type ActionsType = InferActionsTypes<typeof appAC>;

/*Action Creators. AC создает объект, который передается в редьюсер. Этот объект как минимум должен иметь свойство
"type", которое определяет, что необходимо выполнить в редьюсере.

Создаем специальный объект, содержащий все наши AC. Все AC мы помещаем в единый объект с целью избавиться от большого
количества отдельных типов для каждого AC в обмен на один общий для них тип, который мы создаем выше. Также удаляем все
типы, созданные раннее на основе каждого AC. Также вверху удаляем все константы со значениями для "type" и указываем их
сразу в AC, так как Typescript не даст нам допустить ошибку при указании этих "types" в редьюсере.

Согласно модульному паттерну Redux Ducks, чтобы избежать случаев одинаковых значений свойств "type" из-за чего один и
тот же action-объект может сработать в нескольких редьюсерах, в значениях свойств "type" в action-объекте указываются
"имя-проекта/имя-файла/имя-объекта-action".

Также в конце везде добавляем "as const", чтобы редьюсер адекватно воспринимал action-объекты.*/
export const appAC = {
    /*AC для инициализации приложения.*/
    initializingApp: () => ({
        /*Обязательно свойство "type" для AC.*/
        type: 'demo-spa/app-reducer/INITIALIZATION-SUCCESSFUL'
    } as const)
};

/*Создаем тип для thunks.*/
type ThunkType = BaseThunkType<ActionsType>;

/*Thunk creators. Thunk - это функция, которая может выполнять AJAX-запросы и dispatch-функцию. Поскольку редьюсерам
нужны action-объекты и редьюсеры работают синхронно (AJAX-запросы несинхронные, поэтому будут замедлять этот процесс), а
также редьюсеры являются чистыми функциями, то мы не можем напрямую диспатчить thunks. В таком случае, thunk должен
сначала сам запуститься, внутри него задиспатчатся action-объекты и в дальнейшем будут раскиданы по редьюсерам.

В параметрах thunk всегда приходит dispatch-функция. store из Redux запускает thunk и закидывает в него dispatch-функцию
потому, что она у него есть.

Но, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в thunk нам нужно
использовать замыкание из JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то дополнительные
данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет доступ к данным
1-й функции. Этой 1-й родительской функцией является Thunk creator (по аналогии с Action creator). В TC передается текст
сообщения, а сам thunk возьмет это сообщения из замыкания. В итоге мы диспатчим TC, а не сам thunk.

Также для этого нам нужен некий промежуточный слой thunk middleware между "store.dispatch" и редьюсерами. Если в store
придет action-объект, то thunk middleware передаст его в редьюсеры. Если же в store придет thunk, то thunk middleware
запустить этот thunk, закинет в него dispatch-функцию и на выходе будет action-объект, который затем будет передан в
редьюсеры. Если в thunk будет несколько AC, то сначала отправится первый AC в thunk middleware, потом второй AC и так
далее до тех пор, пока не переберутся все AC. Это и есть замыкание. Для установки thunk middleware нам нужна библиотека
Redux Thunk. Установка происходит в файле со "redux-store.ts".

В TC мы диспатчим не сам AC, а их вызовы.*/

/*TC для инициализации приложения. Этот TC на выходе возвращает thunk, который имеет тип "ThunkType", созданный нами
выше. Мы могли здесь также указать тип dispatch-функции, функцию "getState()" и дополнительных аргументов, но типизируя
то, что возвращает TC, то есть thunk, мы также типизируем, что в thunk будет передаваться дальше, то есть те самые
dispatch-функцию, функцию "getState()" и дополнительные аргументы.

Этот TC работает примерно так:
1. сначала срабатывает TC "getAuthUserData".
2. ожидаем выполнения 1-го шага.
3. после завершения 1-го шага указываем, что приложение инициализировано.*/
export const initializeApp = (): ThunkType => (dispatch) => {
    /*Здесь dispatch-функция возвращает то, что вернет "getAuthUserData()" (TC отвечающий за запрос и установку данных
    залогиненного пользователя в state), и поместит это в массив "promise" (потому, что вернется массив). В этом массиве
    будет разная информация, в том числе и разные промисы.*/
    const promise = dispatch(getAuthUserData());

    /*Здесь мы будем ждать выполнения всех промисов в массиве "promise" (причем не важно успешно они завершатся или
    нет). После этого сработает блок then.*/
    Promise.all([promise])
        /*Вызываем TC "initializingApp()" для указания, что инициализация приложения завершена.*/
        .then(() => { dispatch(appAC.initializingApp()) });
};