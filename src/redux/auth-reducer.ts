/*
Это файл "reducer", отвечающего за аутентификацию и связанные с ней процессы. Каждый "reducer" состоит из:
- констант, содержащих значения для свойства "type" объекта "action"
- "initialState" - своей части "state"
- самой функции "reducer"
- "Action Creators" или "AC"
- "Thunk Creators" или "TC".
*/

import {authAPI} from '../api/auth-api'; /*Импортируем блоки запросов, связанных с аутентификацией.*/
import {securityAPI} from '../api/security-api'; /*Импортируем блоки запросов, связанных с капчей.*/
import {ResultCodeEnum, ResultCodeForCaptchaEnum} from '../api/api'; /*Импортируем списки кодов ответов от сервера.*/

import {FormAction, stopSubmit} from 'redux-form'; /*Импортируем специальный AC "stopSubmit" из библиотеки "redux-form",
который сообщает UI, что что-то пошло не так, и останавливает "submit" данных в форме. Импортировали "FormAction", чтобы
создать тип для объектов "action", который передается в "thunks" и TC.*/

import {InferActionsTypes, BaseThunkType} from './redux-store'; /*Подключаем типы.*/


/*Создаем тип "state" из самого "state" при помощи "typeof".*/
type InitialAuthStateType = typeof initialState;

/*Создаем сам "state".*/
let initialState = {
    id: null as number | null, /*Свойство, которое хранит "ID" залогиненного пользователя. Указываем, что изначально
    это свойство может иметь тип "null", то есть быть пустым, или быть числом.*/
    email: null as string | null, /*Свойство, которое хранит "email" залогиненного пользователя. Указываем, что
    изначально это свойство может иметь тип "null", то есть быть пустым, или быть строкой.*/
    login: null as string | null, /*Свойство, которое хранит "login" залогиненного пользователя. Указываем, что
    изначально это свойство может иметь тип "null", то есть быть пустым, или быть строкой.*/
    isAuth: false, /*Свойство, которое указывает залогинен ли пользователь.*/
    captchaURL: null as string | null /*Свойство, которое хранит URL изображения с капчей. Указываем, что изначально
    это свойство может иметь тип "null", то есть быть пустым, или быть строкой.*/
};


/*
Это "reducer" - чистая функция, которая принимает объект "action" и копию части "state".
Потом "reducer" изменяет (или не изменяет, если объект "action" не подошел) определенную часть "state" и возвращает ее.
После этого все возвращенные части "state" всех "reducers" собираются в новый "state".
*/
const authReducer = (state = initialState, action: ActionsType): InitialAuthStateType => { /*Указываем, что тип
"state" на выходе имеет тот же тип "InitialAuthStateType", что и "state" на входе. На входе объекты "action" имеют тип
"ActionsType", созданный нами ниже.*/
    switch (action.type) {
        case 'demo-spa/auth-reducer/SET-USER-DATA':
        case 'demo-spa/auth-reducer/SET-CAPTCHA-URL': /*Здесь для обоих случаев один и тот же код потому, что в обоих
        соотвествующих AC используется "payload". Благодаря деструктуризации мы сможем передать нужные значения свойств
        из "payload" в нужные свойства "state" при совпадении имен свойств.*/
            return { /*Устанавливаем данные по залогиненному пользователю в "state".*/
                ...state, /*Делаем поверхностную копию "state".*/
                ...action.payload, /*Объект "action" будет иметь объект "payload", который содержит "id", "email",
                "login" и "isAuth". Аналогично может прийти такой же объект "payload", но он может содержать только
                "captchaURL" - URL изображения с капчей. Делаем глубокую копию, чтобы установить эти данные в "state",
                деструктурируя этот объект "payload".*/
            };

        default: /*Если объект "action" никуда не подошел, то по default возвращается тот же "state", чтобы не вызвать
        перерисовку.*/
            return state;
    }
};


/*Создаем типы для объектов "action".*/
type ActionsType = InferActionsTypes<typeof authAC>; /*Здесь мы все созданные раннее типы для объектов "action"
объеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип "InferActionsTypes" для
определения типов всех объектов "action" у упакованных в единый объект "authAC" AC.*/


/*
Action Creators.
AC создает объект, который передается в reducer.
Этот объект как минимум должен иметь свойство "type", которое определяет, что необходимо выполнить в reducer.
*/
export const authAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные
раннее на основе каждого AC. Также вверху удалили все константы со значениями для "type" и указывываем их сразу в AC,
так как "TypeScript" не даст нам допустить ошибку при указании этих "types" в "reducer". Согласно модульному паттерну
"Redux Ducks", чтобы избежать случаев одиноковых значений свойств "type" из-за чего один и тот же объект "action" может
сработать в нескольких "reducers", в значениях свойств "type" в объекте "action" указываются
"имя-проекта/имя-файла/имя-объекта-action". Также в конце везде добавили "as const", чтобы "reducer" адекватно
воспринимал объекты "action". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных
типов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/
    setAuthUserData: (id: number | null, /*На входе получает "ID" пользователя, который должен быть числом или "null",
                      то есть быть пустым.*/
                      email: string | null, /*На входе получает "email" пользователя, который должен быть строкой или
                      "null", то есть быть пустым.*/
                      login: string | null, /*На входе получает "login" пользователя, который должен быть строкой или
                      "null", то есть быть пустым.*/
                      isAuth: boolean /*На входе получает информацию залогинен ли пользователь, которая должна быть
                      булева типа.*/
    ) => ({/*AC для установки данных залогиненного пользователя в "state".*/
        type: 'demo-spa/auth-reducer/SET-USER-DATA', /*Обязательно свойство "type" для AC.*/
        payload: { /*Объект с данными по залогиненному пользователю. Далее мы его деструктурируем в "authReducer".*/
            id, /*Свойство, которое хранит "ID" залогиненного пользователя.*/
            email, /*Свойство, которое хранит "email" залогиненного пользователя.*/
            login, /*Свойство, которое хранит "login" залогиненного пользователя.*/
            isAuth /*Свойство, которое указывает залогинен ли пользователь.*/
        }
    } as const),

    setCaptchaURL: (captchaURL: string) => ({ /*AC для установки URL изображения с капчей в "state". На входе получает
    "captchaURL", которое дожно быть строкой.*/
        type: 'demo-spa/auth-reducer/SET-CAPTCHA-URL', /*Обязательно свойство "type" для AC.*/
        payload: { /*Объект с URL изображения с капчей. Далее мы его деструктурируем в "authReducer".*/
            captchaURL /*Свойство, которое хранит URL изображения с капчей.*/
        }
    } as const)
};


/*Создаем типы для "Thunk Creators".*/
type ThunkType = BaseThunkType<ActionsType | FormAction>; /*Создали тип для "thunks". Поскольку в TC
"login" мы диспатчим "stopSubmit" из библиотеки "redux-form", поэтому здесь мы указали еще "FormAction" из библиотеки
"redux-form", так как в файле декларации "stopSubmit" указано, что он "extends" от "FormAction". Но из-за этого теперь
мы можем диспатчить любой объект "action", что естественно нежелательно для нас.*/


/*
Thunk creators.
"Thunk" это функция, которая может выполнять AJAX-запросы и "dispatch".
Поскольку "reducers" нужны объекты "action" и "reducers" работают синхронно (AJAX-запросы несинхронные, поэтому будут
замедлять этот процесс),
а также "reducers" являются чистыми функциями, то мы не можем напрямую диспатчить "thunk".
В таком случае, "thunk" должен сначала сам запуститься, внутри него задиспатчаться объекты "action" и
в дальнейшем будут раскиданы по "reducers".
В параметрах "thunk" всегда приходит функция "dispatch".
"store" из "Redux" запускает "thunk" и закидывает в него функцию "dispatch" потому, что она у него есть.
Но, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в "thunk" нам нужно
использовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то
дополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет
доступ к данным 1-й функции. Этой 1-й родительской функцией является "Thunk creator" (по аналогии с "Action creator").
В TC передается текст сообщения, а сам "thunk" возьмет это сообщения из замыкания. В итоге мы диспатчм "TC",
а не сам "thunk". Также для этого нам нужен некий промежуточный слой "thunk middleware" между "store.dispatch" и
"reducers". Если в "store" придет объект "action", то "thunk middleware" передаст его в "reducers". Если же в "store"
придет "thunk", то "thunk middleware" запустить этот "thunk", закинет в него функцию "dispatch" и на выходе будет
объект "action", который затем будет передан в "reducers". Если в "thunk" будет несколько AC, то сначала отправится
первый AC в "thunk middleware", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть
замыкание. Для установки "thunk middleware" нам нужна библиотека "redux-thunk". Установка происходит в файле со "store"
из "redux". В TC мы диспатчим не сам AC, а их вызовы.
*/
export const getAuthUserData = (): ThunkType => async (dispatch) => {
/*Это TC для запроса и установки данных залогиненного пользователя в "state". Здесь вместо использования ".then" мы
используем "async/await". Промис будет ожидаться в "await". "async" делает TC асинхронным. Этот TC на выходе возвращает
"thunk", который имеет тип "ThunkType", созданный нами выше. Мы могли здесь также указать тип "dispatch", "getState()"
и дополнительных аргументов, но типизируя то, что возвращает TC, то есть "thunk", мы также типизировали, что в "thunk"
будет передаваться дальше, то есть те самые "dispatch", "getState()" и дополнительные аргументы.*/
    const response = await authAPI.me(); /*Делаем запрос на сервер для получения данных залогиненного пользователя.
    Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в "response". Здесь "return" не нужен, так как
    асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/

    if (response.resultCode === ResultCodeEnum.Success) { /*Если свойство "resultCode", которое пришло в ответе от
    сервера, содержит код "0", то есть ошибки при залогинивании не было, то*/
        let {id, email, login} = response.data; /*деструктурируем объект "data", который пришел в ответе от сервера,
        и получаем "ID", "email" и "login" залогиненного пользователя*/
        dispatch(authAC.setAuthUserData(id, email, login, true)); /*и устанавливаем эти данные в "state" при
        помощи AC "setAuthUserData", четвертый параметр это "isAuth", чтобы сообщить, что пользователь залогинился.*/
    }
};

export const login = (email: string, /*На входе получает "email" пользователя, который должен быть строкой.*/
                      password: string, /*На входе получает пароль пользователя, который должен быть строкой.*/
                      rememberMe: boolean, /*На входе получает информацию запомнить ли пользователя, которая должна быть
                      булева типа.*/
                      captcha: string /*На входе получает путь к капче, который должен быть строкой.*/
): ThunkType => async (dispatch) => {
/*Это TC для осуществления логинизации через наше приложение. Здесь вместо использования ".then" мы используем
"async/await". Промис будет ожидаться в "await". "async" делает TC асинхронным. Также этот TC на выходе возвращает
"thunk", который имеет тип "ThunkType", созданный нами выше. Мы могли здесь также указать тип "dispatch", "getState()" и
дополнительных аргументов, но типизируя то, что возвращает TC, то есть "thunk", мы также типизировали, что в "thunk"
будет передаваться дальше, то есть те самые "dispatch", "getState()" и дополнительные аргументы.*/
    const response = await authAPI.login(email, password, rememberMe, captcha); /*Делаем запрос на сервер для
    залогинивания пользователя. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в "response".
    Здесь "return" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу писать логику
    по работе с ответом от сервера.*/

    if (response.resultCode === ResultCodeEnum.Success) { /*Если свойство "resultCode", которое пришло в ответе от
    сервера, содержит код "0", то есть ошибки при залогинивании не было, то*/
        dispatch(getAuthUserData()) /*вызываем TC "getAuthUserData" для запроса и установки данных залогиненного
        пользователя в "state".*/
    } else {
        if (response.resultCode === ResultCodeForCaptchaEnum.CaptchaIsRequired) { /*Иначе если свойство "resultCode",
        которое пришло в ответе от сервера, содержит код "10", то есть нужно ввести капчу, то*/
            dispatch(getCaptchaURL()); /*вызываем TC "getCaptchaURL" для получения URL изображения с капчей с сервера
            и установки его в "state".*/
        } /*Также иначе если пришло какое-то информационное сообщение об ошибке при логинизации от сервера в
        массиве "messages", то мы положим первый элемент этого массива в переменную "message", если длина этого массива
        больше нуля, или же положим в переменную "message" текст "unknown error".*/
        let message = response.messages.length > 0 ? response.messages[0] : 'unknown error'
        dispatch(stopSubmit('login', {_error: message})); /*Затем задиспатчим специальный AC "stopSubmit()"
        из библиотеки "redux-form", который сообщит UI, что что-то пошло не так, и остановит "submit" данных. Первым
        параметром указывается какую форму необходимо остановить, а вторым параметром указывается объект, в котором
        должно быть свойство "_error" (из библиотеки "redux-form", означает ошибку для всей формы, но здесь можно
        использовать и имена других полей, которые мы создали), которому присваивается значение с текстом ошибки.

        Но сейчас со "stopSubmit" проблемы. При его использовании возникает проблема асинхроности, так как
        библиотека "redux-form" вызывает "setSubmitSucceed()" сразу после "stopSubmit()", не успев вернуть ошибку.
        Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно использовать
        такой костыль:
        setTimeout(async () => await dispatch(stopSubmit('login', {_error: message})))

        Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки "redux-form" (8.3.6).*/
    }
};

const getCaptchaURL = (): ThunkType => async (dispatch) => {
/*Это TC для получения URL изображения с капчей с сервера и установки его в "state". Здесь вместо использования ".then"
мы используем "async/await". Промис будет ожидаться в "await". "async" делает TC асинхронным. Этот TC на выходе
возвращает "thunk", который имеет тип "ThunkType", созданный нами выше. Мы могли здесь также указать тип "dispatch",
"getState()" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть "thunk", мы также типизировали,
что в "thunk" будет передаваться дальше, то есть те самые "dispatch", "getState()" и дополнительные аргументы.*/
    const response = await securityAPI.getCaptchaURL(); /*Делаем запрос на сервер для получения капчи. Здесь будет
    ожидаться промис. Когда он зарезольвиться, он сохраниться в "data". Здесь "return" не нужен, так как асинхронная
    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/
    const captchaURL = response.url; /*Получив ответ от сервера, сохраняем из ответа сервера URL капчи.*/

    dispatch(authAC.setCaptchaURL(captchaURL)); /*Затем устанавливаем этот URL капчи в "state" при помощи AC
    "setCaptchaURL".*/
};

export const logout = (): ThunkType => async (dispatch) => {
/*Это TC для осуществления логаута. Здесь вместо использования ".then" мы используем "async/await". Промис будет
ожидаться в "await". "async" делает TC асинхронным. Этот TC на выходе возвращает "thunk", который имеет тип "ThunkType",
созданный нами выше. Мы могли здесь также указать тип "dispatch", "getState()" и дополнительных аргументов, но типизируя
то, что возвращает TC, то есть "thunk", мы также типизировали, что в "thunk" будет передаваться дальше, то есть те самые
 "dispatch", "getState()" и дополнительные аргументы.*/
    const response = await authAPI.logout(); /*Делаем запрос на сервер для разлогинивания пользователя. Здесь будет
    ожидаться промис. Когда он зарезольвиться, он сохраниться в "response". Здесь "return" не нужен, так как асинхронная
    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/

    if (response.resultCode === 0) { /*Если свойство "resultCode", которое пришло в ответе от сервера, содержит
    код "0", то есть ошибки при разлогинивании не было, то*/
        dispatch(authAC.setAuthUserData(null, null, null, false)); /*обнуляем данные пользователя
        в "state" при помощи AC "setAuthUserData", четвертый параметр это "isAuth", чтобы сообщить, что пользователь
        разлогинился.*/
    }
};


export default authReducer; /*Экспортируем "authReducer" по default и будем его использовать в нашем проекте под
именем "authReducer", экспорт необходим для импорта.*/