/*Здесь содержатся селекторы для данных из файла "users-reducer.ts". Это селекторы для компонента "UsersContainer".*/

/*Функция "mapStateToProps()" в функции "connect()" срабатывает каждый раз, когда что-то меняется в state. Если мы будем
использовать сложные селекторы с дополнительной внутренней логикой, то такие селекторы будут вызывать большую нагрузку и
заставлять часто перерисовывать приложение. Также такие селекторы сложно дебажить. Чтобы избежать этих проблем мы
используем библиотеку Reselect. Эта библиотека помогает нам не перезапускать наши сложные селекторы, если в этом нет
такой необходимости.

Наш селектор после запуска не только должен отправлять что-то в функцию "mapStateToProps()", но и сохранять это что-то в
отдельном месте, чтобы в следующий вызов этого селектора он не сработал снова, а просто вернулось это сохраненное
что-то, если оно не было изменено, то есть мы должны указать от чего зависит наш селектор.

Импортируем функцию "createSelector()" из библиотеки Reselect, чтобы создавать наши селекторы. Функция
"createSelector()" - это специальная функция, которая возвращает селектор, а внутри она получает функцию, описывающую
логику селектора. Для того чтобы передать state в функцию в "createSelector()" нам нужно создать примитивный селектор,
получающий state. Можно создавать сложные селекторы на основе нескольких примитивных селекторов или на основе нескольких
примитивных и сложных селекторов.*/
import {createSelector} from 'reselect';
/*Импортируем тип "AppStateType".*/
import {AppStateType} from './redux-store';

/*Создаем примитивный селектор, получающий "users" из state. На входе этот селектор принимает state с типом
"AppStateType".*/
const getUsersPrimitive = (state: AppStateType) => { return state.usersPage.users};
/*Создаем сложный селектор на основе примитивного селектора "getUsersPrimitive()". Можно указать несколько таких
селекторов через запятую. Этот примитивный селектор будет создавать "users" - данные по пользователям. Внутри второго
параметра просто передается весь "users" как есть. Если бы мы указали, например два селектора вместо одного, то
и помимо "users" нужно было бы указать еще что-то. Этот сложный селектор возвращает данные по пользователям для
постраничного вывода.*/
export const getUsers = createSelector(getUsersPrimitive, (users) => { return users.filter(u => true)});
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает максимальное количество пользователей, которое
выводится в постраничном выводе пользователей.*/
export const getPageSize = (state: AppStateType) => { return state.usersPage.pageSize};
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает свойство, которое указывает какое количество
номеров страниц в постраничном выводе может отображаться в одной порции таких страниц.*/
export const getPortionSize = (state: AppStateType) => { return state.usersPage.portionSize};
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает общее количество пользователей.*/
export const getTotalUsersCount = (state: AppStateType) => { return state.usersPage.totalUsersCount};
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает текущий номер выбранной страницы в постраничном
выводе пользователей.*/
export const getCurrentPage = (state: AppStateType) => { return state.usersPage.currentPage};
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает специальное свойство, обозначающее находится ли в
процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/
export const getIsFetching = (state: AppStateType) => { return state.usersPage.isFetching};
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает специальное свойство, содержащее массив, хранящий
ID пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним
отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/
export const getWhoIsInFollowingProgress = (state: AppStateType) => { return state.usersPage.WhoIsInFollowingProgress};
/*Это созданный нами без библиотеки Reselect селектор. Он возвращает свойство, которое содержит данные по фильтрам для
отображения пользователей в постраничном выводе пользователей.*/
export const getUsersFilter = (state: AppStateType) => { return state.usersPage.filter};