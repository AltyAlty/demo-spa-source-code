/*
Это файл "reducer", отвечающего за чат в нашем приложении. Каждый "reducer" состоит из:
- констант, содержащих значения для свойства "type" объекта "action"
- "initialState" - своей части "state"
- самой функции "reducer"
- "Action Creators" или "AC"
- "Thunk Creators" или "TC".
*/

import {chatAPI, SubscriberType} from '../api/chat-api' /*Импортируем API для работы с WebSocket-каналом нашего сервера с целью
реализации чата в нашем приложении. Также подключаем типы оттуда.*/

import {FormAction} from 'redux-form'; /*Импортируем специальный AC "stopSubmit" из библиотеки "redux-form", который
сообщает UI, что что-то пошло не так, и останавливает "submit" данных в форме. Импортировали "FormAction", чтобы создать
тип для объектов "action", который передается в "thunks" и TC.*/

import {InferActionsTypes, BaseThunkType} from './redux-store'; /*Подключаем типы.*/
import {ChatMessageType} from '../types/types'; /*Подключаем типы.*/
import {Dispatch} from 'redux'; /*Импортировали "Dispatch" из библиотеки "redux", чтобы создать тип для "dispatch",
который передается в "thunks" и TC.*/


/*Создаем тип "state" из самого "state" при помощи "typeof".*/
type InitialChatStateType = typeof initialState;

/*Создаем сам "state".*/
let initialState = {
    chatMessages: [] as ChatMessageType[] /*Свойство для хранения сообщений из чата для вывода их в нашем приложении.
    Должно быть массивом элементов с типом "ChatMessageType", который был создан нами и импортирован сюда.*/
};


/*
Это "reducer" - чистая функция, которая принимает объект "action" и копию части "state".
Потом "reducer" изменяет (или не изменяет, если объект "action" не подошел) определенную часть "state" и возвращает ее.
После этого все возвращенные части "state" всех "reducers" собираются в новый "state".
*/
const chatReducer = (state = initialState, action: ActionsType): InitialChatStateType => {
/*Указываем, что тип "state" на выходе имеет тот же тип "InitialChatStateType", что и "state" на входе. На входе объекты
"action" имеют тип "ActionsType", созданный нами ниже.*/
    switch (action.type) {
        case 'demo-spa/chat-reducer/SET-CHAT-MESSAGES': /*Устанавливаем информацию о сообщениях из чата.*/
            return { /*Устанавливаем информацию о сообщениях из чата в "state".*/
                ...state, /*Делаем поверхностную копию "state".*/
                chatMessages: [...state.chatMessages, ...action.chatMessages] /*Делаем глубокую копию "state".
                Дописываем (то есть не затираем старую информацию) информацию о новых сообщениях из чата в "state".*/
            };

        case 'demo-spa/chat-reducer/CLEAR-CHAT-MESSAGES': /*Обнуляем информацию о сообщениях из чата.*/
            return { /*Обнуляем информацию о сообщениях из чата в "state".*/
                ...state, /*Делаем поверхностную копию "state".*/
                chatMessages: [] /*Обнуляем информацию о сообщениях из чата в "state".*/
            };

        default: /*Если объект "action" никуда не подошел, то по default возвращается тот же "state", чтобы не вызвать
        перерисовку.*/
            return state;
    }
};


/*Создаем типы для объектов "action".*/
type ActionsType = InferActionsTypes<typeof chatAC>; /*Здесь мы все созданные раннее типы для объектов "action"
объеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип "InferActionsTypes" для
определения типов всех объектов "action" у упакованных в единый объект "chatAC" AC.*/


/*
Action Creators.
AC создает объект, который передается в reducer.
Этот объект как минимум должен иметь свойство "type", которое определяет, что необходимо выполнить в reducer.
*/
export const chatAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные
раннее на основе каждого AC. Также вверху удалили все константы со значениями для "type" и указывываем их сразу в AC,
так как "TypeScript" не даст нам допустить ошибку при указании этих "types" в "reducer". Согласно модульному паттерну
"Redux Ducks", чтобы избежать случаев одиноковых значений свойств "type" из-за чего один и тот же объект "action" может
сработать в нескольких "reducers", в значениях свойств "type" в объекте "action" указываются
"имя-проекта/имя-файла/имя-объекта-action". Также в конце везде добавили "as const", чтобы "reducer" адекватно
воспринимал объекты "action". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных
типов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/
    setChatMessages: (chatMessages: ChatMessageType[]) => ({ /*AC для установки сообщений для чата в "state".*/
        type: 'demo-spa/chat-reducer/SET-CHAT-MESSAGES', /*Обязательно свойство "type" для AC.*/
        chatMessages /*Это равносильно "chatMessages: chatMessages". Создаем свойство, которое содержит информацию о
        сообщениях для чата.*/
    } as const),

    clearChatMessages: () => ({ /*AC для обнуления сообщений для чата в "state".*/
        type: 'demo-spa/chat-reducer/CLEAR-CHAT-MESSAGES' /*Обязательно свойство "type" для AC.*/
    } as const)
};


/*Создаем типы для "Thunk Creators".*/
type ThunkType = BaseThunkType<ActionsType | FormAction>; /*Создали тип для "thunks". Поскольку в TC
"login" мы диспатчим "stopSubmit" из библиотеки "redux-form", поэтому здесь мы указали еще "FormAction" из библиотеки
"redux-form", так как в файле декларации "stopSubmit" указано, что он "extends" от "FormAction". Но из-за этого теперь
мы можем диспатчить любой объект "action", что естественно нежелательно для нас.*/


/*
Thunk creators.
"Thunk" это функция, которая может выполнять AJAX-запросы и "dispatch".
Поскольку "reducers" нужны объекты "action" и "reducers" работают синхронно (AJAX-запросы несинхронные, поэтому будут
замедлять этот процесс),
а также "reducers" являются чистыми функциями, то мы не можем напрямую диспатчить "thunk".
В таком случае, "thunk" должен сначала сам запуститься, внутри него задиспатчаться объекты "action" и
в дальнейшем будут раскиданы по "reducers".
В параметрах "thunk" всегда приходит функция "dispatch".
"store" из "Redux" запускает "thunk" и закидывает в него функцию "dispatch" потому, что она у него есть.
Но, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в "thunk" нам нужно
использовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то
дополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет
доступ к данным 1-й функции. Этой 1-й родительской функцией является "Thunk creator" (по аналогии с "Action creator").
В TC передается текст сообщения, а сам "thunk" возьмет это сообщения из замыкания. В итоге мы диспатчм "TC",
а не сам "thunk". Также для этого нам нужен некий промежуточный слой "thunk middleware" между "store.dispatch" и
"reducers". Если в "store" придет объект "action", то "thunk middleware" передаст его в "reducers". Если же в "store"
придет "thunk", то "thunk middleware" запустить этот "thunk", закинет в него функцию "dispatch" и на выходе будет
объект "action", который затем будет передан в "reducers". Если в "thunk" будет несколько AC, то сначала отправится
первый AC в "thunk middleware", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть
замыкание. Для установки "thunk middleware" нам нужна библиотека "redux-thunk". Установка происходит в файле со "store"
из "redux". В TC мы диспатчим не сам AC, а их вызовы.
*/
let _newChatMessagesHandler: SubscriberType | null = null; /*Создаем вспомогательную функцию "_newChatMessagesHandler",
которая будет хранить в себе функцию перехватчика сообщений для чата по WebSocket-каналу. Такая функция должна быть типа
"SubscriberType", который был создан нами и импортирован сюда, или "null", то есть отсутствовать.*/

const newChatMessagesHandlerCreator = (dispatch: Dispatch) => { /*Создаем еще одну вспомогательную функцию (высшего
порядка), которая будет проверять есть ли у нас уже перехватчик сообщений для чата, и если нет, то будет присваивать и
возвращать такой перехватчик, который будет получать сообщения для чата и устанавливать их в "state" при помощи AC
"setChatMessages". Здесь нам нужна указанная проверка, так как мы вызываем эту функцию в нескольких местах (при подписке
и отписке), поэтому получаем одну и туже функцию несколько раз, соотвественно если уже есть перехватчик сообщений для
чата, то для исключения упомянутых повторов в таком случае просто возвращаем уже существующий перехватчик сообщений для
чата (типо мемоизация).
*/
    if (_newChatMessagesHandler === null) {
        _newChatMessagesHandler = (chatMessages) => {
            dispatch(chatAC.setChatMessages(chatMessages));
        };
    };

    return _newChatMessagesHandler;
};

export const startGettingChatMessages = (): ThunkType => async (dispatch) => {
/*Это TC для инициализации WebSocket-канала и установки информации по сообщениям для чата в "state", которые будут
получаться через этот WebSocket-канал. Здесь вместо использования ".then" мы используем "async/await". Промис будет
ожидаться в "await". "async" делает TC асинхронным. Этот TC на выходе возвращает "thunk", который имеет тип "ThunkType",
созданный нами выше. Мы могли здесь также указать тип "dispatch", "getState()" и дополнительных аргументов, но типизируя
то, что возвращает TC, то есть "thunk", мы также типизировали, что в "thunk" будет передаваться дальше, то есть те самые
"dispatch", "getState()" и дополнительные аргументы.*/
    chatAPI.startWSChannel(); /*Инициализируем WebSocket-канал для получения сообщений для чата.*/

    chatAPI.subscribe(newChatMessagesHandlerCreator(dispatch)); /*Подписываем функцию "newChatMessagesHandlerCreator"
    на получение новых сообщений для чата, передав в нее функцию "dispatch", необходимую ей для ее внутренней работы.*/
};

/*const unsubscribe = chatAPI.subscribe(newChatMessagesHandlerCreator);*/ /*Это еще одна реализации отписки, продолжение
ниже в TC "stopGettingChatMessages".*/

export const stopGettingChatMessages = (): ThunkType => async (dispatch) => {
/*Это TC для закрытия WebSocket-канала и остановки получения информации по сообщениям для чата, которые получались через
этот WebSocket-канал. Здесь вместо использования ".then" мы используем "async/await". Промис будет ожидаться в "await".
"async" делает TC асинхронным. Этот TC на выходе возвращает "thunk", который имеет тип "ThunkType", созданный нами выше.
Мы могли здесь также указать тип "dispatch", "getState()" и дополнительных аргументов, но типизируя то, что возвращает
TC, то есть "thunk", мы также типизировали, что в "thunk" будет передаваться дальше, то есть те самые "dispatch",
"getState()" и дополнительные аргументы.*/
    chatAPI.stopWSChannel(); /*Закрываем WebSocket-канал, чтобы прекратить получение сообщений для чата.*/

    chatAPI.unsubscribe(newChatMessagesHandlerCreator(dispatch)); /*Отписываем функцию "newChatMessagesHandlerCreator"
    от получения новых сообщений для чата, передав в нее функцию "dispatch", необходимую ей для ее внутренней работы.*/

    dispatch(chatAC.clearChatMessages()); /*Обнуляем информацию о сообщениях из чата в "state", чтобы не получить
    несколько копий сообщений в чате на случай если мы потом переподключимся к WebSocket-каналу.*/

    /*unsubscribe();*/ /*Продолжение еще одной реализации отписки.*/
};

export const sendChatMessage = (chatMessage: string): ThunkType => async (dispatch) => {
/*Это TC для отправки сообщений в чат по WebSocket-каналу. На входе получает сообщение для чата, которое должно быть
строкой. Здесь вместо использования ".then" мы используем "async/await". Промис будет ожидаться в "await". "async"
делает TC асинхронным. Этот TC на выходе возвращает "thunk", который имеет тип "ThunkType", созданный нами выше. Мы
могли здесь также указать тип "dispatch", "getState()" и  дополнительных аргументов, но типизируя то, что возвращает TC,
то есть "thunk", мы также типизировали, что в  "thunk" будет передаваться дальше, то есть те самые "dispatch",
"getState()" и дополнительные аргументы.*/
    chatAPI.sendChatMessage(chatMessage); /*Отправляем наше сообщение в чат.*/
};


export default chatReducer; /*Экспортируем "chatReducer" по default и будем его использовать в нашем проекте под
именем "authReducer", экспорт необходим для импорта.*/