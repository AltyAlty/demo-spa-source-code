/*Refs дают возможность получить доступ к DOM-узлам или React-элементам. Ситуациями, когда использование рефов
оправдано, являются управление фокусом, выделение текста, воспроизведение медиа, императивный вызов анимаций, интеграция
со сторонними DOM-библиотеками. Рефы прикрепляются к React-элементам через атрибут "ref".

Хук "useRef()" возвращает изменяемый ref-объект, свойство "current" которого инициализируется переданным аргументом, то
есть "initialValue". Возвращенный объект будет сохраняться в течение всего времени жизни компонента.*/
import React, {useEffect, useRef, useState} from 'react';
import {useSelector} from 'react-redux';
/*Импортируем селектор "getChatMessages()".*/
import {getChatMessages} from '../../../../redux/chat-selectors';
import styles from '../../ChatPage.module.css';
/*Импортируем компонент "ChatMessage".*/
import {ChatMessage} from './ChatMessage/ChatMessage';

/*"ChatMessages" это функциональный компонент, который создан в виде стрелочной функции. "ChatMessages" является
компонентом, который отображает сообщения чата.

Внутри компонента "ChatMessages" используются следующие компоненты:
1. "ChatMessage" - компонент, который отвечает за типовое отображение сообщения в чате. Импортирован.

Компонент "ChatMessages" импортируется в файле "Chat.tsx".*/
export const ChatMessages: React.FC = () => {
    /*При помощи хука "useSelector()", передав в него селектор "getChatMessages()", получаем информацию о сообщениях из
    чата для вывода их в нашем приложении.*/
    const chatMessages = useSelector(getChatMessages);
    /*При помощи хука "useRef()" создаем реф типа "HTMLDivElement", то есть элемент "div", который изначально равен
    null.*/
    const chatMessagesAnchorRef = useRef<HTMLDivElement>(null);
    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый
    элемент из хука "useState()", этот элемент будет означать активна ли автопрокрутка чата в какой-то момент или нет
    (изначально активна). Вторая переменная будет хранить функцию из хука "useState()", которая будет изменять первый
    элемент (то есть указывать активна ли автопрокрутка чата в какой-то момент или нет).*/
    const [isAutoScrollActive, setAutoScroll] = useState<boolean>(true);

    /*Создаем специальную callback-функцию, которая будет вызываться снизу в корневом элементе "div" при срабатывании
    события "onScroll", то есть в момент прокрутки нашего чата. На входе принимает событие типа
    "React.UIEvent<HTMLDivElement, UIEvent>".*/
    const scrollEventHandler = (event: React.UIEvent<HTMLDivElement, UIEvent>) => {
        /*Получаем свойство "currentTarget" полученного события.*/
        const element = event.currentTarget;

        /*Свойство "scrollHeight" это измерение высоты контента в элементе, включая содержимое, невидимое из-за
        прокрутки. Значение свойства "scrollHeight" равно минимальному значению свойства "clientHeight", которое
        потребуется элементу для того, чтобы поместить все содержимое в видимую область, не используя вертикальную
        полосу прокрутки. Оно включает в себя "padding" элемента, но не его "margin".

        Свойство "scrollTop" считывает или устанавливает количество пикселей, прокрученных от верха элемента. Свойство
        "scrollTop" измеряет дистанцию от верха элемента до верхней точки видимого контента. Когда контент элемента не
        создает вертикальную прокрутку, его свойство "scrollTop" равно 0.

        Свойство "clientHeight" - это свойство, доступное только для чтения. Для элементов без CSS-стилей, или элементов
        каркаса строчной разметки - значение равно 0. Для остальных элементов - значение равно внутренней высоте
        элемента в пикселях, включая пространство между содержимым элемента и его границей ("padding"), но исключая
        высоту полосы горизонтальной прокрутки, и ширину отступа от границы элемента до родительского элемента
        ("margin"). Значение свойства "clientHeight" может быть вычислено по формуле:
        "CSS height" + "CSS padding" - "высота горизонтального скролла (если присутствует)".

        Здесь мы сначала высчитываем высоту того, что ниже верхней границы контента, который мы видим в чате, по модулю
        при помощи функции "Math.abs()". Далее вычисляем высоту контента, находящийся ниже нижней границы контента,
        который мы видим в чате. И если это полученное значение меньше 200 пикселей и автопрокрутка чата отключена, то
        мы включаем автопрокрутку. Если же полученное значение больше 200 пикселей и автопрокрутка чата включена, то мы
        выключаем автопрокрутку, чтобы чат постоянно не прокручивался вниз, когда мы что-то читаем сверху чата.*/
        if (Math.abs((element.scrollHeight - element.scrollTop) - element.clientHeight) < 200) {
            !isAutoScrollActive && setAutoScroll(true);
        } else {
            isAutoScrollActive && setAutoScroll(false);
        }
    };

    /*Используем хук "useEffect()", чтобы при получении новых сообщений автоматически прокручивать вниз, чтобы было
    видно новое сообщение.*/
    useEffect(() => {
            /*Метод "scrollIntoView()" прокручивает текущий контейнер родителя элемента так, чтобы этот элемент, на
            котором был вызван метод "scrollIntoView()" был видим пользователю. Если автопрокрутка включена, то у рефа
            "chatMessagesAnchorRef" вызывается метод "scrollIntoView()", чтобы чат прокручивался до элемента с этим
            рефом. Параметр "behavior" в данном случае определяет плавную анимацию прокрутки.*/
            if (isAutoScrollActive) chatMessagesAnchorRef.current?.scrollIntoView({behavior: 'smooth'});
        },
        /*Второй параметр это сообщения для чата из глобального state. Если эти данные будут меняться, то будет
        срабатывать каждый раз все то, что указано в первом параметре.*/
        [chatMessages]
    );

    return (
        <div className={styles.chatMessages} onScroll={scrollEventHandler}>
            {/*Мапим массив с сообщениями из чата, чтобы в итоге отрисовать каждое сообщение, используя компонент
            "ChatMessage". Внутрь этого компонента передаем информацию о сообщении через атрибут "chatMessage".*/}
            {chatMessages.map((m, index) => <ChatMessage key={m.id} chatMessage={m}/>)}
            {/*После всех сообщений чата отрисовываем специальный элемент "div", который содержит атрибут "ref". Это нам
            нужно, чтобы реализовать прокрутку в самый низ чата.*/}
            <div ref={chatMessagesAnchorRef}></div>
        </div>
    )
};