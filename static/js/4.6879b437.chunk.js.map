{"version":3,"sources":["components/Dialogs/Dialogs.module.css","hoc/WithAuthRedirect.tsx","components/Dialogs/DialogItem/DialogItem.tsx","components/Dialogs/Message/Message.tsx","components/Dialogs/IncomingMessage/IncomingMessage.tsx","components/Dialogs/Dialogs.tsx","components/Dialogs/DialogsContainer.tsx"],"names":["module","exports","mapStateToPropsForRedirect","state","isAuth","auth","withAuthRedirect","Component","connect","props","restProps","to","DialogItem","id","name","avatar","path","className","styles","dialog","src","alt","activeClassName","active","Message","message","IncomingMessage","incomingMessage","maxLength10","maxLengthCreator","AddMessageReduxForm","reduxForm","form","handleSubmit","onSubmit","createField","Textarea","required","compose","dialogsPage","addMessage","dialogsAC","dialogsElements","dialogs","map","d","messagesElements","messagesData","m","incomingMessagesElement","incomingMessagesData","im","dialogsItems","messages","formData","newMessageText","incomingMessages"],"mappings":"qGACAA,EAAOC,QAAU,CAAC,QAAU,yBAAyB,aAAe,8BAA8B,OAAS,wBAAwB,OAAS,wBAAwB,SAAW,0BAA0B,iBAAmB,kCAAkC,QAAU,yBAAyB,gBAAkB,mC,kICc7SC,EAA6B,SAACC,GAAD,MAA0D,CAEzFC,OAAQD,EAAME,KAAKD,SAiBhB,SAASE,EAA+BC,GAgC3C,OAAOC,YACNN,EADMM,EAtBP,SAA2BC,GAGvB,IAAOL,EAAwBK,EAAxBL,OAAWM,EAAlB,YAA+BD,EAA/B,GAIA,OAAKL,EAKE,cAACG,EAAD,eAAeG,IALF,cAAC,IAAD,CAAUC,GAAI,iB,sHC3B7BC,EAAkC,SAAC,GAAwB,IAAvBC,EAAsB,EAAtBA,GAAIC,EAAkB,EAAlBA,KAAMC,EAAY,EAAZA,OAEnDC,EAAO,YAAcH,EAEzB,OAGI,cAFA,CAEA,OAAKI,UAAWC,IAAOC,OAAvB,UAEI,qBAAKC,IAAKL,EAAQM,IAAI,KAGtB,cAAC,IAAD,CAASV,GAAIK,EAAMM,gBAAiBJ,IAAOK,OAA3C,SAAoDT,QCdnDU,EAA+B,SAAC,GAAuB,IAAtBC,EAAqB,EAArBA,QAASV,EAAY,EAAZA,OACnD,OAGI,cAFA,CAEA,OAAKE,UAAWC,IAAOO,QAAvB,UAEI,qBAAKL,IAAKL,EAAQM,IAAI,MAErBI,MCPAC,EAAuC,SAAC,GAAuB,IAAtBD,EAAqB,EAArBA,QAASV,EAAY,EAAZA,OAC3D,OAGI,cAFA,CAEA,OAAKE,UAAWC,IAAOS,gBAAvB,UAEKF,EAED,qBAAKL,IAAKL,EAAQM,IAAI,U,gBCkC5BO,EAAcC,YAAiB,IAgF/BC,EAAsBC,YAAgE,CAExFC,KAAM,wBAFkBD,EA3CxB,SAAC,GAAoB,IAAnBE,EAAkB,EAAlBA,aACE,OAEI,cADA,CACA,QAAMC,SAAUD,EAAhB,UAGI,8BAIKE,YACG,qBACA,iBACAC,IACA,CAACC,IAAUT,MAMnB,8BACI,yD,SCnELU,sBAKX9B,aAlCoB,SAACL,GACrB,MAAO,CAACoC,YAAapC,EAAMoC,eAmCvB,CAACC,WAAYC,IAAUD,aAG3BlC,IAVWgC,ED6GoC,SAAC,GAA+B,IAA9BC,EAA6B,EAA7BA,YAAaC,EAAgB,EAAhBA,WAExDE,EAAkBH,EAAYI,QAAQC,KAAI,SAAAC,GAAC,OAAI,cAAC,EAAD,CAAY/B,KAAM+B,EAAE/B,KACRD,GAAIgC,EAAEhC,GACNE,OAAQ8B,EAAE9B,QACL8B,EAAEhC,OAGlEiC,EAAmBP,EAAYQ,aAAaH,KAAI,SAAAI,GAAC,OAAI,cAAC,EAAD,CAASnC,GAAImC,EAAEnC,GACNY,QAASuB,EAAEvB,QACXV,OAAQiC,EAAEjC,QACLiC,EAAEnC,OAGrEoC,EAA0BV,EAAYW,qBAAqBN,KAAI,SAAAO,GAAE,OAAI,cAAC,EAAD,CAAiBtC,GAAIsC,EAAGtC,GACPY,QAAS0B,EAAG1B,QACZV,OAAQoC,EAAGpC,QACNoC,EAAGtC,OAapG,OACI,sBAAKI,UAAWC,IAAOyB,QAAvB,UAEI,qBAAK1B,UAAWC,IAAOkC,aAAvB,SAAsCV,IAGtC,sBAAKzB,UAAWC,IAAOmC,SAAvB,UAEI,8BAAMP,IASN,cAAChB,EAAD,CAAqBI,SAxBX,SAACoB,GAEnBd,EAAWc,EAASC,gBAEpBD,EAASC,eAAiB,SAwBtB,qBAAKtC,UAAWC,IAAOsC,iBAAvB,SAA0CP","file":"static/js/4.6879b437.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"dialogs\":\"Dialogs_dialogs__3amLP\",\"dialogsItems\":\"Dialogs_dialogsItems__7CGoa\",\"active\":\"Dialogs_active__1_RCy\",\"dialog\":\"Dialogs_dialog__2j5iP\",\"messages\":\"Dialogs_messages__2q7fz\",\"incomingMessages\":\"Dialogs_incomingMessages__3i9AD\",\"message\":\"Dialogs_message__1iLAx\",\"incomingMessage\":\"Dialogs_incomingMessage__hw21f\"};","import React, {ComponentType} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {Redirect} from 'react-router-dom';\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from '../redux/redux-store';\r\n\r\n/*Создаем тип для функции \"mapStateToPropsForRedirect()\".*/\r\ntype MapStateToPropsForRedirectType = {\r\n    /*Свойство, которое указывает залогинен ли пользователь, должно быть булева типа.*/\r\n    isAuth: boolean\r\n};\r\n\r\n/*Здесь мы таким образом создаем props необходимые для работы редиректа. Будем их подключать при помощи функции\r\n\"connect()\". На входе функция \"mapStateToPropsForRedirect()\" принимает state с типом \"AppStateType\", а на выходе выдает\r\nданные с типом \"MapStateToPropsForRedirectType\".*/\r\nconst mapStateToPropsForRedirect = (state: AppStateType): MapStateToPropsForRedirectType => ({\r\n    /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    isAuth: state.auth.isAuth\r\n});\r\n\r\n/*HOC \"withAuthRedirect()\" - это HOC, который добавляет редирект в наш проект.\r\n\r\nЭтот HOC, в качестве параметра принимает какой-либо компонент \"Component\". Не используем здесь синтаксис стрелочной\r\nфункции, чтобы можно было уточнить props как \"WrappedProps\", как мы это сделали здесь. Этот HOC принимает какой-то\r\ngeneric компонент \"Component\", который ожидает props c типом \"WrappedProps\".\r\n\r\nКомпонент \"Component\" должен быть типа \"ComponentType\", то есть быть каким-то компонентом из React.\r\n\r\nУточняем, что внутри ожидаются props c типом \"WrappedProps\", то есть те же props компонента \"Component\", который мы\r\nбудем передавать в этот HOC, так как наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\".\r\nНо при этом наш HOC будет использовать свойство \"isAuth\" из функции \"mapStateToPropsForRedirect()\" для своей внутренней\r\nработы.\r\n\r\nHOC \"withAuthRedirect()\" импортируется в файлах \"DialogsContainer.tsx\" и \"ChatPage.tsx\".*/\r\nexport function withAuthRedirect<WrappedProps>(Component: ComponentType<WrappedProps>) {\r\n    /*После получения компонента \"Component\" в качестве параметра, создается другой функциональный компонент\r\n    \"RedirectComponent\". Это обертка для компонента \"Component\", поэтому props компонента \"RedirectComponent\" должны\r\n    быть типа \"WrappedProps\", так как эти props должны не потеряться и быть переданы в компонент \"Component\", и типа\r\n    \"MapStateToPropsForRedirectType\", так как для работы компонента \"RedirectComponent\" необходимо свойство \"isAuth\" из\r\n    функции \"mapStateToPropsForRedirect()\". Но свойство \"isAuth\" мы не должны передавать в компонент \"Component\".\r\n\r\n    Но для функции \"connect()\" и для внутренней работы компонента \"RedirectComponent\" важно знать только props типа\r\n    \"MapStateToPropsForRedirectType\", поэтому в итоге мы убираем \"WrappedProps\" здесь и оставляем только\r\n    \"MapStateToPropsForRedirectType\" в качестве типа для props компонента \"RedirectComponent\".*/\r\n    function RedirectComponent(props: MapStateToPropsForRedirectType) {\r\n        /*Здесь мы выделяем \"props.isAuth\" в переменную \"isAuth\", а остальные свойства props оставляем в объекте\r\n        \"restProps\" при помощи деструктуризации.*/\r\n        const {isAuth, ...restProps} = props;\r\n        /*Внутри этого функционального компонента \"RedirectComponent\" указано, что если пользователь не залогинен, то\r\n        происходит при помощи \"Redirect\" из библиотеки React Router DOM редирект по пути \"/login/\", где находится форма\r\n        для логинизации, вместо отрисовки переданного в HOC компонента \"Component\".*/\r\n        if (!isAuth) return <Redirect to={'/login/'}/>\r\n        /*Если же пользователь оказался залогиненным, то мы попадем в этот return. В этом случае возвращается компонент\r\n        \"Component\", переданный в HOC, при помощи деструктуризации снабженный \"restProps\", которые должны восприниматься\r\n        как props типа \"WrappedProps\", то есть теми же props, что у него были изначально, так как выше мы убрали\r\n        свойство \"isAuth\" из них.*/\r\n        return <Component {...restProps as WrappedProps}/>\r\n    };\r\n\r\n    /*Далее в свою очередь функциональный компонент \"RedirectComponent\" оборачивается при помощи функции \"connect()\",\r\n    чтобы получить необходимые props для проверки залогинен ли пользователь или нет. Метод \"connect()\" вернет итоговый\r\n    компонент. Поскольку функция \"connect()\" является generic, то ее можно уточнить: первым в \"<>\" указан тип для\r\n    функции \"MapStateToProps()\", вторым для функции \"MapDispatchToProps()\", третьим для \"собственных props\" компонента,\r\n    четвертым для state. Эти параметры мы узнали перейдя в файл декларации функции \"connect()\".\r\n\r\n    Сам HOC \"withAuthRedirect()\" в итоге возвращает получившийся итоговый компонент.*/\r\n    return connect<MapStateToPropsForRedirectType, {}, WrappedProps, AppStateType>\r\n    (mapStateToPropsForRedirect)(RedirectComponent);\r\n};","import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\nimport styles from './../Dialogs.module.css';\r\n/*Импортируем тип \"AvatarSourceType\".*/\r\nimport {AvatarSourceType} from '../../../types/types';\r\n\r\ntype PropsType = {\r\n    /*ID диалога должно быть числом.*/\r\n    id: number\r\n    /*Имя, с кем ведется диалог, должно быть строкой.*/\r\n    name: string\r\n    /*Аватар того, с кем ведется диалог, должен быть типа \"AvatarSourceType\".*/\r\n    avatar: AvatarSourceType\r\n};\r\n\r\n/*\"DialogItem\" это функциональный компонент, который создан в виде стрелочной функции. \"DialogItem\" является\r\nкомпонентом, который описывает как должны выглядеть диалоги.\r\n\r\nКомпонент \"DialogItem\" импортируется в файле \"Dialogs.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"id\" - ID диалога.\r\n2. \"name\" - имя, с кем ведется диалог.\r\n3. \"avatar\" - аватар того, с кем ведется диалог.*/\r\nexport const DialogItem: React.FC<PropsType> = ({id, name, avatar}) => {\r\n    /*Путь для компонента \"NavLink\" формируется на основе ID пользователя, который берется из параметров props.*/\r\n    let path = '/dialogs/' + id;\r\n\r\n    return (\r\n        /*Этот элемент представляет собой типовой пункт диалогов, который будет отрисовываться в компоненте \"Dialogs\"\r\n        при помощи метода \"map()\".*/\r\n        <div className={styles.dialog}>\r\n            {/*Пункт диалога содержит аватар пользователя, ссылка на который берется из параметров props.*/}\r\n            <img src={avatar} alt=''/>\r\n            {/*А также пункт диалога содержит компонент \"NavLink\" с именем пользователя, которое берется из параметров\r\n            props.*/}\r\n            <NavLink to={path} activeClassName={styles.active}>{name}</NavLink>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\nimport styles from './../Dialogs.module.css';\r\n/*Импортируем тип \"AvatarSourceType\".*/\r\nimport {AvatarSourceType} from '../../../types/types';\r\n\r\ntype PropsType = {\r\n    /*ID исходящего сообщения должно быть числом. Мы это здесь не используем, но указываем, так как передаем этот ID в\r\n    компоненте \"Dialogs\" в компонент \"Message\" при использовании функции \"map()\".*/\r\n    id: number\r\n    /*Текст исходящего сообщения должно быть строкой.*/\r\n    message: string\r\n    /*Аватар того, от кого отправлено исходящее сообщение, должен быть типа \"AvatarSourceType\".*/\r\n    avatar: AvatarSourceType\r\n};\r\n/*\"Message\" это функциональный компонент, который создан в виде стрелочной функции. \"Message\" является компонентом,\r\nкоторый описывает как должны выглядеть исходящие сообщения.\r\n\r\nКомпонент \"Message\" импортируется в файле \"Dialogs.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"message\" - текст исходящего сообщения.\r\n2. \"avatar\" - аватар того, от кого отправлено исходящее сообщение.*/\r\nexport const Message: React.FC<PropsType> = ({message, avatar}) => {\r\n    return (\r\n        /*Этот элемент представляет собой типовое отображение исходящих сообщений, которое будет отрисовываться в\r\n        компоненте \"Dialogs\" при помощи метода \"map()\".*/\r\n        <div className={styles.message}>\r\n            {/*Исходящее сообщение содержит аватар пользователя, ссылка на который берется из параметров props.*/}\r\n            <img src={avatar} alt=\".\"/>\r\n            {/*Также исходящее сообщение содержит текст этого сообщения, которое берется из параметров props.*/}\r\n            {message}\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\nimport styles from './../Dialogs.module.css';\r\n/*Импортируем тип \"AvatarSourceType\".*/\r\nimport {AvatarSourceType} from '../../../types/types';\r\n\r\ntype PropsType = {\r\n    /*ID входящего сообщения должно быть числом. Мы это здесь не используем, но указываем, так как передаем этот ID в\r\n    компоненте \"Dialogs\" в компонент \"IncomingMessage\" при использовании функции \"map()\".*/\r\n    id: number\r\n    /*Текст исходящего сообщения должно быть строкой.*/\r\n    message: string\r\n    /*Аватар того, от кого отправлено входящее сообщение, должен быть типа \"AvatarSourceType\".*/\r\n    avatar: AvatarSourceType\r\n};\r\n\r\n/*\"IncomingMessage\" это функциональный компонент, который создан в виде стрелочной функции. \"IncomingMessage\" является\r\nкомпонентом, который описывает как должны выглядеть входящие сообщения.\r\n\r\nКомпонент \"IncomingMessage\" импортируется в файле \"Dialogs.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"message\" - текст исходящего сообщения.\r\n2. \"avatar\" - аватар того, от кого отправлено исходящее сообщение.*/\r\nexport const IncomingMessage: React.FC<PropsType> = ({message, avatar}) => {\r\n    return (\r\n        /*Этот элемент представляет собой типовое отображение входящих сообщений, которое будет отрисовываться в\r\n        компоненте \"Dialogs\" при помощи метода \"map()\".*/\r\n        <div className={styles.incomingMessage}>\r\n            {/*Исходящее сообщение содержит текст этого сообщения, которое берется из параметров props.*/}\r\n            {message}\r\n            {/*Также исходящее сообщение содержит аватар пользователя, ссылка на который берется из параметров props.*/}\r\n            <img src={avatar} alt='.'/>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\n/*В данном файле работа с библиотекой Redux Form происходит следующим образом:\r\n1. callback-функция \"handleSubmit()\" указана в компоненте \"AddMessageForm\".\r\n2. оборачиваем компонент \"AddMessageForm\" функцией \"reduxForm()\" в компоненте \"AddMessageReduxForm\", тем самым\r\nпредоставляя callback-функцию \"handleSubmit()\" для компонента \"AddMessageForm\".\r\n3. компонент \"AddMessageReduxForm\" указывается в компоненте \"Dialogs\", куда в событие \"onSubmit\" будет попадать объект\r\nс данными, сформированный в событии \"onSubmit\" при помощи callback-функции \"handleSubmit()\" в компоненте\r\n\"AddMessageForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback-функция \"handleSubmit()\" в компоненте\r\n\"AddMessageForm\", которая собирает все данные из формы и помещает их в объект. Потом внутри callback-функции\r\n\"handleSubmit()\" вызывается нами созданная callback-функция \"addNewMessage()\" (доступна из контейнерного компонента\r\n\"AddMessageReduxForm\") из компонента \"Dialogs\". В компонент \"Dialogs\" передается указанный объект с данными и собираются\r\nв одном месте, потом эти данные передаются в компонент \"AddMessageReduxForm\", из которого перенаправляются в глобальный\r\nstate в виде объекта под именем \"dialogAddMessageForm\".\r\n\r\nВ компонент \"AddMessageForm\" внедряются некие дополнительные props (например, та же callback-функция \"handleSubmit()\")\r\nХОКом, который образуется при помощи компонента \"AddMessageReduxForm\". Эти props содержатся под именем\r\n\"InjectedFormProps\". Эти \"InjectedFormProps\" также содержат добавленные нами props. Поэтому мы импортировали\r\n\"InjectedFormProps\" из библиотеки Redux Form, чтобы типизировать такие props в компоненте \"AddMessageForm\".*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\nimport styles from './Dialogs.module.css';\r\n/*Импортируем компонент \"DialogItem\".*/\r\nimport {DialogItem} from './DialogItem/DialogItem';\r\n/*Импортируем компонент \"Message\".*/\r\nimport {Message} from './Message/Message';\r\n/*Импортируем компонент \"IncomingMessage\".*/\r\nimport {IncomingMessage} from './IncomingMessage/IncomingMessage';\r\n/*Импортируем созданный нами компонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию.\r\nТакже импортируем функцию \"createField()\", которая принимает параметры и создает элементы формы. Мы ее используем для\r\nсоздания формы в компоненте \"AddMessageForm\". Дополнительно импортируем оттуда тип \"GetValuesKeysType\".*/\r\nimport {createField, GetValuesKeysType, Textarea} from '../common/FormsControls/FormsControls';\r\n/*Импортируем валидаторы для полей форм.*/\r\nimport {maxLengthCreator, required} from '../../utils/validators/validators';\r\n/*Импортируем тип \"InitialDialogsStateType\".*/\r\nimport {InitialDialogsStateType} from '../../redux/dialogs-reducer';\r\n\r\n/*Создаем общий тип для всех props компонента \"Dialogs\".*/\r\ntype DialogsPropsType = {\r\n    /*Поскольку передаем в этот компонент весь state из файла \"dialogs-reducer.ts\", то указываем тип\r\n    \"InitialDialogsStateType\" - это тип всего этого state.*/\r\n    dialogsPage: InitialDialogsStateType\r\n    /*AC для добавления нового исходящего сообщения, который принимает строковой параметр и ничего не возвращает.*/\r\n    addMessage: (newMessageText: string) => void\r\n};\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"AddMessageForm\". Указываем пустой объект, так как компонент\r\n\"AddMessageForm\" не содержит \"собственных props\". По идее это можно в данном случае вообще не указывать.*/\r\ntype AddMessageFormOwnPropsType = {};\r\n\r\n/*Создаем тип для props компонента \"AddMessageForm\", которые будут использоваться в \"formData\" для компонента\r\n\"Dialogs\".*/\r\ntype AddMessageFormValuesType = {\r\n    /*Текст исходящего сообщения, который должен быть строкой.*/\r\n    newMessageText: string\r\n};\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибок при указании свойства \"name\" в функции\r\n\"createField()\". Это свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы\r\nиспользуем сюда вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"AddMessageFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"AddMessageFormValuesType\".*/\r\ntype AddMessageFormValuesKeysType = GetValuesKeysType<AddMessageFormValuesType>;\r\n\r\n/*Создали валидатор, который проверяет не введено ли больше 10 символов в поле.*/\r\nconst maxLength10 = maxLengthCreator(10);\r\n\r\n/*\"AddMessageForm\" это функциональный компонент, который создан в виде стрелочной функции. \"AddMessageForm\" является\r\nкомпонентом, который представляет собой форму для добавления исходящих сообщений в диалогах в виде заготовки для\r\nоборачивания ее функцией \"reduxForm()\".\r\n\r\nВнутри компонента \"AddMessageForm\" используются следующие компоненты:\r\n1. \"Textarea\" - компонент, который используется для отрисовки элементов \"textarea\" в других местах, где в таких\r\nэлементах требуется валидация. Импортирован.\r\n\r\nКомпонент \"AddMessageForm\" используется в компоненте \"AddMessageReduxForm\" в этом же файле и оборачивается функцией\r\n\"reduxForm()\", тем самым получая callback-функцию \"handleSubmit()\".\r\n\r\nУказываем при помощи \"React.FC<>\", что props в этом функциональном компоненте имеют тип\r\n\"InjectedFormProps<AddMessageFormValuesType, AddMessageFormOwnPropsType> & AddMessageFormOwnPropsType>\".\r\n\r\nТакая комбинация получилась следующим образом:\r\n1. \"InjectedFormProps<AddMessageFormValuesType, AddMessageFormOwnPropsType>\" - здесь мы уточняем внедренные ХОКом,\r\nкоторый образуется при помощи компонента \"AddMessageReduxForm\", \"InjectedFormProps\". \"AddMessageFormValuesType\"\r\nуказывает, что приходит из этого ХОКа, а \"AddMessageFormOwnPropsType\" указывает, что приходит со стороны - в нашем\r\nслучае ничего.\r\n2. \"& AddMessageFormOwnPropsType\" - также этот компонент содержит некие свои \"собственные props\", которые не приходят от\r\nХОКа выше.\r\n\r\nЭто мы делаем на основании файла декларации \"InjectedFormProps\". Там указано, что первым параметром принимаются\r\n\"formData\" - то есть какие именно данные собирает форма в компоненте, оборачиваемый функцией \"reduxForm()\" (то есть\r\nкомпонент \"AddMessageForm\"), и \"собственные props\" этого компонента \"AddMessageForm\", непреходящие от ХОКа выше (так\r\nнужно для внутренней работы \"InjectedFormProps\"). А вторым параметром принимаются еще раз некие свои \"собственные\r\nprops\", которые не приходят от ХОКа выше (так уже надо для работы самого этого компонента \"AddMessageForm\"). Третьим\r\nпараметром принимается вид ошибки формы с типом строки, но в данном случае мы этого не указываем.\r\n\r\nТолько все эти три параметра указываются как бы вместе как единый параметр, а не через запятую как три разных параметра.\r\nВОЗМОЖНО, это потому, что \"InjectedFormProps\" является объектом (как единое целое состоит из разных свойств, которые\r\nможно типизировать суммой разных типов), а та же функция \"reduxForm()\" является функцией (принимает последовательность\r\nпараметров, где каждый параметр нужно отдельно типизировать).*/\r\nconst AddMessageForm:\r\n    React.FC<InjectedFormProps<AddMessageFormValuesType, AddMessageFormOwnPropsType> & AddMessageFormOwnPropsType> =\r\n    ({handleSubmit}) => {\r\n        return (\r\n            /*Здесь в элементе \"form\" в событии \"onSubmit\" указываем callback-функцию \"handleSubmit()\".*/\r\n            <form onSubmit={handleSubmit}>\r\n                {/*Создаем элемент \"div\", в котором создаем поле для ввода текста исходящего сообщения при помощи\r\n                импортированной функции \"createField()\".*/}\r\n                <div>\r\n                    {/*Создаем поле для ввода исходящего сообщения на основе импортированной функции \"createField()\".\r\n                    Уточняем здесь функцию \"createField()\", что она имеет тип \"AddMessageFormValuesKeysType\", созданный\r\n                    нами выше.*/}\r\n                    {createField<AddMessageFormValuesKeysType>(\r\n                        'Enter your message',\r\n                        'newMessageText',\r\n                        Textarea,\r\n                        [required, maxLength10]\r\n                    )}\r\n                </div>\r\n\r\n                {/*Создаем специальный элемент \"div\", внутри которого будет находиться элемент \"button\", используемый\r\n                как кнопка для сабмита данных введенных в форму.*/}\r\n                <div>\r\n                    <button>Add message</button>\r\n                </div>\r\n            </form>\r\n        )\r\n    };\r\n\r\n/*Компонент \"AddMessageReduxForm\" является отдельным контейнерным компонентом, цель которого в этом же файле обернуть\r\nкомпонент \"AddMessageForm\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\". Именно\r\nкомпонент \"AddMessageReduxForm\" будет заниматься общением с глобальным state.\r\n\r\nВнутри компонента \"AddMessageReduxForm\" используются следующие компоненты:\r\n1. \"AddMessageForm\" - компонент, который представляет собой форму для добавления исходящих сообщений в диалогах в виде\r\nзаготовки для оборачивания ее функцией \"reduxForm()\". Из этого же файла.\r\n\r\nКомпонент \"AddMessageReduxForm\" используется в компоненте \"Dialogs\" в этом же файле.\r\n\r\nФункция \"reduxForm()\" является generic, поэтому мы ее уточняем. В файле декларации функции \"reduxForm()\" указано, что\r\nон принимает следующие данные:\r\n1. \"formData\" - какие именно данные собирает форма в компоненте (то есть в компоненте \"AddMessageForm\"), оборачиваемым\r\nфункцией \"reduxForm()\";\r\n2. \"собственные props\" компонента (то есть компонента \"AddMessageForm\"), которого оборачиваем функцией \"reduxForm()\";\r\n3. вид ошибки формы с типом строки, но в данном случае мы этого не указываем.*/\r\nconst AddMessageReduxForm = reduxForm<AddMessageFormValuesType, AddMessageFormOwnPropsType>({\r\n    /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный state.*/\r\n    form: 'dialogAddMessageForm'\r\n})(AddMessageForm);\r\n\r\n/*\"Dialogs\" это функциональный компонент, который создан в виде стрелочной функции. \"Dialogs\" является компонентом,\r\nкоторый отображает диалоги.\r\n\r\nВнутри компонента \"Dialogs\" используются следующие компоненты:\r\n1. \"DialogItem\" - компонент, который описывает как должны выглядеть диалоги. Импортирован.\r\n2. \"Message\" - компонент, который описывает как должны выглядеть исходящие сообщения.\r\n3. \"IncomingMessage\" - компонент, который описывает как должны выглядеть входящие сообщения.\r\n4. \"AddMessageReduxForm\" - отдельный контейнерный компонентом, цель которого в этом же файле обернуть компонент\r\n\"AddMessageForm\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\". Из этого же файла.\r\n\r\nКомпонент \"Dialogs\" импортируется в файле \"DialogsContainer.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"dialogsPage\" - весь state из файла \"dialogs-reducer.ts\".\r\n2. \"addMessage\" - AC для добавления нового исходящего сообщения.*/\r\nexport const Dialogs: React.FC<DialogsPropsType> = ({dialogsPage, addMessage}) => {\r\n    /*Массив \"dialogsElements\" содержит диалоги пользователя.*/\r\n    const dialogsElements = dialogsPage.dialogs.map(d => <DialogItem name={d.name}\r\n                                                                     id={d.id}\r\n                                                                     avatar={d.avatar}\r\n                                                                     key={d.id}/>);\r\n\r\n    /*Массив \"messagesElements\" содержит исходящие сообщения пользователя.*/\r\n    const messagesElements = dialogsPage.messagesData.map(m => <Message id={m.id}\r\n                                                                        message={m.message}\r\n                                                                        avatar={m.avatar}\r\n                                                                        key={m.id}/>);\r\n\r\n    /*Массив \"incomingMessagesElement\" содержит входящие сообщения пользователя.*/\r\n    const incomingMessagesElement = dialogsPage.incomingMessagesData.map(im => <IncomingMessage id={im.id}\r\n                                                                                                message={im.message}\r\n                                                                                                avatar={im.avatar}\r\n                                                                                                key={im.id}/>);\r\n\r\n    /*Создаем специальную callback-функцию \"addNewMessage()\", которая будет вызываться при срабатывании события\r\n    \"onSubmit\" в форме. Эта callback-функция будет собирать все данные формы (текст исходящего сообщения) в одном месте.\r\n    Эти данные будут отдаваться в AC \"addMessage()\" для добавления нового исходящего сообщения. Эта callback-функция\r\n    получает указанные данные на входе в объекте \"formData\" с типом \"AddMessageFormValuesType\".*/\r\n    const addNewMessage = (formData: AddMessageFormValuesType) => {\r\n        /*Здесь мы вызываем AC \"addMessage()\", полученный из props, и передаем ему текст исходящего сообщения.*/\r\n        addMessage(formData.newMessageText);\r\n        /*После вывода исходящего сообщения зануляем поле для ввода текста.*/\r\n        formData.newMessageText = '';\r\n    };\r\n\r\n    return (\r\n        <div className={styles.dialogs}>\r\n            {/*Этот элемент \"div\" содержит список диалогов.*/}\r\n            <div className={styles.dialogsItems}>{dialogsElements}</div>\r\n\r\n            {/*Этот элемент \"div\" содержит внутри два других элемента \"div\".*/}\r\n            <div className={styles.messages}>\r\n                {/*Этот элемент \"div\" содержит исходящие сообщения.*/}\r\n                <div>{messagesElements}</div>\r\n\r\n                {/*Здесь в событии \"onSubmit\" будет приходить объект с данными из callback-функции \"handleSubmit()\" из\r\n                компонента \"AddMessageForm\", который обернут компонентом \"AddMessageReduxForm\". Далее будет вызываться\r\n                при этом событии нами созданная callback-функция \"addNewMessage()\", в которую будет передаваться этот\r\n                объект с данными. После этого эти данные будут отправляться в часть глобального state, которую\r\n                обрабатывает библиотека Redux Form, с целью осуществления работы нашей формы добавления сообщения. Но\r\n                теперь после отправки сообщения окно для ввода текста сообщения не будет очищаться, так как библиотека\r\n                Redux Form хоть и осуществляет FLUX-круговорот, но очистку не осуществляет.*/}\r\n                <AddMessageReduxForm onSubmit={addNewMessage}/>\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит входящие сообщения.*/}\r\n            <div className={styles.incomingMessages}>{incomingMessagesElement}</div>\r\n        </div>\r\n    );\r\n};","import {connect} from 'react-redux';\r\nimport {compose} from 'redux';\r\n/*Импортируем объект \"dialogsAC\", что использовать оттуда AC \"addMessageActionCreator()\". Также Импортируем типы из\r\nфайла \"dialogs-reducer.ts\".*/\r\nimport {dialogsAC, InitialDialogsStateType} from '../../redux/dialogs-reducer';\r\n/*Импортируем компонент \"Dialogs\".*/\r\nimport {Dialogs} from './Dialogs';\r\n/*Импортируем созданный нами HOC \"withAuthRedirect()\" для добавления редиректа.*/\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect';\r\n/*Импортируем тип \"ComponentType\" для типизации.*/\r\nimport {ComponentType} from 'react';\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from '../../redux/redux-store';\r\n\r\ntype MapStateToPropsType = {\r\n    /*Поскольку передаем в этот компонент весь state из файла \"dialogs-reducer.ts\", то указываем тип\r\n    \"InitialDialogsStateType\" - это тип всего этого state.*/\r\n    dialogsPage: InitialDialogsStateType\r\n};\r\n\r\ntype MapDispatchToPropsType = {\r\n    /*AC для добавления нового исходящего сообщения, который принимает строковой параметр и ничего не возвращает.*/\r\n    addMessage: (newMessageText: string) => void\r\n};\r\n\r\n/*При помощи функции \"mapStateToProps()\" указываются данные из state, которые необходимо передать в компонент\r\n\"Dialogs\".*/\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => {\r\n    return {dialogsPage: state.dialogsPage}\r\n};\r\n\r\n/*\"DialogsContainer\" это не классовый компонент и не функциональный компонент. \"DialogsContainer\" является контейнерным\r\nкомпонентом для компонента \"Dialogs\".\r\n\r\nВнутри компонента \"DialogsContainer\" используются следующие компоненты:\r\n1. \"Dialogs\" - компонентом, который отображает диалоги. Импортирован.\r\n\r\nЭтот компонент экспортируется по default и используется в нашем приложении под именем \"DialogsContainer\". Компонент\r\n\"DialogsContainer\" импортируется в файле \"App.tsx\".\r\n\r\nКонтейнерные компоненты оборачивают презентационные компоненты и передают им данные BLL и DAL. Эти данные в нашем\r\nприложении контейнерные компоненты получают из контекста, созданного при помощи компонента \"Provider\" (указан в файле\r\n\"App.tsx\") из библиотеки React Redux.\r\n\r\nВ отличие от классового компонента, компонент такого типа не имеет методов жизненного цикла классового компонента. В\r\nэтом компоненте мы просто создаем функции \"mapStateToProps()\" и \"mapDispatchToProps()\", тем самым формируя props для\r\nпрезентационной компоненты \"Dialogs\". Поэтому нам не нужно создавать классовый компонент для этого. Таким же образом\r\nработает компонент \"MyPostsContainer\".\r\n\r\nПри помощи функции \"compose()\" объединяем HOC \"withAuthRedirect()\" и функцию \"connect()\", возвращая итоговый компонент\r\n\"DialogsContainer\".\r\n\r\nЗдесь мы уточняем тип только одним параметром, так как согласно файлу декларации функции \"compose()\" (раздел \"rest\"),\r\nнам нужно уточнить только такой компонент, свойства props которого не будут переданы в этот компонент функциями,\r\nпереданными внутрь функции \"compose()\", то есть функциями HOC-ом \"withRouter()\" и функцией \"connect()\", а это никакие\r\nсвойства, так как мы не передаем извне ничего в компонент \"Dialogs\".*/\r\nexport default compose<ComponentType>(\r\n    /*При помощи функции \"connect()\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\r\n    компоненту \"Dialogs\". Поскольку функция \"connect()\" является generic, то ее можно уточнить: первым в \"<>\" указан тип\r\n    для функции \"MapStateToProps()\", вторым для функции \"MapDispatchToProps()\", третьим для \"собственных props\"\r\n    компонента, четвертым для state. Эти параметры мы узнали перейдя в файл декларации функции \"connect()\".*/\r\n    connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(\r\n        mapStateToProps,\r\n        {addMessage: dialogsAC.addMessage}\r\n    ),\r\n    /*При помощи HOC \"withAuthRedirect()\" добавляем логику по редиректу в компонент.*/\r\n    withAuthRedirect\r\n)(Dialogs);\r\n\r\n/*--------------------------------------------------------------------------------------------------------------------*/\r\n\r\n/*Это старый вариант функции \"mapDispatchToProps()\". Сейчас АС \"addMessage()\" мы используем в функции \"connect()\". Здесь\r\nуказываются данные (callback-функции - AC или TC) dispatch, которые необходимо передать в компонент \"Dialogs\". Эта\r\nфункция возвращает указанные данные в виде объекта. Функция \"mapDispatchToProps()\" работает следующим образом:\r\n1. Компонент вызывает callback-функцию \"addMessage()\".\r\n2. Компонент передает этой функции параметр \"newMessageText\".\r\n3. Далее этот параметр передается в AC \"addMessageActionCreator()\".\r\n4. Этот AC вызывается.\r\n5. Создается action-объект.\r\n6. Этот action-объект диспатчится в \"dialogsReducer\" в файле \"dialogs-reducer.ts\".*/\r\n// const mapDispatchToProps = (dispatch) => {\r\n//     return {\r\n//         addMessage: (newMessageText) => { dispatch(dialogsAC.addMessage(newMessageText)) }\r\n//     }\r\n// };"],"sourceRoot":""}