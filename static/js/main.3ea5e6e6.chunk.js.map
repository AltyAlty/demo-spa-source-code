{"version":3,"sources":["components/theory/UseEffectTheory/SearchUsersArea/SearchUsersArea.module.css","components/theory/UseStateTheory/UseStateTheory.module.css","components/common/Paginator/Paginator.module.css","components/Navbar/Sidebar/Sidebar.module.css","components/theory/UseEffectTheory/UseEffectTheory.module.css","components/theory/UseEffectTheory/SearchUsersAreaResults/SearchUsersAreaResults.module.css","api/profile-api.ts","redux/profile-reducer.ts","api/chat-api.ts","redux/chat-reducer.ts","redux/dialogs-reducer.ts","api/api.ts","components/common/Preloader/Preloader.module.css","components/Header/Header.module.css","components/Navbar/Navbar.module.css","components/Users/User/User.module.css","assets/images/user.png","components/theory/UseEffectTheory/UserInfo/UserInfo.module.css","components/theory/UseEffectTheory/UserInfo/Timer/Timer.module.css","serviceWorker.js","redux/sidebar-reducer.ts","utils/helpers/object-helpers.ts","api/users-api.ts","redux/users-reducer.ts","api/auth-api.ts","api/security-api.ts","redux/auth-reducer.ts","redux/app-reducer.ts","redux/redux-store.ts","redux/auth-selectors.ts","assets/images/headerlogo.png","components/Header/Header.tsx","redux/sidebar-selectors.ts","components/Navbar/Sidebar/Sidebar.tsx","components/Navbar/Navbar.tsx","redux/users-selectors.ts","components/common/Paginator/Paginator.tsx","components/Users/User/User.tsx","components/Users/UsersSearchForm/UsersSearchForm.tsx","components/Users/Users.tsx","components/Music/Music.tsx","components/News/News.tsx","components/Settings/Settings.tsx","components/Friends/Friends.tsx","components/Login/Login.tsx","components/theory/UseStateTheory/UseStateTheory.tsx","components/theory/UseEffectTheory/SearchUsersArea/SearchUsersArea.tsx","components/theory/UseEffectTheory/SearchUsersAreaResults/SearchUsersAreaResults.tsx","components/theory/UseEffectTheory/UserInfo/Timer/Timer.tsx","components/theory/UseEffectTheory/UserInfo/UserInfo.tsx","components/theory/UseEffectTheory/UseEffectTheory.tsx","hoc/WithSuspense.tsx","App.tsx","index.js","assets/images/preloader.gif","components/common/Preloader/Preloader.tsx","components/common/FormsControls/FormsControls.tsx","components/common/FormsControls/FormsControls.module.css","utils/validators/validators.ts"],"names":["module","exports","profileAPI","userID","instance","get","then","response","data","status","put","photoFile","formData","FormData","append","profile","initialState","postsData","id","message","likesCount","avatar","avatarSource","profileReducer","state","action","type","newPost","newPostText","filter","p","postID","photos","profileAC","addPost","setUserProfile","setUserStatus","deletePostActionCreator","isSavingUserPhotoSuccessfulAC","getUserProfile","dispatch","a","getUserStatus","updateUserStatus","resultCode","ResultCodeEnum","Success","alert","saveUserPhoto","saveProfile","getState","auth","Error","stopSubmit","_error","messages","Promise","reject","ws","notifySubscribersAboutWSStatus","WSStatus","subscribers","forEach","s","closeEventHandler","setTimeout","createWSChannel","messageEventHandler","event","newChatMessages","JSON","parse","openEventHandler","errorEventHandler","removeEvents","removeEventListener","close","WebSocket","addEventListener","chatAPI","WSEvent","callback","push","chatMessage","send","chatMessages","chatReducer","map","m","v1","index","array","length","chatAC","_newChatMessagesHandler","newChatMessagesHandlerCreator","_WSStatusChangingHandler","WSStatusChangingHandlerCreator","startGettingChatMessages","stopGettingChatMessages","sendChatMessage","dialogs","name","messagesData","incomingMessagesData","dialogsReducer","newMessage","newMessageText","dialogsAC","addMessage","ResultCodeForCaptchaEnum","axios","create","withCredentials","baseURL","headers","Boolean","window","location","hostname","match","friendsData","updateObjectInArray","items","itemID","objPropName","newObjProps","u","usersAPI","getUsers","currentPage","pageSize","term","friend","unfollow","delete","follow","post","users","totalUsersCount","isFetching","WhoIsInFollowingProgress","portionSize","usersAC","count","isFollowingInProgress","payload","requestUsers","totalCount","_followUnfollowFlow","apiMethod","actionCreator","authAPI","email","password","rememberMe","captcha","securityAPI","login","isAuth","captchaURL","authAC","getAuthUserData","getCaptchaURL","url","initialized","appAC","rootReducer","combineReducers","profilePage","dialogsPage","sidebar","usersPage","followed","form","formReducer","app","chat","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","store","createStore","applyMiddleware","thunkMiddleWare","__store__","getIsAuth","getLogin","Header","props","Layout","useSelector","useDispatch","className","styles","header","span","src","headerLogoSource","alt","theme","mode","Item","to","icon","UserOutlined","href","onClick","offset","getSidebar","SideBar","path","activeClassName","active","Navbar","sidebarElements","f","SubMenu","Menu","Sider","subMenuKey","getSubMenuKey","key","pop","pathname","getSubMenuKeyCallback","menu","selectedKeys","openKeys","title","onTitleClick","ProfileOutlined","MessageOutlined","HeartOutlined","TeamOutlined","CommentOutlined","BuildOutlined","AlertOutlined","ThunderboltOutlined","ToolOutlined","BookOutlined","createSelector","getPageSize","getPortionSize","getTotalUsersCount","getCurrentPage","getIsFetching","getWhoIsInFollowingProgress","getUsersFilter","Paginator","totalItemsCount","onPageChange","pagesCount","Math","ceil","pages","i","portionCount","useState","currentPortionNumber","setCurrentPortionNumber","lowerBoundOfCurrentPortion","upperBoundOfCurrentPortion","paginator","cn","selectedPage","pageNumber","User","user","small","userPhoto","disabled","some","usersSearchFormValidate","values","UsersSearchForm","React","memo","onFilterChange","enableReinitialize","initialValues","String","validate","onSubmit","setSubmitting","isSubmitting","as","value","Users","isNotJustCreated","setIsNotJustCreated","isJustCreated","setIsJustCreated","useEffect","history","useHistory","search","substr","parsed","queryString","actualCurrentPage","actualFilter","page","Number","query","unfollowCallback","bind","followCallback","Preloader","Music","News","Settings","Friends","maxLength30","maxLengthCreator","LoginReduxForm","reduxForm","handleSubmit","error","createField","Input","required","undefined","style","formSummaryError","Login","CaptchaIsRequired","UseStateTheory","playerOneLife","setPlayerOneLife","playerTwoLife","setPlayerTwoLife","p1","p2","playersLives","setPlayersLives","players","findBestPlayer","console","log","maxPair","max","bestPair","playerThreeLife","setPlayerThreeLife","playerFourLife","setPlayerFourLife","wholeGame","playerOneSection","playerOneName","increasePlayerOneLifeSection","increasePlayerOneLifeButton","actualValue","decreaseAllLivesSection","decreaseAllLivesButton","playerTwoSection","playerTwoName","increasePlayerTwoLifeSection","increasePlayerTwoLifeButton","SearchUsersArea","setGitHubUsers","setSelectedGitHubUserDetails","selectedGitHubUserDetails","setIsRequestingGitHubUsers","initialSearchText","localSearchTerm","setLocalSearchTerm","gitHubSearchTerm","setGitHubSearchTerm","searchUsersArea","searchUsersAreaInput","placeholder","onChange","e","currentTarget","searchUsersAreaButton","searchUsersAreaResetButton","document","SearchUsersAreaResults","gitHubUsers","isRequestingGitHubUsers","setIsRequestingSelectedGitHubUserDetails","selectedGitHubUser","setSelectedGitHubUser","searchUsersAreaResults","selectedUser","Timer","timerKey","secondsToLive","setSecondsToLive","intervalID","setInterval","prev","clearInterval","timerSeconds","UserInfo","isRequestingSelectedGitHubUserDetails","userInfo","followers","avatar_url","UseEffectTheory","wholeGitHubSearch","userList","withSuspense","Component","fallback","DialogsContainer","lazy","ProfileContainer","ChatPage","ProfileContainerWithSuspense","ChatPageWithSuspense","App","this","initializeApp","Content","Footer","exact","render","AppContainer","withRouter","connect","promise","all","AppMain","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","preloader","FormControl","meta","touched","children","hasError","formControl","Textarea","input","restProps","component","validators","text","maxLength"],"mappings":"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","file":"static/js/main.3ea5e6e6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"searchUsersArea\":\"SearchUsersArea_searchUsersArea__pFcHL\",\"searchUsersAreaInput\":\"SearchUsersArea_searchUsersAreaInput__28pPq\",\"searchUsersAreaButton\":\"SearchUsersArea_searchUsersAreaButton__2HTvO\",\"searchUsersAreaResetButton\":\"SearchUsersArea_searchUsersAreaResetButton__1-QCk\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"wholeGame\":\"UseStateTheory_wholeGame__1_zMA\",\"playerOneSection\":\"UseStateTheory_playerOneSection__G4Qei\",\"playerTwoSection\":\"UseStateTheory_playerTwoSection__3RwrA\",\"decreaseAllLivesSection\":\"UseStateTheory_decreaseAllLivesSection__3iue-\",\"increasePlayerOneLifeButton\":\"UseStateTheory_increasePlayerOneLifeButton__2i5CY\",\"increasePlayerTwoLifeButton\":\"UseStateTheory_increasePlayerTwoLifeButton__Z5uh2\",\"decreaseAllLivesButton\":\"UseStateTheory_decreaseAllLivesButton__2Fn2r\",\"playerOneName\":\"UseStateTheory_playerOneName__3gVo6\",\"playerTwoName\":\"UseStateTheory_playerTwoName__6bSJ9\",\"playerOneLife\":\"UseStateTheory_playerOneLife__2w4D2\",\"playerTwoLife\":\"UseStateTheory_playerTwoLife__ky-1q\",\"increasePlayerOneLifeSection\":\"UseStateTheory_increasePlayerOneLifeSection__3n1Lm\",\"increasePlayerTwoLifeSection\":\"UseStateTheory_increasePlayerTwoLifeSection__250KB\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"paginator\":\"Paginator_paginator__3ycd9\",\"pageNumber\":\"Paginator_pageNumber__xULH7\",\"selectedPage\":\"Paginator_selectedPage__1Q54U\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sidebar\":\"Sidebar_sidebar__22UBE\",\"active\":\"Sidebar_active__36icM\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"wholeGitHubSearch\":\"UseEffectTheory_wholeGitHubSearch__vn6bc\",\"userList\":\"UseEffectTheory_userList__2vePn\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"searchUsersAreaResults\":\"SearchUsersAreaResults_searchUsersAreaResults__2DDOa\",\"selectedUser\":\"SearchUsersAreaResults_selectedUser__2pLQI\"};","/*Импортируем общий тип \"ResponseWithDataType\" для некоторых ответов от сервера со схожей структурой ответа.*/\r\nimport {instance, ResponseWithDataType} from './api';\r\n/*Импортируем типы \"PhotosType\" и \"ProfileType\".*/\r\nimport {PhotosType, ProfileType} from '../types/types';\r\n\r\n/*Создаем отдельный тип для \"data\" для запроса \"saveUserPhoto()\" из объекта с запросами \"profileAPI\". Используется для\r\nуточнения в типе \"ResponseType\".*/\r\ntype SaveUserPhotoResponseDataType = {\r\n    /*Объект с фото пользователя должно быть типа \"PhotosType\"*/\r\n    photos: PhotosType\r\n    /*Путь к уменьшенной версии фото пользователя должен быть строкой или null (то есть быть пустым). Это свойство\r\n    видимо добавлено на сервере ошибочно, так как дублирует часть объекта \"photos\".*/\r\n    small: string | null\r\n    /*Путь к увеличенной версии фото пользователя должен быть строкой или null (то есть быть пустым). Это свойство\r\n    видимо добавлено на сервере ошибочно, так как дублирует часть объекта \"photos\".*/\r\n    large: string | null\r\n};\r\n\r\n/*Объект \"profileAPI\" содержит запросы, связанные со страницей профиля пользователя.*/\r\nexport const profileAPI = {\r\n    /*Эта функция является запросом на получение данных профиля пользователя для страницы профиля. Данная функция\r\n    принимает один параметр в виде ID пользователя, который должен быть числом.*/\r\n    getUserProfile(userID: number) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы получить данные профиля пользователя.\r\n            Указываем, что этот GET-запрос возвращает промис с типом \"ProfileType\".*/\r\n            instance.get<ProfileType>(`profile/${userID}`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"aboutMe\" - информация \"обо мне\" (на сайте API этого нет, но на самом деле на сервере это поле\r\n                имеется).\r\n                2. \"contacts\": - контакты\r\n                  1) \"github\"\r\n                  2) \"vk\"\r\n                  3) \"facebook\"\r\n                  4) \"instagram\"\r\n                  5) \"twitter\"\r\n                  6) \"website\"\r\n                  7) \"youtube\"\r\n                  8) \"mainLink\".\r\n                3. \"fullName\" - полное имя.\r\n                4. \"lookingForAJob\" - ищет ли работу.\r\n                5. \"lookingForAJobDescription\" - какую ищет работу.\r\n                6. \"photos\": - фото.\r\n                  1) \"small\"\r\n                  2) \"large\".\r\n                7. \"userId\" - ID пользователя.\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"getUserProfile()\".*/\r\n                .then(response => { return response.data })\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на получение данных статуса пользователя для страницы профиля. Данная функция\r\n    принимает один параметр в виде ID пользователя, который должен быть числом.*/\r\n    getUserStatus(userID: number) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы получить данные статуса пользователя.\r\n            Указываем, что этот GET-запрос возвращает промис с типом строки.*/\r\n            instance.get<string>(`profile/status/${userID}`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находится\r\n                текст статуса пользователя (хотя было бы лучше, чтобы данные приходили в формате JSON, то есть в данном\r\n                случае не возвращается объект со свойствами, как это происходит в других запросах).\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"getUserStatus()\".*/\r\n                .then(response => { return response.data })\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на изменение данных статуса пользователя для страницы профиля на сервере. Данная\r\n    функция принимает один параметр в виде строки с информацией из статуса. Согласно API сервера максимальная длинна\r\n    статуса 300 символов в формате JSON.*/\r\n    updateUserStatus(status: string) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы отправить на сервер новые данные статуса\r\n            пользователя. А также указываем объект с этими данными. Еще указываем, что этот PUT-запрос возвращает промис\r\n            с типом \"ResponseWithDataType\".*/\r\n            instance.put<ResponseWithDataType>(`profile/status`, {status: status})\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя (0 - все хорошо, 1 -\r\n                какая-то ошибка).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время обновления статуса пользователя).\r\n                3. \"data\" - какие-то дополнительные данные (в данный момент не используется).\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"updateUserStatus()\".*/\r\n                .then(response => { return response.data })\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на загрузку фото пользователя на сервер. Данная функция принимает один параметр в\r\n    виде файла. Тип этого файла указан как File из Typescript.*/\r\n    saveUserPhoto(photoFile: File) {\r\n        const formData = new FormData();\r\n        /*Поскольку здесь мы передаем не просто JSON-данные, а изображение, то поэтому формируем специальный объект при\r\n        помощи функции \"formData()\". При помощи метода \"formData.append()\" добавляем в этот объект файл с фото. \"image\"\r\n        - так указывается согласно API сервера. Третьим параметром отправляется объект со специфическими заголовками, но\r\n        в данном случае и без него все работает.*/\r\n        formData.append('image', photoFile);\r\n\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы отправить на сервер фото пользователя. А\r\n            также указываем объект с этим фото. Еще указываем, что этот PUT-запрос возвращает промис с типом\r\n            \"ResponseWithDataType<SaveUserPhotoResponseDataType>\".*/\r\n            instance.put<ResponseWithDataType<SaveUserPhotoResponseDataType>>\r\n            (`profile/photo`, formData/*, {headers: {'Content-Type': 'multipart/form-data'}}*/)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли прошла загрузка фото пользователя (0 - все хорошо, другие\r\n                числа - какая-то ошибка).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время загрузки фото).\r\n                3. \"data\" - дополнительные данные, содержащие еще один объект \"photos\", который в свою очередь имеет еще\r\n                два свойства:\r\n                  1) \"small\" - URL фото в маленьком размере, если отсутствует, то будет null.\r\n                  2) \"large\" - URL фото в большом размере, если отсутствует, то будет null.\r\n                Помимо наличия объекта \"photos\", свойство \"data\" имеет также свои свойства \"small\" и \"large\", копирующие\r\n                аналогичные свойства у объекта \"photos\". Предположительно это ошибочно добавили на сервере.\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"saveUserPhoto()\"*/\r\n                .then(response => { return response.data })\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на отправку новых данных профиля пользователя на сервер. Данная функция принимает\r\n    один параметр в виде объекта с данными типа \"ProfileType\". Согласно API сервера в этом объекте должно находится\r\n    следующее:\r\n    1. \"aboutMe\" - информация \"обо мне\" (на сайте API этого нет, но на самом деле на сервере это поле имеется).\r\n    2. \"contacts\": - контакты\r\n      1) \"github\"\r\n      2) \"vk\"\r\n      3) \"facebook\"\r\n      4) \"instagram\"\r\n      5) \"twitter\"\r\n      6) \"website\"\r\n      7) \"youtube\"\r\n      8) \"mainLink\".\r\n    3. \"fullName\" - полное имя.\r\n    4. \"lookingForAJob\" - ищет ли работу.\r\n    5. \"lookingForAJobDescription\" - какую ищет работу.\r\n    6. \"photos\": - фото.\r\n      1) \"small\"\r\n      2) \"large\".\r\n    7. \"userId\" - ID пользователя.*/\r\n    saveProfile(profile: ProfileType) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы отправить на сервер новые данные профиля\r\n            пользователя. А также указываем объект с этими данными. Еще указываем, что этот PUT-запрос возвращает промис\r\n            с типом \"ResponseWithDataType\".*/\r\n            instance.put<ResponseWithDataType>(`profile`, profile)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли прошла отправка новых данных профиля пользователя (0 - все\r\n                хорошо, другие числа - какая-то ошибка).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время отправки новых данных профиля пользователя).\r\n                3. \"data\" - какие-то дополнительные данные (в данный момент не используется).\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"saveProfile()\".*/\r\n                .then(response => { return response.data })\r\n        );\r\n    }\r\n};","/*Импортируем из ассетов проекта аватар пользователя.*/\r\nimport avatarSource from '../assets/images/user.png';\r\n/*Импортируем блоки запросов, связанных со страницей профиля пользователя.*/\r\nimport {profileAPI} from '../api/profile-api';\r\n/*Импортируем списки кодов ответов от сервера.*/\r\nimport {ResultCodeEnum} from '../api/api';\r\n/*Импортируем специальный AC \"stopSubmit()\" из библиотеки Redux Form, который сообщает UI, что что-то пошло не так, и\r\nостанавливает submit данных в форме. Импортируем \"FormAction\", чтобы создать тип для action-объектов, которые передается\r\nв thunks и TC.*/\r\nimport {FormAction, stopSubmit} from 'redux-form';\r\n/*Импортируем типы \"PhotosType\", \"PostType\" и \"ProfileType\".*/\r\nimport {PhotosType, PostType, ProfileType} from '../types/types';\r\n/*Импортируем типы \"InferActionsTypes\" и \"BaseThunkType\".*/\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store';\r\n\r\ntype InitialProfileStateType = typeof initialState;\r\n\r\nlet initialState = {\r\n    /*Создаем массив объектов, которые хранят информацию о постах на странице профиля. Указываем, что этот массив\r\n    объектов имеет тип массива элементов с типом \"PostType\".*/\r\n    postsData: [\r\n        {id: 1, message: 'Hi, how are you?', likesCount: 2, avatar: avatarSource},\r\n        {id: 2, message: 'It\\'s my first post', likesCount: 3, avatar: avatarSource}\r\n    ] as Array<PostType>,\r\n\r\n    /*Создаем свойство, которое будет хранить информацию о профиле пользователя, полученную с сервера. Имеет тип\r\n    \"ProfileType\" или может иметь тип null, то есть быть пустым.*/\r\n    profile: null as ProfileType | null,\r\n\r\n    /*Создаем свойство, которое будет хранить информацию о статусе пользователя, полученную с сервера. Указываем, что\r\n    изначально это свойство может иметь тип null, то есть быть пустым, или быть строкой. Можно было вместо этого просто\r\n    указать ''.*/\r\n    status: null as string | null\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за страницу профиля.*/\r\nexport const profileReducer = (state = initialState, action: ActionsType): InitialProfileStateType => {\r\n    switch (action.type) {\r\n        /*Добавляем новый пост на страницу профиля пользователя.*/\r\n        case 'demo-spa/profile-reducer/ADD-POST': {\r\n            /*Создаем новый пост в виде объекта.*/\r\n            const newPost = {\r\n                /*Указываем ID поста.*/\r\n                id: 5,\r\n                /*Указываем текст поста.*/\r\n                message: action.newPostText,\r\n                /*Указываем количество лайков у поста.*/\r\n                likesCount: 0,\r\n                /*Указываем аватар пользователя, которые будет отрисовываться рядом с постом.*/\r\n                avatar: avatarSource\r\n            };\r\n\r\n            /*Добавляем этот новый пост в state.*/\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Делаем глубокую копию state. Добавляем данные для нового поста в state.*/\r\n                postsData: [...state.postsData, newPost]\r\n            };\r\n        }\r\n\r\n        /*Устанавливаем данные профиля пользователя на странице его профиля.*/\r\n        case 'demo-spa/profile-reducer/SET-USER-PROFILE': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Устанавливаем данные профиля пользователя в state.*/\r\n                profile: action.profile\r\n            };\r\n        }\r\n\r\n        /*Устанавливаем данные статуса пользователя на странице его профиля.*/\r\n        case 'demo-spa/profile-reducer/SET-USER-STATUS': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Устанавливаем данные статуса пользователя в state.*/\r\n                status: action.status\r\n            };\r\n        }\r\n\r\n        /*Удаляем пост по его ID.*/\r\n        case 'demo-spa/profile-reducer/DELETE-POST': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Отфильтровываем массив \"postsData\", оставив только те элементы, которые не имеют ID равного ID из\r\n                полученного action-объекта.*/\r\n                postsData: state.postsData.filter(p => p.id !== action.postID)\r\n            };\r\n        }\r\n\r\n        /*Устанавливаем ссылки на фото пользователя на странице профиля в state.*/\r\n        case 'demo-spa/profile-reducer/IS-SAVING-USER-PHOTO-SUCCESSFUL': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Делаем глубокую копию state. Добавляем объект со ссылками на фото пользователя на странице профиля в\r\n                state. Указываем, что объект \"profile\" имеет тип \"ProfileType\", но такого лучше здесь не делать, а\r\n                делать это в указании типа action-объектов, которые редьюсер принимает на входе.*/\r\n                profile: {...state.profile, photos: action.photos} as ProfileType\r\n            };\r\n        }\r\n\r\n        default: {\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\ntype ActionsType = InferActionsTypes<typeof profileAC>;\r\n\r\nexport const profileAC = {\r\n    /*AC для добавления нового поста. На входе получает \"newPostText\", которое должно быть строкой.*/\r\n    addPost: (newPostText: string) => ({\r\n        type: 'demo-spa/profile-reducer/ADD-POST',\r\n        /*Создаем свойство, которое содержит текст поста.*/\r\n        newPostText\r\n    } as const),\r\n\r\n    /*AC для установки данных профиля пользователя на странице его профиля. На входе получает \"profile\", которое должно\r\n    быть типа \"ProfileType\".*/\r\n    setUserProfile: (profile: ProfileType) => ({\r\n        type: 'demo-spa/profile-reducer/SET-USER-PROFILE',\r\n        /*Создаем свойство, которое содержит данные профиля пользователя.*/\r\n        profile\r\n    } as const),\r\n\r\n    /*AC для установки данных статуса пользователя на странице его профиля. На входе получает \"status\", которое должно\r\n    быть строкой.*/\r\n    setUserStatus: (status: string) => ({\r\n        type: 'demo-spa/profile-reducer/SET-USER-STATUS',\r\n        /*Создаем свойство, которое содержит данные статуса пользователя на странице его профиля.*/\r\n        status\r\n    } as const),\r\n\r\n    /*AC для добавления нового поста. Этот AC создали специально для целей тестирования в файле\r\n    \"profile-reducer.test.ts\", данный функционал в нашем приложении пока еще не реализован. На входе получает \"postID\",\r\n    которое должно быть числом.*/\r\n    deletePostActionCreator: (postID: number) => ({\r\n        type: 'demo-spa/profile-reducer/DELETE-POST',\r\n        /*Создаем свойство, которое содержит ID поста для удаления.*/\r\n        postID\r\n    } as const),\r\n\r\n    /*AC для установки фото пользователя в приложении на странице его профиля. На входе получает \"photos\", которое\r\n    должно быть типа \"PhotosType\".*/\r\n    isSavingUserPhotoSuccessfulAC: (photos: PhotosType) => ({\r\n        type: 'demo-spa/profile-reducer/IS-SAVING-USER-PHOTO-SUCCESSFUL',\r\n        /*Создаем свойство, которое содержит объект со ссылками на фото пользователя с сервера.*/\r\n        photos\r\n    } as const)\r\n};\r\n\r\n\r\n/*Создаем тип для thunks. Поскольку в TC \"saveProfile()\" мы диспатчим AC \"stopSubmit()\" из библиотеки Redux Form,\r\nпоэтому здесь мы указываем еще и \"FormAction\" из библиотеки Redux Form, так как в файле декларации AC \"stopSubmit()\"\r\nуказано, что он \"extends\" от \"FormAction\". Но из-за этого теперь мы можем диспатчить любой action-объект, что\r\nестественно нежелательно для нас.*/\r\ntype ThunkType = BaseThunkType<ActionsType | FormAction>;\r\n\r\n/*Это TC для запроса и установки данных по профилю пользователя на странице профиля. На входе принимает ID пользователя,\r\nкоторое должно быть числом.*/\r\nexport const getUserProfile = (userID: number): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для получения данных по профилю пользователя и ждем ответа от сервера.*/\r\n    const response = await profileAPI.getUserProfile(userID);\r\n    /*Получив ответ от сервера, при помощи AC \"setUserProfile()\" устанавливаем данные по профилю пользователя в state.*/\r\n    dispatch(profileAC.setUserProfile(response));\r\n};\r\n\r\n/*Это TC для запроса и установки данных по статусу пользователя на странице профиля. На входе принимает ID пользователя,\r\nкоторое должно быть числом.*/\r\nexport const getUserStatus = (userID: number): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для получения данных по статусу пользователя и ждем ответа от сервера.*/\r\n    const response = await profileAPI.getUserStatus(userID);\r\n    /*Получив ответ от сервера, при помощи AC \"setUserStatus()\" устанавливаем данные по статусу пользователя в state.*/\r\n    dispatch(profileAC.setUserStatus(response));\r\n};\r\n\r\n/*Это TC для изменения данных по статусу пользователя на странице профиля.  На входе принимает статус пользователя,\r\nкоторый должно быть строкой.*/\r\nexport const updateUserStatus = (status: string): ThunkType => async (dispatch) => {\r\n    /*Используем конструкцию try/catch.*/\r\n    try {\r\n        /*Делаем запрос на сервер для изменения данных по статусу пользователя и ждем ответа от сервера.*/\r\n        const response = await profileAPI.updateUserStatus(status);\r\n        /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\", то есть операция прошла успешно, то диспатчим AC\r\n        \"setUserStatus()\" для установки нового статуса пользователя в приложении, передав в этот AC данные по статусу\r\n        пользователя с сервера.*/\r\n        if (response.resultCode === ResultCodeEnum.Success) dispatch(profileAC.setUserStatus(status));\r\n    } catch (error) {\r\n        /*Если во время выполнения блока \"try\" произошла ошибка, то вместо краша приложения будет выведено сообщение,\r\n        что произошла какая-то ошибка.*/\r\n        alert(error);\r\n    }\r\n};\r\n\r\n/*Это TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении. На входе\r\nпринимает объект с фото пользователя, которое типа \"File\" из Typescript.*/\r\nexport const saveUserPhoto = (photoFile: File): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для загрузки фото пользователя и ждем ответа от сервера.*/\r\n    const response = await profileAPI.saveUserPhoto(photoFile);\r\n\r\n    /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\", то есть операция прошла успешно, то диспатчим AC\r\n    \"isSavingUserPhotoSuccessfulAC()\" для установки фото пользователя в приложении, передав в этот AC объект со ссылками\r\n    на фото пользователя с сервера.*/\r\n    if (response.resultCode === ResultCodeEnum.Success) {\r\n        dispatch(profileAC.isSavingUserPhotoSuccessfulAC(response.data.photos));\r\n    }\r\n};\r\n\r\n/*Это TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем\r\nприложении. На входе принимает профиль пользователя, который должно быть типа \"ProfileType\".*/\r\nexport const saveProfile = (profile: ProfileType): ThunkType =>\r\n    async (dispatch, getState) => {\r\n        /*Получаем ID залогиненного пользователя при помощи функции \"getState()\".*/\r\n        const userID = getState().auth.id;\r\n        /*Делаем запрос на сервер отправки новых данных профиля пользователя и ждем ответа от сервера.*/\r\n        const response = await profileAPI.saveProfile(profile);\r\n\r\n        /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\", то есть операция прошла успешно, то диспатчим TC\r\n        \"getUserProfile()\" для запроса и установки данных по профилю пользователя на странице профиля, передав в этот TC\r\n        ID залогиненного пользователя.*/\r\n        if (response.resultCode === ResultCodeEnum.Success) {\r\n            /*Внутри здесь делаем проверку, чтобы \"userID\" не был null, так как Typescript пишет ошибку.*/\r\n            if (userID !== null) {\r\n                dispatch(getUserProfile(userID));\r\n            } else {\r\n                /*Если же окажется, что \"userID\" все-таки равен null, то будет выведена ошибка, что \"userID\" не может\r\n                быть null.*/\r\n                throw new Error('userID cannot be null');\r\n            }\r\n        } else {\r\n            /*Иначе если в ответе от сервера в свойстве \"resultCode\" не указано \"0\", то есть операция не прошла успешно,\r\n            то задиспатчим специальный AC \"stopSubmit()\" из библиотеки Redux Form, который сообщит UI, что что-то пошло\r\n            не так, и остановит submit данных.\r\n\r\n            Первым параметром указывается какую форму необходимо остановить. Вторым параметром указывается объект, в\r\n            котором должно быть свойство \"_error\" (это свойство из библиотеки Redux Form, означающее ошибку для всей\r\n            формы, но здесь можно использовать и имена других полей, созданных нами), присваиваемый значение с текстом\r\n            ошибки (в ответе от сервера в данном случае).\r\n\r\n            Но сейчас со AC \"stopSubmit()\" проблемы. При его использовании возникает проблема асинхронности, так как\r\n            библиотека Redux Form вызывает функцию \"setSubmitSucceed()\" сразу после AC \"stopSubmit()\", не успев вернуть\r\n            ошибку. Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно\r\n            использовать такой костыль:\r\n            setTimeout(async () => await dispatch(stopSubmit('editProfile', {_error: response.messages[0]})))\r\n\r\n            Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки Redux Form\r\n            (8.3.6).*/\r\n            dispatch(stopSubmit('editProfile', {_error: response.messages[0]}));\r\n            /*И поскольку будет какая-то ошибка на сервера, то промис будет в состоянии ожидании, соответственно, мы его\r\n            прерываем, указав текст ошибки. Это нужно, чтобы не произошло деактивации режима редактирования профиля\r\n            пользователя в callback-функции \"onSubmit()\", которая создана нами в компоненте \"ProfileInfo\".*/\r\n            return Promise.reject(response.messages[0]);\r\n        }\r\n    };","/*Создаем тип для объектов, которые будут приходить от сервера и содержать информацию о сообщении из чата.*/\r\nexport type ChatMessageAPIType = {\r\n    /*Сообщение пользователя, которое было отправлено в чат, должно быть строкой.*/\r\n    message: string\r\n    /*Фото пользователя, который отправил сообщение в чат, должно быть строкой.*/\r\n    photo: string\r\n    /*ID пользователя, который отправил сообщение в чат, должно быть числом.*/\r\n    userId: number\r\n    /*Имя пользователя, который отправил сообщение в чат, должно быть строкой.*/\r\n    userName: string\r\n};\r\n\r\n/*Создаем тип для статуса готовности WebSocket-канала для отправки информации по нему.*/\r\nexport type WSStatusType = 'pending' | 'ready' | 'error';\r\n\r\n/*Создаем тип для callback-функции, которая передается в методы \"subscribe()\" и \"unsubscribe()\" в объекте с запросами\r\n\"chatAPI\" ниже. Функции с таким типом обозначают подписчиков на получение новых сообщения чата. Эта callback-функция\r\nничего не возвращает, но на входе принимает массив элементов с созданным нами выше типом \"ChatMessageAPIType\", то есть\r\nмассив с сообщениями из чата.*/\r\nexport type ChatMessagesReceivingSubscriberType = (chatMessages: ChatMessageAPIType[]) => void;\r\n\r\n/*Создаем тип для callback-функции, которая передается в методы \"subscribe()\" и \"unsubscribe()\" в объекте с запросами\r\n\"chatAPI\" ниже. Функции с таким типом обозначают подписчиков на изменение статуса готовности WebSocket-канала для\r\nотправки информации по нему. Эта callback-функция ничего не возвращает, но на входе принимает указанный статус\r\nWebSocket-канала созданного нами выше типа \"WSStatusType\".*/\r\nexport type WSStatusChangingSubscriberType = (status: WSStatusType) => void;\r\n\r\n/*Создаем специальный тип для ключей в виде строковых значений в объекте \"subscribers\", где каждый ключ обозначает вид\r\nподписчиков на разные события. \"chat-messages-receiving\" обозначает подписчиков на получение новых сообщений в чате, а\r\n\"ws-status-changing\" обозначает подписчиков на изменение статуса готовности WebSocket-канала для отправки информации по\r\nнему.*/\r\nexport type WSEventType = 'chat-messages-receiving' | 'ws-status-changing';\r\n\r\n/*Объявляем переменную \"ws\", которая может быть типа \"WebSocket\" или null, то есть отсутствовать, в дальнейшем\r\nиспользуемая для хранения WebSocket-канала.*/\r\nlet ws: WebSocket | null = null;\r\n\r\n/*Создаем вспомогательную функцию \"notifySubscribersAboutWSStatus()\", которая при вызове будет уведомлять подписчиков на\r\nизменение статуса готовности WebSocket-канала для отправки информации по нему в объекте \"subscribers\" при изменении\r\nэтого статуса.\r\n\r\nТо есть здесь мы пробегаемся по каждому подписчику на изменение статуса готовности WebSocket-канала для отправки\r\nинформации по нему, то есть по каждой callback-функции в массиве под ключем \"ws-status-changing\" объекта \"subscribers\",\r\nвызываем каждого такого подписчика и передаем каждому из них информацию о статусе готовности WebSocket-канала для\r\nотправки информации по нему, чтобы в дальнейшем они установили эту информацию в наш store.*/\r\nconst notifySubscribersAboutWSStatus = (WSStatus: WSStatusType) => {\r\n    subscribers['ws-status-changing'].forEach(s => s(WSStatus));\r\n};\r\n\r\n/*Создаем функцию \"closeEventHandler()\", которая будет вызываться при подписке на событие \"close\" в WebSocket-канале и\r\nвызывать функцию \"createWSChannel\" каждые 3 секунды с целью пересоздания WebSocket-канала.*/\r\nconst closeEventHandler = () => { setTimeout(createWSChannel, 3000)};\r\n\r\n/*Создаем функцию \"messageEventHandler()\", которая будет вызываться при подписке на событие \"message\" в\r\nWebSocket-канале, на входе получать информацию из WebSocket-канала, которая внутри себя содержит информацию о сообщениях\r\nиз чата, парсить ее в формат JSON при помощи метода \"JSON.parse()\", чтобы в дальнейшем можно было сохранить эту\r\nинформацию в массиве \"newChatMessages\" под элементами в виде объектов, после этого сохранять эту информацию о сообщениях\r\nиз чата в массиве \"newChatMessages\".\r\n\r\nДалее мы пробегаемся по каждому подписчику на получение новых сообщений в чате, то есть по каждой callback-функции в\r\nмассиве под ключем \"chat-messages-receiving\" объекта \"subscribers\", вызываем каждого такого подписчика и передаем\r\nкаждому из них информацию о сообщениях из чата, чтобы в дальнейшем они установили эту информацию в наш store.*/\r\nconst messageEventHandler = (event: MessageEvent) => {\r\n    const newChatMessages = JSON.parse(event.data);\r\n    subscribers['chat-messages-receiving'].forEach(s => s(newChatMessages));\r\n};\r\n\r\n/*Создаем функцию \"openEventHandler()\", которая будет вызываться при подписке на событие \"open\" в WebSocket-канале,\r\nуведомлять подписчиков на изменение статуса готовности WebSocket-канала для отправки информации по нему об изменении\r\nэтого статуса.*/\r\nconst openEventHandler = () => { notifySubscribersAboutWSStatus('ready')};\r\n/*Создаем функцию \"errorEventHandler()\", которая будет вызываться при подписке на событие \"error\" в WebSocket-канале,\r\nуведомлять подписчиков на изменение статуса готовности WebSocket-канала для отправки информации по нему об изменении\r\nэтого статуса.*/\r\nconst errorEventHandler = () => { notifySubscribersAboutWSStatus('error')};\r\n\r\n/*Создаем функцию \"removeEvents()\", которая при вызове отписывает от всех событий в WebSocket-канале с целью очистки\r\nпамяти.*/\r\nconst removeEvents = () => {\r\n    /*Если имеется WebSocket-канал, то с целью очистки памяти мы отписываемся в нем от события \"close\". Для отписки\r\n    должны указать ту же функцию, что и указывали при подписке на это событие (подписка ниже).*/\r\n    ws?.removeEventListener('close', closeEventHandler);\r\n    /*Если имеется WebSocket-канал, то с целью очистки памяти мы отписываемся в нем от события \"message\". Для отписки\r\n    должны указать ту же функцию, что и указывали при подписке на это событие (подписка ниже).*/\r\n    ws?.removeEventListener('message', messageEventHandler);\r\n    /*Если имеется WebSocket-канал, то с целью очистки памяти мы отписываемся в нем от события \"open\". Для отписки\r\n    должны указать ту же функцию, что и указывали при подписке на это событие (подписка ниже).*/\r\n    ws?.removeEventListener('open', openEventHandler);\r\n    /*Если имеется WebSocket-канал, то с целью очистки памяти мы отписываемся в нем от события \"error\". Для отписки\r\n    должны указать ту же функцию, что и указывали при подписке на это событие (подписка ниже).*/\r\n    ws?.removeEventListener('error', errorEventHandler);\r\n};\r\n\r\n/*Создаем функцию \"createWSChannel()\".*/\r\nfunction createWSChannel() {\r\n    /*Если имеется WebSocket-канал, то с целью очистки памяти мы отписываемся в нем от событий \"close\", \"message\",\r\n    \"open\" и \"error\".*/\r\n    removeEvents();\r\n    /*Далее мы вызываем функцию \"close()\" у WebSocket-канала (если таковой имеется) с целью полного закрытия этого\r\n    WebSocket-канала.*/\r\n    ws?.close();\r\n    /*Далее следующим образом создаем WebSocket-канал, указав адрес согласно API сервера. Согласно API сервера в ответ\r\n    мы будем получать объекты, содержащие следующие свойства:\r\n    1. \"userId\" - ID пользователя, который отправил сообщение в чат.\r\n    2. \"userName\" - имя пользователя, который отправил сообщение в чат.\r\n    3. \"photo\" - фото пользователя, который отправил сообщение в чат.\r\n    4. \"message\" - сообщение пользователя, которое было отправлено в чат.\r\n\r\n    По стандартному HTTP-протоколу клиент делает запросы на сервер, а сервер отправляет ответы клиенту. Чтобы делать\r\n    наоборот, нужно применять дополнительные механизмы, например, SSE или WebSocket. WebSocket - это в каком-то смысле\r\n    альтернатива протокола HTTP (прикладной уровень). WSS - это безопасная версия протокола WebSocket, по аналогии с\r\n    HTTPS. По протоколу WebSocket можно передавать два типа данных: текстовой и бинарный. Также нужно помнить, что в\r\n    браузерах в средствах разработчика нельзя замедлить скорость WebSocket-каналов.*/\r\n    ws = new WebSocket('wss://social-network.samuraijs.com/handlers/ChatHandler.ashx');\r\n    /*Далее подписываемся на событие \"close\", при срабатывании которого будет вызываться функция\r\n    \"closeEventHandler()\".*/\r\n    ws.addEventListener('close', closeEventHandler);\r\n    /*Далее подписываемся на событие \"message\", при срабатывании которого будет вызываться функция\r\n    \"messageEventHandler()\".*/\r\n    ws.addEventListener('message', messageEventHandler);\r\n    /*Далее подписываемся на событие \"open\", при срабатывании которого будет вызываться функция \"openEventHandler()\".*/\r\n    ws.addEventListener('open', openEventHandler);\r\n    /*Далее подписываемся на событие \"error\", при срабатывании которого будет вызываться функция\r\n    \"errorEventHandler()\".*/\r\n    ws.addEventListener('error', errorEventHandler);\r\n};\r\n\r\n/*Создаем специальный объект \"subscribers\", который будет содержать ключи в виде строковых значений. Каждый ключ будет\r\nхранить свой массив каких-то элементов в виде функций, то есть функций, которые как бы будут подписываться на какие-то\r\nизменения и что-то получать при каждом таком изменении.\r\n\r\nВ случае ключа \"chat-messages-receiving\" там будут callback-функции типа \"ChatMessagesReceivingSubscriberType\", которые\r\nбудут подписываться на получение новых сообщений для чата из WebSocket-канала. Соответственно, после подписки при каждом\r\nновом сообщении для чата эти callback-функции будут вызываться и получать эти новые сообщения, что в дальнейшем мы можем\r\nиспользовать для сохранения этих сообщений на уровне BLL, то есть в нашем store.\r\n\r\nВ случае ключа \"ws-status-changing\" там будут callback-функции типа \"WSStatusChangingSubscriberType\", которые будут\r\nподписываться на изменение статуса готовности WebSocket-канала для отправки информации по нему. Соответственно, после\r\nподписки при каждом изменении этого статуса WebSocket-канала эти callback-функции будут вызываться и получать этот новый\r\nстатус WebSocket-канала, что в дальнейшем мы можем использовать для сохранения этого статуса WebSocket-канала на уровне\r\nBLL, то есть в нашем store.\r\n\r\nТаким образом реализуется работа между уровнями DAL (WebSocket-канал) и BLL (наш store).*/\r\nconst subscribers = {\r\n    'chat-messages-receiving': [] as ChatMessagesReceivingSubscriberType[],\r\n    'ws-status-changing': [] as WSStatusChangingSubscriberType[]\r\n};\r\n\r\n/*Создаем API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем приложении.*/\r\nexport const chatAPI = {\r\n    /*Создаем метод \"startWSChannel()\", который будет вызывать функцию \"createWSChannel()\", объявленную выше. Этот метод\r\n    будет использоваться для инициализации WebSocket-канала.*/\r\n    startWSChannel() { createWSChannel() },\r\n\r\n    /*Создаем метод \"stopWSChannel()\" для отключения WebSocket-канала (если таковой имеется). При вызове этого метода мы\r\n    очищаем все наши массивы подписчиков, то есть массивы в объекте \"subscribers\". Также с целью очистки памяти мы\r\n    отписываемся от событий \"close\", \"message\", \"open\" и \"error\" в WebSocket-канале. И в конце мы вызываем функцию\r\n    \"close()\" у WebSocket-канала (если таковой имеется) с целью полного закрытия этого WebSocket-канала.*/\r\n    stopWSChannel() {\r\n        subscribers['chat-messages-receiving'] = [];\r\n        subscribers['ws-status-changing'] = [];\r\n        removeEvents();\r\n        ws?.close();\r\n    },\r\n\r\n    /*При получении сообщения для чата по WebSocket-каналу или при изменении статуса готовности WebSocket-канала для\r\n    отправки информации по нему нам необходимо уведомлять об этом уровень BLL, то есть наш store, чтобы мы могли\r\n    сохранять эти новые сообщения в нашем store или этот новый статус WebSocket-канала.\r\n\r\n    Для этого здесь мы создаем метод \"subscribe()\", который при вызове будет получать callback-функции типа\r\n    \"ChatMessagesReceivingSubscriberType\" или типа \"WSStatusChangingSubscriberType\". Эти callback-функции должны будут\r\n    вызываться каждый раз, когда мы получаем новое сообщение для чата или при каждом изменении статуса готовности\r\n    WebSocket-канала для отправки информации по нему соответственно, и устанавливать эту информацию в наш store.\r\n\r\n    При получении таких callback-функций мы добавляем их в объект \"subscribers\", таким образом, как бы подписывая их на\r\n    получение новых сообщений для чата из WebSocket-канала или на изменение статуса готовности WebSocket-канала для\r\n    отправки информации по нему соответственно.\r\n\r\n    Для указания типа подписчика первым параметром здесь мы передаем строковое значение одного из ключей объекта\r\n    \"subscribers\".*/\r\n    subscribe(WSEvent: WSEventType, callback: ChatMessagesReceivingSubscriberType | WSStatusChangingSubscriberType) {\r\n        /*Пока игнорируем здесь Typescript, так как еще не разобрались с типизацией в этом месте.*/\r\n        // @ts-ignore\r\n        subscribers[WSEvent].push(callback);\r\n        /*Также метод \"subscribe()\" возвращает функцию, при вызове снаружи которой произойдет отписка всех подписчиков.\r\n        То есть в объекте \"subscribers\" останутся только те элементы, которые не равны подписанной callback-функции. В\r\n        итоге эта callback-функция перестанет реагировать на получения сообщений для чата или на изменение статуса\r\n        готовности WebSocket-канала для отправки информации по нему соответственно. Это одна из реализаций способа\r\n        отписки. Но ниже мы создали для этого отдельный метод \"unsubscribe()\".\r\n\r\n        Пока игнорируем здесь Typescript, так как еще не разобрались с типизацией в этом месте.*/\r\n        // @ts-ignore\r\n        return () => { subscribers[WSEvent] = subscribers[WSEvent].filter(s => s !== callback) };\r\n    },\r\n\r\n    /*Создаем метод \"unsubscribe()\" для отписки подписчиков, то есть callback-функций в объекте \"subscribers\". При\r\n    вызове этого метода в объекте \"subscribers\" останутся только те элементы, которые не равны подписанной\r\n    callback-функции. В итоге эта callback-функция перестанет реагировать на получения сообщений для чата или на\r\n    изменение статуса готовности WebSocket-канала для отправки информации по нему соответственно.\r\n\r\n    Для указания типа подписчика первым параметром здесь мы передаем строковое значение одного из ключей объекта\r\n    \"subscribers\".*/\r\n    unsubscribe(WSEvent: WSEventType, callback: ChatMessagesReceivingSubscriberType | WSStatusChangingSubscriberType) {\r\n        /*Пока игнорируем здесь Typescript, так как еще не разобрались с типизацией в этом месте.*/\r\n        // @ts-ignore\r\n        subscribers[WSEvent] = subscribers[WSEvent].filter(s => s !== callback);\r\n    },\r\n\r\n    /*Создаем метод \"sendChatMessage()\", при вызове который получает введенное нами сообщения для чата, вызывает функцию\r\n    \"send()\" у WebSocket-канала (если таковой имеется) и передает в нее наше сообщение для отправки этого сообщения по\r\n    WebSocket-каналу.*/\r\n    sendChatMessage(chatMessage: string) { ws?.send(chatMessage) }\r\n};","/*Библиотека UUID помогает организовать идентификацию при помощи создания универсального уникального идентификатора\r\n(UUID). Импортируем функцию \"v1()\" для создания UUID варианта 1.*/\r\nimport {v1} from 'uuid';\r\n/*Импортируем API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем приложении. Также\r\nимпортируем типы \"ChatMessageAPIType\", \"WSStatusType\", \"ChatMessagesReceivingSubscriberType\" и\r\n\"WSStatusChangingSubscriberType\".*/\r\nimport {\r\n    chatAPI, ChatMessageAPIType, WSStatusType, ChatMessagesReceivingSubscriberType, WSStatusChangingSubscriberType\r\n} from '../api/chat-api'\r\n/*Импортируем типы \"InferActionsTypes\" и \"BaseThunkType\".*/\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store';\r\n/*Импортируем функцию \"Dispatch()\" из библиотеки Redux, чтобы создать тип для dispatch-функции, которая передается в\r\nthunks и TC.*/\r\nimport {Dispatch} from 'redux';\r\n\r\n/*Создаем тип для объектов, которые будут приходить от сервера и содержать информацию о сообщении из чата, а также в\r\nредьюсере получать новое строковое свойство \"id\" при помощи функции \"v1()\" из библиотеки UUID.*/\r\ntype ChatMessageType = ChatMessageAPIType & { id: string };\r\n\r\ntype InitialChatStateType = typeof initialState;\r\n\r\nlet initialState = {\r\n    /*Свойство для хранения сообщений из чата для вывода их в нашем приложении. Должно быть массивом элементов с типом\r\n    \"ChatMessageType\".*/\r\n    chatMessages: [] as ChatMessageType[],\r\n    /*Это статус готовности WebSocket-канала для отправки информации по нему (изначально \"pending\"). Должен быть типа\r\n    \"WSStatusType\".*/\r\n    WSStatus: 'pending' as WSStatusType\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за чат в нашем приложении.*/\r\nexport const chatReducer = (state = initialState, action: ActionsType): InitialChatStateType => {\r\n    switch (action.type) {\r\n        /*Устанавливаем информацию о сообщениях из чата.*/\r\n        case 'demo-spa/chat-reducer/SET-CHAT-MESSAGES': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Делаем глубокую копию state. Дописываем информацию о новых сообщениях из чата в state (то есть не\r\n                затираем старую информацию).\r\n\r\n                Сначала мапим массив сообщений для чата, которые хотим добавить в state, и добавляем к каждому элементу\r\n                массива (а это у нас объекты) свойство \"id\", формируемое при помощи функции \"v1()\" из библиотеки UUID\r\n                для создания универсальных уникальных идентификаторов. В итоге каждое сообщение для чата будет иметь\r\n                свой уникальный индекс под свойством \"id\".\r\n\r\n                Нам это необходимо, чтобы избежать лишних перерисовок, так как без уникальных идентификаторов при\r\n                удалении одного сообщения из чата менялись бы индексы у всех остальных сообщений в чате (уменьшались бы\r\n                на 1), что вызывало бы многократные перерисовки.\r\n\r\n                Далее при помощи метода \"filter()\" (первым параметром приходят элементы массива, вторым параметром\r\n                приходят их индексы, а третьим параметром приходит сам массив) оставляем только те сообщения, индекс\r\n                которых больше или равен значению, получаемого из разности длины массива (то есть сколько всего\r\n                сообщений для чата у нас есть в state) и числа 100. Чем большее число мы вычтем, тем меньшее число мы\r\n                получим, значит тем большее количество индексов будет, соответственно, тем больше выведется сообщений в\r\n                чате. Но сервер хранит не больше 100 сообщений, поэтому больше 100 сообщений мы вывести не сможем. Все\r\n                это мы делаем для регулировки максимального количества выведенных сообщений в чате.*/\r\n                chatMessages: [\r\n                    ...state.chatMessages,\r\n                    ...action.chatMessages.map(m => {\r\n                        return {...m, id: v1()}\r\n                    })\r\n                ]\r\n                    .filter((m, index, array) => index >= array.length - 100)\r\n            };\r\n        }\r\n\r\n        /*Обнуляем информацию о сообщениях из чата.*/\r\n        case 'demo-spa/chat-reducer/CLEAR-CHAT-MESSAGES': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Обнуляем информацию о сообщениях из чата в state.*/\r\n                chatMessages: []\r\n            };\r\n        }\r\n\r\n        /*Указываем статус готовности WebSocket-канала для отправки информации по нему.*/\r\n        case 'demo-spa/chat-reducer/SET-WS-STATUS': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Указываем статус готовности WebSocket-канала для отправки информации по нему в state.*/\r\n                WSStatus: action.WSStatus\r\n            };\r\n        }\r\n\r\n        default: {\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\ntype ActionsType = InferActionsTypes<typeof chatAC>;\r\n\r\nexport const chatAC = {\r\n    /*AC для установки сообщений для чата в state. На входе получает информацию о сообщениях для чата как массив\r\n    элементов с типом \"ChatMessageAPIType\".*/\r\n    setChatMessages: (chatMessages: ChatMessageAPIType[]) => ({\r\n        type: 'demo-spa/chat-reducer/SET-CHAT-MESSAGES',\r\n        /*Это равносильно \"chatMessages: chatMessages\". Создаем свойство, которое содержит информацию о сообщениях для\r\n        чата.*/\r\n        chatMessages\r\n    } as const),\r\n\r\n    /*AC для обнуления сообщений для чата в state.*/\r\n    clearChatMessages: () => ({\r\n        type: 'demo-spa/chat-reducer/CLEAR-CHAT-MESSAGES'\r\n    } as const),\r\n\r\n    /*AC для указания статуса готовности WebSocket-канала для отправки информации по нему в state. На входе получает\r\n    такой статус типа \"WSStatusType\".*/\r\n    setWSStatus: (WSStatus: WSStatusType) => ({\r\n        type: 'demo-spa/chat-reducer/SET-WS-STATUS',\r\n        /*Создаем свойство, которое содержит статус готовности WebSocket-канала для отправки информации по нему.*/\r\n        WSStatus\r\n    } as const)\r\n};\r\n\r\ntype ThunkType = BaseThunkType<ActionsType>;\r\n\r\n/*Создаем вспомогательную функцию \"_newChatMessagesHandler()\", которая будет хранить в себе функцию перехватчика\r\nсообщений для чата по WebSocket-каналу. Такая функция должна быть типа \"ChatMessagesReceivingSubscriberType\", или null,\r\nто есть отсутствовать.*/\r\nlet _newChatMessagesHandler: ChatMessagesReceivingSubscriberType | null = null;\r\n\r\n/*Создаем вспомогательную функцию (высшего порядка) \"newChatMessagesHandlerCreator()\", которая будет проверять есть ли у\r\nнас уже перехватчик сообщений для чата, и если нет, то будет присваивать и возвращать такой перехватчик, который будет\r\nполучать сообщения для чата и устанавливать их в state при помощи AC \"setChatMessages()\". Здесь нам нужна указанная\r\nпроверка, так как мы вызываем эту функцию в нескольких местах (при подписке и отписке), поэтому получаем одну и туже\r\nфункцию несколько раз, соответственно, если уже есть перехватчик сообщений для чата, то для исключения упомянутых\r\nповторов в таком случае просто возвращаем уже существующий перехватчик сообщений для чата (это похоже на мемоизацию).*/\r\nconst newChatMessagesHandlerCreator = (dispatch: Dispatch) => {\r\n    if (_newChatMessagesHandler === null) {\r\n        _newChatMessagesHandler = (chatMessages) => { dispatch(chatAC.setChatMessages(chatMessages)) };\r\n    }\r\n\r\n    return _newChatMessagesHandler;\r\n};\r\n\r\n/*Создаем вспомогательную функцию \"_WSStatusChangingHandler()\", которая будет хранить в себе функцию перехватчика\r\nизменений статуса готовности WebSocket-канала для отправки информации по нему. Такая функция должна быть типа\r\n\"WSStatusChangingSubscriberType\", или null, то есть отсутствовать.*/\r\nlet _WSStatusChangingHandler: WSStatusChangingSubscriberType | null = null;\r\n\r\n/*Создаем вспомогательную функцию (высшего порядка) \"WSStatusChangingHandlerCreator()\", которая будет проверять есть ли\r\nу нас уже перехватчик изменений статуса готовности WebSocket-канала для отправки информации по нему, и если нет, то\r\nбудет присваивать и возвращать такой перехватчик, который будет получать указанный статус и устанавливать его в state\r\nпри помощи AC \"setWSStatus()\". Здесь нам нужна указанная проверка, так как мы вызываем эту функцию в нескольких местах\r\n(при подписке и отписке), поэтому получаем одну и туже функцию несколько раз, соответственно, если уже есть перехватчик\r\nсообщений для чата, то для исключения упомянутых повторов в таком случае просто возвращаем уже существующий перехватчик\r\nсообщений для чата (это похоже на мемоизацию).*/\r\nconst WSStatusChangingHandlerCreator = (dispatch: Dispatch) => {\r\n    if (_WSStatusChangingHandler === null) {\r\n        _WSStatusChangingHandler = (WSStatus) => { dispatch(chatAC.setWSStatus(WSStatus)) };\r\n    }\r\n\r\n    return _WSStatusChangingHandler;\r\n};\r\n\r\n/*Это TC для инициализации WebSocket-канала, установки информации по сообщениям для чата в state, которые будут\r\nполучаться через этот WebSocket-канал, и установки статуса готовности WebSocket-канала для отправки информации по нему в\r\nstate.*/\r\nexport const startGettingChatMessages = (): ThunkType => async (dispatch) => {\r\n    /*Инициализируем WebSocket-канал для получения сообщений для чата.*/\r\n    chatAPI.startWSChannel();\r\n    /*Подписываем функцию \"newChatMessagesHandlerCreator()\" на получение новых сообщений для чата, передав в нее\r\n    dispatch-функцию, необходимую ей для ее внутренней работы.*/\r\n    chatAPI.subscribe('chat-messages-receiving', newChatMessagesHandlerCreator(dispatch));\r\n    /*Подписываем функцию \"WSStatusChangingHandlerCreator()\" на изменение статуса готовности WebSocket-канала для\r\n    отправки информации по нему, передав в нее dispatch-функцию, необходимую ей для ее внутренней работы.*/\r\n    chatAPI.subscribe('ws-status-changing', WSStatusChangingHandlerCreator(dispatch));\r\n};\r\n\r\n/*Это еще одна реализации отписки, продолжение ниже в TC \"stopGettingChatMessages()\".*/\r\n// const unsubscribe = chatAPI.subscribe(newChatMessagesHandlerCreator);\r\n\r\n/*Это TC для закрытия WebSocket-канала, остановки получения информации по сообщениям для чата, которые получались через\r\nэтот WebSocket-канал, остановки получения статуса готовности WebSocket-канала для отправки информации по нему.*/\r\nexport const stopGettingChatMessages = (): ThunkType => async (dispatch) => {\r\n    /*Отписываем функцию \"newChatMessagesHandlerCreator()\" от получения новых сообщений для чата, передав в нее\r\n    dispatch-функцию, необходимую ей для ее внутренней работы.*/\r\n    chatAPI.unsubscribe('chat-messages-receiving', newChatMessagesHandlerCreator(dispatch));\r\n    /*Отписываем функцию \"WSStatusChangingHandlerCreator()\" от получения статуса готовности WebSocket-канала для\r\n    отправки информации по нему, передав в нее dispatch-функцию, необходимую ей для ее внутренней работы.*/\r\n    chatAPI.unsubscribe('ws-status-changing', WSStatusChangingHandlerCreator(dispatch));\r\n    /*Закрываем WebSocket-канал, чтобы прекратить получение сообщений для чата.*/\r\n    chatAPI.stopWSChannel();\r\n    /*Обнуляем информацию о сообщениях из чата в state при помощи AC \"clearChatMessages()\", чтобы не получить несколько\r\n    копий сообщений в чате на случай если мы потом переподключаемся к WebSocket-каналу.*/\r\n    dispatch(chatAC.clearChatMessages());\r\n\r\n    /*Продолжение еще одной реализации отписки выше.*/\r\n    // unsubscribe();\r\n};\r\n\r\n/*Это TC для отправки сообщений в чат по WebSocket-каналу. На входе получает сообщение для чата, которое должно быть\r\nстрокой.*/\r\nexport const sendChatMessage = (chatMessage: string): ThunkType => async (dispatch) => {\r\n    /*Отправляем наше сообщение в чат.*/\r\n    chatAPI.sendChatMessage(chatMessage);\r\n};","/*Импортируем из ассетов проекта аватар пользователя.*/\r\nimport avatarSource from '../assets/images/user.png';\r\n/*Импортируем тип \"InferActionsTypes\".*/\r\nimport {InferActionsTypes} from './redux-store';\r\n\r\nexport type InitialDialogsStateType = typeof initialState;\r\n\r\n/*Создаем тип для объектов с данными для диалога.*/\r\ntype DialogType = {\r\n    /*ID диалога должно быть числом.*/\r\n    id: number\r\n    /*Имя, с кем ведется диалог, должно быть строкой.*/\r\n    name: string\r\n    /*Аватар того, с кем ведется диалог, получаем на основе самого изображения аватара при помощи typeof.*/\r\n    avatar: typeof avatarSource\r\n};\r\n\r\n/*Создаем тип для объектов с данными для исходящих сообщений в диалогах.*/\r\ntype MessageType = {\r\n    /*ID исходящего сообщения должно быть числом.*/\r\n    id: number\r\n    /*Текст исходящего сообщения должно быть строкой.*/\r\n    message: string\r\n    /*Аватар того, от кого отправлено исходящее сообщение, получаем на основе самого изображения аватара при помощи\r\n    typeof.*/\r\n    avatar: typeof avatarSource\r\n};\r\n\r\n/*Создаем тип для объектов с данными для входящих сообщений в диалогах.*/\r\ntype IncomingMessageType = {\r\n    /*ID входящего сообщения должно быть числом.*/\r\n    id: number\r\n    /*Текст входящего сообщения должно быть строкой.*/\r\n    message: string\r\n    /*Аватар того, от кого отправлено входящее сообщение, получаем на основе самого изображения аватара при помощи\r\n    typeof.*/\r\n    avatar: typeof avatarSource\r\n};\r\n\r\nlet initialState = {\r\n    /*Создаем массив объектов, которые хранят информацию о диалогах на странице диалогов. Указываем, что этот массив\r\n    объектов имеет тип массива элементов с типом \"DialogType\".*/\r\n    dialogs: [\r\n        {id: 1, name: 'Abba', avatar: avatarSource},\r\n        {id: 2, name: 'Bret', avatar: avatarSource},\r\n        {id: 3, name: 'Carry', avatar: avatarSource},\r\n        {id: 4, name: 'Daemon', avatar: avatarSource},\r\n        {id: 5, name: 'Eric', avatar: avatarSource},\r\n        {id: 6, name: 'Frye', avatar: avatarSource}\r\n    ] as Array<DialogType>,\r\n\r\n    /*Создаем массив объектов, которые хранят информацию об исходящих сообщениях в диалогах на странице диалогов.\r\n    Указываем, что этот массив объектов имеет тип массива элементов с типом \"MessageType\".*/\r\n    messagesData: [\r\n        {id: 1, message: 'Hi', avatar: avatarSource},\r\n        {id: 2, message: '..', avatar: ''},\r\n        {id: 3, message: 'Fine', avatar: avatarSource},\r\n        {id: 4, message: 'You?', avatar: avatarSource}\r\n    ] as Array<MessageType>,\r\n\r\n    /*Создаем массив объектов, которые хранят информацию о входящих сообщениях в диалогах на странице диалогов.\r\n    Указываем, что этот массив объектов имеет тип массива элементов с типом \"IncomingMessageType\".*/\r\n    incomingMessagesData: [\r\n        {id: 1, message: '..', avatar: ''},\r\n        {id: 2, message: 'How are you?', avatar: avatarSource},\r\n        {id: 3, message: '..', avatar: ''},\r\n        {id: 4, message: '..', avatar: ''},\r\n        {id: 5, message: 'OK', avatar: avatarSource}\r\n    ] as Array<IncomingMessageType>\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за страницу диалогов.*/\r\nexport const dialogsReducer = (state = initialState, action: ActionsType): InitialDialogsStateType => {\r\n    switch (action.type) {\r\n        /*Добавляем новое исходящее сообщение на странице диалогов.*/\r\n        case 'demo-spa/dialogs-reducer/ADD-MESSAGE': {\r\n            /*Создаем новое исходящее сообщение в виде объекта.*/\r\n            const newMessage = {\r\n                /*Указываем ID исходящего сообщения.*/\r\n                id: 6,\r\n                /*Указываем текст исходящего сообщения.*/\r\n                message: action.newMessageText,\r\n                /*Указываем аватар пользователя, который будет отрисовываться рядом с исходящим сообщением.*/\r\n                avatar: avatarSource\r\n            };\r\n\r\n            /*Добавляем это новое исходящее сообщение в state.*/\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Делаем глубокую копию state. Добавляем данные для нового исходящего сообщения в диалогах в state.*/\r\n                messagesData: [...state.messagesData, newMessage]\r\n            };\r\n        }\r\n\r\n        default: {\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\ntype ActionsType = InferActionsTypes<typeof dialogsAC>;\r\n\r\nexport const dialogsAC = {\r\n    /*AC для добавления нового исходящего сообщения. На входе получает \"newMessageText\", которое должно быть строкой.*/\r\n    addMessage: (newMessageText: string) => ({\r\n        type: 'demo-spa/dialogs-reducer/ADD-MESSAGE',\r\n        /*Создаем свойство, которое содержит текст исходящего сообщения.*/\r\n        newMessageText\r\n    } as const)\r\n};","/*Этот файл был специально создан для описания в одном месте всех AJAX-запросов на сервер, чтобы компоненты не создавали\r\nside effects такого типа. Этот файл отвечает за DAL - Data Access Layer. Правда в дальнейшем сами запросы мы перенесли в\r\nотдельные файлы по категориям.\r\n\r\nCookie - это файл, который цепляется ко всем запросам на сервер. Cookie-файлы связаны с идентификацией пользователя.\r\nСервер при подтверждении пользователя записывает идентификатор пользователя в cookie-файлы и отправляет в закодированном\r\nвиде (в нашем случае в незакодированном) пользователю. Далее эти cookie-файлы записываются браузером до тех пор, пока не\r\nистечет срок их жизни, который в них установлен. Галочка \"Запомнить меня?\" - это про срок жизни cookie-файлов.\r\n\r\nВ дальнейшем при общении с сервером в cookie-файлах будет использоваться идентификатор пользователя. Таким образом,\r\nсервер сможет определять пользователя. Кодировать или декодировать идентификатор может только сервер.\r\n\r\nДля каждого домена создаются отдельные cookie-файлы. Запрещено делать кросс-доменные запросы, за исключением если домен\r\nдал на это разрешение. Это важно поскольку наше приложение находится на локальном хосте и мы делаем запросы на другой\r\nдомен из нашего приложения. При кроссдоменных запросах, перед основным запросом, браузер отправляет OPTIONS-запрос для\r\nполучения разрешения от сервера на осуществление кроссдоменных запросов. Это часть CORS - политики безопасности\r\nбраузера.\r\n\r\nЧтобы залогиниться в нашем приложении нужно сначала залогиниться на сайте API: https://social-network.samuraijs.com/.\r\n\r\nНастройки в POST-запросе передаются третьим параметром. Настройки в GET-запросе и DELETE-запросе передаются вторым\r\nпараметром. GET-запросы и DELETE-запросы ничего не могут передать на сервер, кроме адресной строки самого URL-адреса.\r\nPOST-запросы и PUT-запросы могут отправлять на сервер разные данные, некий \"payload\" (например, фото или текст).\r\n\r\nВсе запросы, кроме GET-запросов, требуют обязательного ключа доступа, который, в нашем случае, генерируется на сайте\r\nAPI: https://social-network.samuraijs.com/account. Такие ключи указываются в параметрах запросов в свойстве \"headers\".\r\n\r\nПри осуществлении запросов в нашем приложении можно получить ошибку 429, которая означает, что превышен лимит запросов.\r\nДля снятия этого ограничения нужно купить Premium-аккаунт на сайте API (уже, вроде, неактуально, так как часть\r\nограничений была снята).\r\n\r\nБиблиотека Axios нужна для работы с запросами на сервер. Запросы осуществляются на endpoints, которые представляют собой\r\nURL.\r\n\r\nНаш API сервера находится здесь: \"https://social-network.samuraijs.com/docs\". У каждого API сервера есть базовый URL, в\r\nнашем случае это \"https://social-network.samuraijs.com/api/1.0/\". К базовому URL дописываются определенные элементы\r\n(например, \"/users\"), чтобы получить какую-то категорию данных.\r\n\r\nВ нашем случае мы получаем ответы от сервера в формате JSON.\r\n\r\nСуществует подход \"API first\": сначала создается API, а потом уже front-end и back-end.\r\n\r\nВ библиотеке Axios любой GET-запрос, POST-запрос или PUT-запрос являются generic и возвращают промис, который можно\r\nуточнить при помощи Typescript.*/\r\nimport axios from 'axios';\r\n\r\n/*Создаем \"instance\" (экземпляр). Метод \"axios.create()\" позволяет создавать экземпляры из Axios. Этот экземпляр будет\r\nсодержать необходимые параметры для наших запросов.*/\r\nexport const instance = axios.create({\r\n    /*Указываем, чтобы к запросам прикреплялись cookie-файлы.*/\r\n    withCredentials: true,\r\n    /*Указываем базовый URL. Используем обратные кавычки ``, чтобы можно было использовать спецсимволы.*/\r\n    baseURL: `https://social-network.samuraijs.com/api/1.0/`,\r\n    /*Указываем обязательный ключ доступа, который сгенерирован на сайте API. В целях безопасности, нужно удалять при\r\n    осуществлении коммитов.*/\r\n    headers: {\r\n        'API-KEY': 'd621d468-c2ab-4a1a-a36b-de2dead20aeb'\r\n    }\r\n});\r\n\r\n/*enum в TS перечисляет строки или числа. При помощи enum создаем список кодов ответа от сервера, которые используются в\r\nTC \"getAuthUserData()\" и в \"login()\" в файле \"auth-reducer.ts\".*/\r\nexport enum ResultCodeEnum {\r\n    Success = 0,\r\n    Error = 1\r\n};\r\n\r\n/*Создаем список кодов ответа от сервера, которые используются в TC \"login()\" в файле \"auth-reducer.ts\".*/\r\nexport enum ResultCodeForCaptchaEnum {\r\n    CaptchaIsRequired = 10\r\n};\r\n\r\n/*Создаем общий тип для ответов от сервера, где ответ имеет следующую структуру:\r\n1. \"items\" - массив каких-то элементов.\r\n2. \"totalCount\" - количество этих элементов.\r\n3. \"error\" - какое-то информационное сообщение об ошибке.\r\n\r\nЭтот тип используется в типе \"GetUsersType\" в файле \"users-api.ts\".*/\r\nexport type ResponseWithItemsType<T> = {\r\n    items: Array<T>\r\n    totalCount: number\r\n    error: string | null\r\n};\r\n\r\n/*Создаем общий тип для ответов от сервера, где ответ имеет следующую структуру:\r\n1. \"data\" - объект, содержащий какие-то данные.\r\n2. \"resultCode\" - код какой-то ошибки.\r\n3. \"messages\" - массив с какими-то информационными сообщениями об ошибке, например:\r\n    1) при какой-либо ошибке во время залогинивания в запросах \"me()\" и \"login()\" из файла \"auth-api.ts\";\r\n    2) при какой-либо ошибке во время разлогинивания в запросе \"logout()\" из файла \"auth-api.ts\";\r\n    3) при какой-либо ошибке во время фолловинга/анфолловинга пользователя в запросах \"follow()\" и \"unfollow()\" из файла\r\n    \"users-api.ts\";\r\n    4) при какой-либо ошибке во время обновления статуса пользователя в запросе \"updateUserStatus()\" из файла\r\n    \"profile-api.ts\";\r\n    5) при какой-либо ошибке во время сохранения фото пользователя в запросе \"saveUserPhoto()\" из файла\r\n    \"profile-api.ts\";\r\n    6) при какой-либо ошибке во время сохранения данных профиля в запросе \"saveProfile()\" из файла \"profile-api.ts\".\r\n\r\nДанный тип является generic, в котором мы уточняем \"D\" - наша \"data\" (по умолчанию это пустой объект) и \"RC\" - наш\r\n\"resultCode\" (по умолчанию список \"ResultCodeEnum\").\r\n\r\nЭтот тип используется в запросах:\r\n- GET в запросе \"me()\" в файле \"auth-api.ts\";\r\n- POST в запросе \"login()\" в файле \"auth-api.ts\";\r\n- DELETE в запросе \"logout()\" в файле \"auth-api.ts\";\r\n- POST в запросе \"follow()\" в файле \"users-api.ts\";\r\n- DELETE в запросе \"unfollow()\" в файле \"users-api.ts\";\r\n- PUT в запросе \"updateUserStatus()\" в файле \"profile-api.ts\";\r\n- PUT в запросе \"saveUserPhoto()\" в файле \"profile-api.ts\";\r\n- PUT в запросе \"saveProfile()\" в файле \"profile-api.ts\".*/\r\nexport type ResponseWithDataType<D = {}, RC = ResultCodeEnum> = {\r\n    data: D\r\n    resultCode: RC\r\n    messages: Array<string>\r\n};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"preloader\":\"Preloader_preloader__1UVoj\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"Header_header__N7XTU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"menu\":\"Navbar_menu__1qyUG\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"userPhoto\":\"User_userPhoto__1FgRj\"};","export default __webpack_public_path__ + \"static/media/user.ad89b36a.png\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"userInfo\":\"UserInfo_userInfo__1A3a8\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"timerSeconds\":\"Timer_timerSeconds__39z0r\"};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","/*Импортируем из ассетов проекта аватар пользователя.*/\r\nimport avatarSource from '../assets/images/user.png';\r\n/*Импортируем тип \"AvatarSourceType\".*/\r\nimport {AvatarSourceType} from '../types/types';\r\n\r\nexport type InitialSidebarStateType = typeof initialState;\r\n\r\n/*Создаем тип для объектов с данными по друзьям, которые в онлайне и отображаются в сайдбаре.*/\r\ntype FriendType = {\r\n    /*ID друга в онлайне должно быть числом.*/\r\n    id: number\r\n    /*Имя друга в онлайне должно быть числом.*/\r\n    name: string\r\n    /*Аватар друга в онлайне должен быть типа \"AvatarSourceType\".*/\r\n    avatar: AvatarSourceType\r\n};\r\n\r\nlet initialState = {\r\n    /*Создаем массив объектов, хранящих информацию о друзьях пользователя в онлайне, которые отображаются в сайдбаре.\r\n    Указываем, что этот массив объектов имеет тип массива элементов с типом \"FriendType\".*/\r\n    friendsData: [\r\n        {id: 1, name: 'Abba', avatar: avatarSource},\r\n        {id: 2, name: 'Bret', avatar: avatarSource},\r\n        {id: 3, name: 'Carry', avatar: avatarSource}\r\n    ] as Array<FriendType>\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за сайдбар.*/\r\nexport const sidebarReducer = (state = initialState, action: any): InitialSidebarStateType => {\r\n    /*Этот редьюсер просто возвращает state, никак его не модифицируя.*/\r\n    return state;\r\n};","/*Чтобы избавиться от повторяющегося кода в файле \"users-reducer.ts\" в редьюсере в разделах \"FOLLOW\" и \"UNFOLLOW\", мы\r\nсоздали этот файл, который содержит общую логику для разделов \"FOLLOW\" и \"UNFOLLOW\". При помощи этой логики можно\r\nперебирать элементы (объекты) в любом массиве и менять какое-либо свойство при срабатывании условия у какого-то элемента\r\n(объекта) в этом массиве.*/\r\n\r\n/*Убрали в этой функции стрелочный синтаксис и типизировали ее следующим образом. Эта функция имеет три уточняющих тип\r\nпараметра \"T\", \"K\" и \"P\".\r\n\r\nУточняющий тип параметр \"T\" указывает какой тип имеют элементы в массиве элементов первого параметра \"items\" этой\r\nфункции. В случае использования этой функции в рамках фолловинга/анфолловинга пользователей это должен быть тип\r\n\"UserType\", так как первым параметром мы передаем в эту функцию массив объектов с типом \"UserType\", где каждый объект\r\nпредставляет собой информацию о каком-то пользователе. Следовательно, на этот параметр \"T\" установлено ограничение, что\r\nэтот тип должен быть похож на какой-либо объект.\r\n\r\nВторым уточняющим тип параметром \"K\" мы должны указывать тип ключа из объектов массива из первого уточняющего тип\r\nпараметра \"T\", так как третьим параметром в эту функцию мы передаем \"objPropName\" - имя свойства в объектах, по которому\r\nидет проверка сравнением, в случае фолловинга/анфолловинга пользователей это строковое значение \"id\". Чтобы получить\r\nключи объектов с типом \"T\" мы используем \"keyof T\". Это выдаст все ключи, например, того же типа \"UserType\": \"name\",\r\n\"id\", \"photos\", \"status\", \"followed\". И опять же, в случае фолловинга/анфолловинга пользователей мы передаем третьим\r\nпараметром строковое значение \"id\", что будет совпадать с одним из этих полученных ключей. Следовательно, на параметр\r\n\"K\" установлено ограничение, что это тип должен быть ключами первого параметра \"T\", то есть \"keyof T\", и в случае\r\nфолловинга/анфолловинга пользователей мы укажем \"keyof UserType\".\r\n\r\nВторым параметром в эту функцию мы передаем \"itemID\" - значение для сравнения при поиске нужного объекта в массиве, в\r\nслучае фолловинга/анфолловинга пользователей это ID пользователя для фолловинга/анфолловинга. Следовательно, его тип\r\nуказан как \"T[K]\", так как опять же в случае фолловинга/анфолловинга пользователей это будет выглядеть как\r\n\"UserType['id']\", что равно \"UserType.id\", то есть мы получим значение свойства \"id\" в объекте с типом \"UserType\",\r\nсодержащем информацию по пользователю, которого мы пытаемся зафолловить или перестать фолловить.\r\n\r\nТретьим уточняющим тип параметром \"P\" мы должны указывать тип объекта, передаваемый в эту функцию четвертым параметром\r\n\"newObjProps\", со свойствами и их значениями. Этот объект нужно подменить на место старого в найденном объекте, в случае\r\nфолловинга/анфолловинга пользователей мы должны поменять \"{followed: false}\" на \"{followed: true}\" для фолловинга и\r\n\"{followed: true}\" на \"{followed: false}\" для анфолловинга в найденном объекте с типом \"UserType\", содержащем информацию\r\nпо пользователю, которого мы пытаемся зафолловить или перестать фолловить. Следовательно, четвертый параметр\r\n\"newObjProps\" в этой функции, опять же, в случае фолловинга/анфолловинга пользователей должен быть одним из свойств\r\nобъекта с типом \"UserType\" - свойством \"followed\", поэтому на уточняющий тип параметр \"P\" уставлено ограничение, что он\r\nчастично или полностью должен копировать первый уточняющий параметр \"T\", то есть в случае фолловинга/анфолловинга\r\nпользователей тип \"UserType\", который как раз содержит свойство \"followed\". Это мы делаем при помощи Partial из\r\nTypescript - \"P extends Partial<T>\", и в случае фолловинга/анфолловинга пользователей мы указываем \"Partial<UserType>\".\r\n\r\nТакже в этой функции указано, что на выходе мы возвращаем массив объектов с типом \"T\", так как суть этой функции взять\r\nмассив каких-то объектов с определенным типом, найти какой-то интересующий нас объект среди этих объектов, у этого\r\nобъекта поменять значение какого-то свойство или значения нескольких каких-то свойств, и вернуть снова массив каких-то\r\nобъектов с тем же типом, в котором мы изменили какой-то один объект. То есть, в случае фолловинга/анфолловинга\r\nпользователей на входе мы даем \"Array<UserType>\" и на выходе должны получить \"Array<UserType>\".*/\r\nexport function updateObjectInArray<\r\n    T extends {},\r\n    K extends keyof T,\r\n    P extends Partial<T>\r\n>(\r\n    /*\"items\" - будет получать массив объектов (информация о пользователях для постраничного вывода из state для\r\n    разделов \"FOLLOW\" и \"UNFOLLOW\" в редьюсере).*/\r\n    items: Array<T>,\r\n    /*\"itemID\" - значение для сравнения при поиске нужного объекта в массиве (ID пользователя для\r\n    фолловинга/анфолловинга из action-объекта для разделов \"FOLLOW\" и \"UNFOLLOW\" в редьюсере).*/\r\n    itemID: T[K],\r\n    /*\"objPropName\" - имя свойства в объектах, по которому идет проверка сравнением (\"id\" для разделов \"FOLLOW\" и\r\n    \"UNFOLLOW\" в редьюсере).*/\r\n    objPropName: K,\r\n    /*\"newObjProps\" - объект со свойствами и их значениями, который нужно подменить на место старого в найденном объекте\r\n    (\"{followed: true}\" для фолловинга и \"{followed: false}\" для анфолловинга для разделов \"FOLLOW\" и \"UNFOLLOW\" в\r\n    редьюсере).*/\r\n    newObjProps: P\r\n): Array<T> {\r\n    /*Мапим полученный массив объектов. \"u\" - это каждый элемент массива. Метод \"map()\" возвращает новый массив в итоге\r\n    на основе полученного массива.*/\r\n    return items.map(u => {\r\n        /*Вспоминаем, что \"u.id\" и \"u[\"id\"]\" это одно и тоже. Если у какого-либо элемента (объекта, содержащего\r\n        информацию о пользователе для постраничного вывода в случае для разделов \"FOLLOW\" и \"UNFOLLOW\" в редьюсере)\r\n        массива указанное свойство \"objPropName\" (\"u.id\", то есть ID пользователя в случае для разделов \"FOLLOW\" и\r\n        \"UNFOLLOW\" в редьюсере) равно значению для сравнения \"itemID\" (из action-объекта там будет ID пользователя для\r\n        фолловинга/анфолловинга для разделов \"FOLLOW\" и \"UNFOLLOW\" в редьюсере),*/\r\n        if (u[objPropName] === itemID) {\r\n            /*то делаем деструктуризацию этого элемента (объекта, содержащего информацию о пользователе для\r\n            постраничного вывода в случае для разделов \"FOLLOW\" и \"UNFOLLOW\" в редьюсере) и подменяем ему указанное\r\n            свойство со значением в \"newObjProps\" вместо старого значения этого свойства (\"{followed: true}\" для\r\n            фолловинга и \"{followed: false}\" для анфолловинга для разделов \"FOLLOW\" и \"UNFOLLOW\" в редьюсере).\r\n\r\n            В итоге метод \"map()\" соберет новый массив с теми же объектами, где у одного из них измениться значение\r\n            одного из свойств (\"{followed: true}\" для фолловинга и \"{followed: true}\" для анфолловинга для разделов\r\n            \"FOLLOW\" и \"UNFOLLOW\" в редьюсере).*/\r\n            return {...u, ...newObjProps}\r\n        }\r\n\r\n        /*Если же условие выше не срабатывает, то метод \"map()\" вернет элемент массива как есть.*/\r\n        return u;\r\n    });\r\n};","/*Импортируем два общих типа \"ResponseWithDataType\" и \"ResponseWithItemsType\" для некоторых ответов от сервера со схожей\r\nструктурой ответа.*/\r\nimport {instance, ResponseWithDataType, ResponseWithItemsType} from './api';\r\n/*Импортируем тип \"UserType\".*/\r\nimport {UserType} from '../types/types';\r\n\r\n/*Объект \"usersAPI\" содержит запросы, связанные со страницей с постраничным выводом пользователей.*/\r\nexport const usersAPI = {\r\n    /*Эта функция является запросом на получение данных пользователей в постраничном выводе. Эти данные на сервере\r\n    структурированы по страницам, поэтому данная функция принимает четыре параметра:\r\n    1. \"currentPage\" - текущая страница для отображения (1 по умолчанию), должно быть числом.\r\n    2. \"pageSize\" - количество пользователей на этой странице (от 10 по умолчанию до 100), должно быть числом.\r\n    3. \"term\" - фильтр в виде строкового значения, которое сервер будет получать и искать наличие этого значения в\r\n    именах всех пользователей, чтобы в итоге вывести только таких пользователей (по умолчанию указана пустая строка).\r\n    4. \"friend\" - еще один фильтр булева типа или типа null, если указать в нем true, то сервер выберет только тех\r\n    пользователей, которых мы фолловим, если указать false - только тех, кого мы не фолловим, если указать null или\r\n    вообще не указывать, то выберет всех пользователей (по умолчанию указано null).*/\r\n    getUsers(currentPage: number, pageSize: number, term: string = '', friend: null | boolean = null) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы получить данные пользователей. Знак \"?\"\r\n            означает, что дальше идут параметры GET-запроса. Знак \"&\" используется для перечисления таких параметров.\r\n            Названия этих параметров и ограничения их значений описываются в API сервера.\r\n\r\n            \"+ (friend === null ? '' : `&friend=${friend}`\" - здесь мы склеиваем строку с пустой строкой, если параметр\r\n            \"friend\" равен null, иначе склеиваем со строками `&friend=true` или `&friend=false`, если в параметре\r\n            \"friend\" указали true или false соответственно.\r\n\r\n            Также указываем, что этот GET-запрос возвращает промис с типом \"ResponseWithItemsType<UserType>\".*/\r\n            instance.get<ResponseWithItemsType<UserType>>(\r\n                `users?page=${currentPage}&count=${pageSize}&term=${term}` + (friend === null ? '' : `&friend=${friend}`\r\n                ))\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"items\" - массив с объектами, которые содержат данные по пользователям. Каждый такой объект содержит\r\n                следующее:\r\n                  1) \"name\" - имя пользователя.\r\n                  2) \"id\" - ID пользователя.\r\n                  3) \"photos\": - объект с путями к фото пользователя.\r\n                    a. \"small\" - уменьшенное фото.\r\n                    b. \"large\" - увеличенное фото.\r\n                  3) \"status\" - статус пользователя.\r\n                  4) \"followed\" - говорит фолловим ли мы пользователя или нет.\r\n                3. \"totalCount\" - количество всех пользователей.\r\n                4. \"error\" - содержит сообщение об ошибке, если была.\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"requestUsers()\".*/\r\n                .then(response => { return response.data })\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на анфолловинг какого-либо пользователя. Оба запроса на анфолловинг и фолловинг идут\r\n    на один и тот же endpoint, только для анфолловинга нужно делать DELETE-запрос, а для фолловинга нужно делать\r\n    POST-запрос. Также в обоих случаях нужно указывать ID пользователя, которого анфолловим или фолловим. Этот параметр\r\n    должен быть числом. Все это указано в API сервера. При помощи cookie-файлов сервер будет определять нас и знать для\r\n    какого пользователя сделать фолловинг или анфолловинг.*/\r\n    unfollow(id: number) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы сформировать запрос на анфолловинг.\r\n            Указываем, что этот DELETE-запрос возвращает промис с типом \"ResponseWithDataType\".*/\r\n            instance.delete<ResponseWithDataType>(`follow/${id}`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя (0 - все хорошо, 1 -\r\n                какая-то ошибка).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время анфолловинга пользователя).\r\n                3. \"data\" - какие-то дополнительные данные (в данный момент не используется).\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить анфолловинг\r\n                пользователя при помощи TC \"unfollow()\".*/\r\n                .then(response => { return response.data })\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на фолловинг какого-либо пользователя. Оба запроса на анфолловинг и фолловинг идут\r\n    на один и тот же endpoint, только для анфолловинга нужно делать DELETE-запрос, а для фолловинга нужно делать\r\n    POST-запрос. Также в обоих случаях нужно указывать ID пользователя, которого анфолловим или фолловим. Этот параметр\r\n    должен быть числом. Все это указано в API сервера. При помощи cookie-файлов сервер будет определять нас и знать для\r\n    какого пользователя сделать фолловинг или анфолловинг.*/\r\n    follow(id: number) {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы сформировать запрос на фолловинг.\r\n            Указываем, что этот POST-запрос возвращает промис с типом \"ResponseWithDataType\".*/\r\n            instance.post<ResponseWithDataType>(`follow/${id}`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя (0 - все хорошо, 1 -\r\n                какая-то ошибка).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время фолловинга пользователя).\r\n                3. \"data\" - какие-то дополнительные данные (в данный момент не используется).\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить фолловинг\r\n                пользователя при помощи TC \"follow()\".*/\r\n                .then(response => {\r\n                    return response.data;\r\n                })\r\n        );\r\n    }\r\n};","/*Импортируем вспомогательную функцию, которая содержит общую логику для \"FOLLOW\" и \"UNFOLLOW\" в редьюсере.*/\r\nimport {updateObjectInArray} from '../utils/helpers/object-helpers';\r\n/*Импортируем блок запросов, связанных со страницей с постраничным выводом пользователей.*/\r\nimport {usersAPI} from '../api/users-api';\r\n/*Импортируем списки кодов ответов от сервера.*/\r\nimport {ResponseWithDataType, ResultCodeEnum} from '../api/api';\r\n/*Импортируем тип \"UserType\".*/\r\nimport {UserType} from '../types/types';\r\n/*Импортируем типы \"InferActionsTypes\", \"BaseThunkType\" и \"BaseDispatchType\".*/\r\nimport {InferActionsTypes, BaseThunkType, BaseDispatchType} from './redux-store';\r\n\r\nexport type InitialUsersStateType = typeof initialState;\r\n\r\n/*Создаем отдельный тип для данных из state, которые отвечают за фильтрацию пользователей в постраничном выводе.*/\r\nexport type UsersFilterType = typeof initialState.filter;\r\n\r\nlet initialState = {\r\n    /*Свойство, которое будет хранить объекты с информацией о пользователях для постраничного вывода, полученные с\r\n    сервера. Указываем, что этот массив объектов имеет тип массива элементов с типом \"UserType\".*/\r\n    users: [] as Array<UserType>,\r\n    /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводиться на одной\r\n    странице в постраничном выводе пользователей.*/\r\n    pageSize: 30,\r\n    /*Свойство, которое хранит значение, обозначающее общее количество пользователей. Получается с сервера.*/\r\n    totalUsersCount: 0,\r\n    /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в постраничном выводе\r\n    пользователей.*/\r\n    currentPage: 1,\r\n    /*Специальное свойство, обозначающее находится ли в процессе запрос на сервер на получение данных по пользователям\r\n    для постраничного вывода. Если в процессе, то будет отрисовываться компонент-заглушка \"Preloader\".*/\r\n    isFetching: false,\r\n    /*Специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то определенный момент\r\n    находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга\r\n    от пользователя. Указываем, что это свойство имеет тип массива элементов с типом числа.*/\r\n    WhoIsInFollowingProgress: [] as Array<number>,\r\n    /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может отображаться\r\n    в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное количество, а\r\n    имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими\r\n    порциями страниц.*/\r\n    portionSize: 20,\r\n    /*Свойство, содержащее объект, внутри которого указываются фильтры для выборки пользователей в постраничном выводе.\r\n    Это свойство будет использоваться в форме, которая была создана при помощи библиотеки Formik, а для этой библиотеки\r\n    не обязательно хранить значения формы в store из библиотеки Redux. Но мы это делаем, так как эти фильтры будут\r\n    применяться как параметры адресной строки, то есть будут являться данными BLL.*/\r\n    filter: {\r\n        /*Свойство, содержащее значение для фильтра в виде строкового значения, которое будет получать сервер и искать\r\n        наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких пользователей.*/\r\n        term: '',\r\n        /*Свойство, содержащее значение для фильтра булева типа. Если указать в нем true, то сервер выберет только тех\r\n        пользователей, которых мы фолловим, если указать false - только тех, кого мы не фолловим, если указать null или\r\n        вообще не указывать, то выберет всех пользователей.*/\r\n        friend: null as null | boolean\r\n    }\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за страницу постраничного вывода пользователей.*/\r\nexport const usersReducer = (state = initialState, action: ActionsType): InitialUsersStateType => {\r\n    switch (action.type) {\r\n        /*Меняем флаг у пользователя, чтобы указать, что мы его теперь фолловим.*/\r\n        case 'demo-spa/users-reducer/FOLLOW': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Вызываем вспомогательную функцию \"updateObjectInArray()\" и передаем ей:\r\n                1. \"state.users\" - информация о пользователях для постраничного вывода из state.\r\n                2. \"action.userID\" - ID пользователя для фолловинга из action-объекта.\r\n                3. 'id' - имя свойства в объектах, по которому идет проверка сравнением в функции\r\n                \"updateObjectInArray()\".\r\n                4. \"{followed: true}\" - объект со свойствами и их значениями, который нужно подменить на место старого\r\n                в найденном объекте.\r\n\r\n                В результате получаем новый измененным массив объектов с информацией о пользователях для постраничного\r\n                вывода, в котором у одного из пользователей свойство \"followed\" станет true, что будет означать, что\r\n                мы его теперь фолловим.*/\r\n                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>\r\n                (state.users, action.userID, 'id', {followed: true})\r\n            };\r\n        }\r\n\r\n        /*Меняем флаг у пользователя, чтобы указать, что мы больше его не фолловим.*/\r\n        case 'demo-spa/users-reducer/UNFOLLOW': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Вызываем вспомогательную функцию \"updateObjectInArray()\" и передаем ей:\r\n                1. \"state.users\" - информация о пользователях для постраничного вывода из state.\r\n                2. \"action.userID\" - ID пользователя для фолловинга из action-объекта.\r\n                3. 'id' - имя свойства в объектах, по которому идет проверка сравнением в функции\r\n                \"updateObjectInArray()\".\r\n                4. \"{followed: false}\" - объект со свойствами и их значениями, который нужно подменить на место старого\r\n                в найденном объекте.\r\n\r\n                В результате получаем новый измененным массив объектов с информацией о пользователях для постраничного\r\n                вывода, в котором у одного из пользователей свойство \"followed\" станет false, что будет означать, что\r\n                мы его больше не фолловим.*/\r\n                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>\r\n                (state.users, action.userID, 'id', {followed: false})\r\n            };\r\n        }\r\n\r\n        /*Добавляем данные о пользователях \"users\" в state, полученные с сервера.*/\r\n        case 'demo-spa/users-reducer/SET-USERS': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Добавляем данные о пользователях \"users\" в state. Здесь мы не добавляем к существующим данным новые.\r\n                Мы затираем старые данные, добавляя новые. Здесь мы не делаем глубокую копию, так как работаем с\r\n                примитивом.*/\r\n                users: action.users\r\n            };\r\n        }\r\n\r\n        /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей в state.*/\r\n        case 'demo-spa/users-reducer/SET-CURRENT-PAGE': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей. Здесь мы не\r\n                делаем глубокую копию, так как работаем с примитивом.*/\r\n                currentPage: action.currentPage,\r\n            };\r\n        }\r\n\r\n        /*Устанавливаем общее количество пользователей в state.*/\r\n        case 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Устанавливаем общее количество пользователей. Здесь мы не делаем глубокую копию, так как работаем с\r\n                примитивом.*/\r\n                totalUsersCount: action.count\r\n            };\r\n        }\r\n\r\n        /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного\r\n        вывода. Если в процессе, то будет отрисовываться компонент-заглушка \"Preloader\".*/\r\n        case 'demo-spa/users-reducer/TOGGLE-IS-FETCHING': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для\r\n                постраничного вывода. Здесь мы не делаем глубокую копию, так как работаем с примитивом.*/\r\n                isFetching: action.isFetching\r\n            };\r\n        }\r\n\r\n        /*Оперируем массивом \"WhoIsInFollowingProgress\" для указания находятся ли или нет какие-либо пользователи в\r\n        процессе анфолловинга/фолловинга.*/\r\n        case 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Если свойство \"isFollowingInProgress\" является true, то делаем глубокую копию и помещаем ID\r\n                пользователя, который находится в процессе анфолловинга/фолловинга в массив \"WhoIsInFollowingProgress\".\r\n                Иначе если свойство \"isFollowingInProgress\" является false, то делаем глубокую копию и удаляем ID этого\r\n                пользователя из массива \"WhoIsInFollowingProgress\" при помощи метода \"filter()\", который создает новый\r\n                массив (тем самым мы делаем копию), в который войдут только те элементы, которые не равны ID указанного\r\n                пользователя.*/\r\n                WhoIsInFollowingProgress: action.isFollowingInProgress\r\n                    ? [...state.WhoIsInFollowingProgress, action.userID]\r\n                    : state.WhoIsInFollowingProgress.filter(id => id !== action.userID)\r\n            };\r\n        }\r\n\r\n        /*Устанавливаем данные по фильтрам для отображения пользователей в постраничном выводе пользователей в state.\r\n        Здесь благодаря деструктуризации мы сможем передать нужные значения свойств из \"payload\" в нужные свойства state\r\n        при совпадении имен свойств.*/\r\n        case 'demo-spa/users-reducer/SET-FILTER': {\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Action-объект будет иметь объект \"payload\", который содержит объект \"filter\" со свойствами \"term\" и\r\n                \"friend\". Делаем глубокую копию, чтобы установить эти данные в state, деструктуризируя этот объект\r\n                \"payload\".*/\r\n                filter: action.payload\r\n            };\r\n        }\r\n\r\n        default: {\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\ntype ActionsType = InferActionsTypes<typeof usersAC>;\r\n\r\nexport const usersAC = {\r\n    /*AC для указания того, что мы зафолловили пользователя. На входе получает \"userID\", которое должно быть числом.*/\r\n    followSuccess: (userID: number) => ({\r\n        type: 'demo-spa/users-reducer/FOLLOW',\r\n        /*ID пользователя, которого мы фолловим.*/\r\n        userID\r\n    } as const),\r\n\r\n    /*AC для указания того, что мы заанфолловили пользователя. На входе получает \"userID\", которое должно быть числом.*/\r\n    unfollowSuccess: (userID: number) => ({\r\n        type: 'demo-spa/users-reducer/UNFOLLOW',\r\n        /*ID пользователя, которого мы анфолловим.*/\r\n        userID\r\n    } as const),\r\n\r\n    /*AC для установки данных пользователей \"users\" в state, которые получены с сервера. На входе получает \"users\",\r\n    которое должно быть массивом с объектами типа \"UserType\".*/\r\n    setUsers: (users: Array<UserType>) => ({\r\n        type: 'demo-spa/users-reducer/SET-USERS',\r\n        /*Данные по пользователям для постраничного вывода пользователей, полученные с сервера.*/\r\n        users\r\n    } as const),\r\n\r\n    /*AC для установки значения текущей выбранной страницы в постраничном выводе пользователей в state. На входе\r\n    получает \"currentPage\", которое должно быть числом.*/\r\n    setCurrentPage: (currentPage: number) => ({\r\n        type: 'demo-spa/users-reducer/SET-CURRENT-PAGE',\r\n        /*Номер выбранной текущей страницы в постраничном выводе пользователей.*/\r\n        currentPage\r\n    } as const),\r\n\r\n    /*AC для установки общего количество пользователей в state. На входе получает \"totalUsersCount\", которое должно быть\r\n    числом.*/\r\n    setTotalUsersCount: (totalUsersCount: number) => ({\r\n        type: 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT',\r\n        /*Значение обозначающее общее количество пользователей.*/\r\n        count: totalUsersCount\r\n    } as const),\r\n\r\n    /*AC для указания находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного\r\n    вывода. Если в процессе, то будет отрисовываться компонент-заглушка \"Preloader\". На входе получает \"isFetching\",\r\n    которое должно быть булева типа.*/\r\n    toggleIsFetching: (isFetching: boolean) => ({\r\n        type: 'demo-spa/users-reducer/TOGGLE-IS-FETCHING',\r\n        /*Специальное свойство, обозначающее находится ли в процессе запрос на сервер на получение данных по\r\n        пользователям для постраничного вывода.*/\r\n        isFetching\r\n    } as const),\r\n\r\n    /*AC для указания находится ли в процессе анфолловинга/фолловинга какой-либо пользователь. Если в процессе, то\r\n    кнопка для анфолловинга/фолловинга будет отключена. На входе получает \"isFollowingInProgress\", которое должно быть\r\n    булева типа. Также на входе получает \"userID\", которое должно быть числом.*/\r\n    toggleIsFollowingInProgress: (isFollowingInProgress: boolean, userID: number) => ({\r\n        type: 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS',\r\n        /*Специальное свойство, указывающее находится ли какой-либо пользователь в процессе анфолловинга/фолловинга.*/\r\n        isFollowingInProgress,\r\n        /*Специальное свойство, указывающее ID пользователя по которому идет проверка находится ли он в процессе\r\n        анфолловинга/фолловинга.*/\r\n        userID\r\n    } as const),\r\n\r\n    /*AC для установки фильтров для отображения пользователей в постраничном выводе пользователей в state. На входе\r\n    получает \"filter\", которое должно быть типа \"UsersFilterType\".*/\r\n    setFilter: (filter: UsersFilterType) => ({\r\n        type: 'demo-spa/users-reducer/SET-FILTER',\r\n        /*Объект с данными по фильтрам для отображения пользователей в постраничном выводе пользователей. Далее мы его\r\n        деструктуризируем в редьюсере \"usersReducer()\".*/\r\n        payload: filter\r\n    } as const)\r\n};\r\n\r\n/*Создаем тип для dispatch-функции, передается в thunks и TC.*/\r\ntype DispatchType = BaseDispatchType<ActionsType>;\r\n/*Создаем тип для thunks.*/\r\ntype ThunkType = BaseThunkType<ActionsType>;\r\n\r\n/*Это TC для запроса и установки данных по пользователям в постраничном выводе.*/\r\nexport const requestUsers = (\r\n    /*Номер текущей выбранной страницы в постраничном выводе пользователей, который должен быть числом.*/\r\n    currentPage: number,\r\n    /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводиться на одной\r\n    странице в постраничном выводе пользователей. Это свойство должно быть числом.*/\r\n    pageSize: number,\r\n    /*Свойство, хранящее данные по фильтрам для отображения пользователей в постраничном выводе пользователей, которое\r\n    должны быть типа \"UsersFilterType\".*/\r\n    filter: UsersFilterType\r\n): ThunkType => async (dispatch) => {\r\n    /*Включаем компонент-заглушку \"Preloader\" перед началом запроса на сервер.*/\r\n    dispatch(usersAC.toggleIsFetching(true));\r\n    /*При помощи AC \"setFilter()\" устанавливаем данные по фильтрам для отображения пользователей в постраничном выводе\r\n    пользователей в state.*/\r\n    dispatch(usersAC.setFilter(filter));\r\n    /*Делаем запрос на сервер для получения данных по пользователям для постраничного вывода и ждем ответа от сервера.*/\r\n    const response = await usersAPI.getUsers(currentPage, pageSize, filter.term, filter.friend);\r\n    /*После получения ответа от сервера, отключаем компонент-заглушку \"Preloader\".*/\r\n    dispatch(usersAC.toggleIsFetching(false));\r\n    /*При помощи AC \"setUsers()\" устанавливаем данные по пользователям для постраничного вывода в state.*/\r\n    dispatch(usersAC.setUsers(response.items));\r\n    /*Устанавливаем общее количество пользователей в state.*/\r\n    dispatch(usersAC.setTotalUsersCount(response.totalCount));\r\n};\r\n\r\n/*Это вспомогательный TC для осуществления анфолловинга/фолловинга пользователей \"_followUnfollowFlow()\". Он вызывается\r\nвнутри TC \"unfollow()\" или \"follow()\". Для своей работы он принимает следующие параметры:\r\nметод \"dispatch\" (обязателен для \"thunk\", \"store\" из \"redux\" его сам закинет),\r\n\"ID\" пользователя для анфолловинга/фолловинга,\r\nзапрос на сервер для анфолловинга/фолловинга,\r\nAC для анфолловинга/фолловинга.\r\nЭти параметры он получает от TC \"unfollow()\" или \"follow()\".*/\r\nconst _followUnfollowFlow = async (\r\n    /*Dispatch-функция (обязательна для thunk, store из Redux его сам закинет), которая должна быть типа\r\n    \"DispatchType\".*/\r\n    dispatch: DispatchType,\r\n    /*ID пользователя для анфолловинга/фолловинга, которое должно быть числом.*/\r\n    id: number,\r\n    /*На входе принимает метод API являющийся функцией, на входе принимающей числовой параметр, а на выходе выдающей\r\n    промис, который резольвится данными типа \"ResponseWithDataType\". Такая типизация сделана на основе запросов\r\n    \"follow()\" и \"unfollow()\" в файле \"users-api.ts\".*/\r\n    apiMethod: (id: number) => Promise<ResponseWithDataType>,\r\n    /*AC, который должен быть функцией, на входе принимающей числовой параметр, а на выходе ранее возвращающей\r\n    action-объекты либо с типом \"FollowSuccessActionType\", либо с типом \"UnfollowSuccessActionType\", оба эти типа\r\n    были созданы нами, но затем были удалены, поэтому сейчас эти action-объекты временно должны быть общего типа для\r\n    всех action-объектов - \"ActionsType\".*/\r\n    actionCreator: (id: number) => ActionsType\r\n) => {\r\n    /*Указываем, что находимся в процессе попытки зафолловить/заанфолловить какого-то пользователя.*/\r\n    dispatch(usersAC.toggleIsFollowingInProgress(true, id));\r\n    /*Делаем запрос на сервер на анфолловинг/фолловинг и ждем ответа от сервера.*/\r\n    const response = await apiMethod(id);\r\n    /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\", то есть операция прошла успешно, то диспатчим AC на\r\n    анфолловинг/фолловинг, передав в этот AC ID пользователя, которого анфолловим/фолловим.*/\r\n    if (response.resultCode === ResultCodeEnum.Success) dispatch(actionCreator(id));\r\n    /*Указываем, что больше не находимся в процессе попытки зафолловить/заанфолловить какого-то пользователя.*/\r\n    dispatch(usersAC.toggleIsFollowingInProgress(false, id));\r\n};\r\n\r\n/*Далее идут два основных TC для осуществления анфолловинга/фолловинга пользователей \"unfollow()\" и \"follow()\". Все, что\r\nони делают так это вызывают вспомогательный TC для осуществления анфолловинга/фолловинга пользователей\r\n\"_followUnfollowFlow()\" и передают ему ряд параметров для его работы.*/\r\n\r\n/*Это TC для осуществления анфолловинга какого-либо пользователя. На входе принимает ID пользователя для анфолловинга,\r\nкоторое должно быть числом.*/\r\nexport const unfollow = (id: number): ThunkType => async (dispatch) => {\r\n    /*Так как мы берем метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли\r\n    этот метод какие-нибудь свойства с контекстом this и так далее, поэтому мы используем здесь функцию \"bind()\", чтобы\r\n    не потерять контекст this. Но вроде и без этого должно работать.*/\r\n    await _followUnfollowFlow(dispatch, id, usersAPI.unfollow.bind(usersAPI), usersAC.unfollowSuccess);\r\n};\r\n\r\n/*Это TC для осуществления фолловинга какого-либо пользователя. На входе принимает \"ID\" пользователя для фолловинга,\r\nкоторое должно быть числом.*/\r\nexport const follow = (id: number): ThunkType => async (dispatch) => {\r\n    /*Так как мы берем метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли\r\n    этот метод какие-нибудь свойства с контекстом this и так далее, поэтому мы используем здесь функцию \"bind()\", чтобы\r\n    не потерять контекст this. Но вроде и без этого должно работать.*/\r\n    await _followUnfollowFlow(dispatch, id, usersAPI.follow.bind(usersAPI), usersAC.followSuccess);\r\n};","/*Импортируем \"instance\" для более быстрого создания запросов. Также импортируем \"ResultCodeEnum\" - список кодов ответа\r\nот сервера, которые используются в TC \"getAuthUserData()\" и \"login()\", для осуществления типизации. Так же для типизации\r\nимпортируем \"ResultCodeForCaptchaEnum\" - список кодов ответа от сервера, которые используются в TC \"login()\". В добавок\r\nимпортируем общий тип \"ResponseWithDataType\" для некоторых ответов от сервера со схожей структурой ответа.*/\r\nimport {instance, ResultCodeEnum, ResultCodeForCaptchaEnum, ResponseWithDataType} from './api';\r\n\r\n/*Создаем отдельный тип для \"data\" для запроса \"me()\" из объекта с запросами \"authAPI\". Используется для уточнения в\r\nтипе \"ResponseType\". Этот объект \"data\" должен содержать информацию о залогиненном пользователе.*/\r\ntype MeResponseDataType = {\r\n    /*ID залогиненного пользователя, которое должно быть числом.*/\r\n    id: number\r\n    /*Email залогиненного пользователя, который должен быть строкой.*/\r\n    email: string\r\n    /*Логин залогиненного пользователя, который должен быть строкой.*/\r\n    login: string\r\n};\r\n\r\n/*Создаем отдельный тип для \"data\" для запроса \"login()\" из объекта с запросами \"authAPI\". Используется для уточнения в\r\nтипе \"ResponseType\".*/\r\ntype LoginResponseDataType = {\r\n    /*ID залогиненного пользователя, которое должно быть числом.*/\r\n    userId: number\r\n};\r\n\r\n/*Создаем отдельный тип для \"data\" для запроса \"logout()\" из объекта с запросами \"authAPI\". Используется для уточнения в\r\nтипе \"ResponseType\".*/\r\ntype LogoutResponseDataType = {\r\n    /*Таким образом мы указываем, что здесь могут быть любые свойства объекта.*/\r\n    [key: string]: any\r\n};\r\n\r\n/*Объект \"authAPI\" содержит запросы, связанные с аутентификацией.*/\r\nexport const authAPI = {\r\n    /*Эта функция является запросом на запрос информации для залогинивания через наше приложение. Перед этим необходимо\r\n    либо залогиниться на сайте API для создания cookie-файлов, чтобы при запросе сервер мог нас идентифицировать, либо\r\n    ввести данные для залогинивания в нашем приложении.*/\r\n    me() {\r\n        return (\r\n            /*Делаем GET-запрос для залогинивания в нашем приложении на адрес как указано в API сервера. Указываем, что\r\n            этот GET-запрос возвращает промис с типом \"ResponseWithDataType<MeResponseDataType>\".*/\r\n            instance.get<ResponseWithDataType<MeResponseDataType>>(`auth/me`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. еще один объект \"data\", который в свою очередь содержит \"id\" (ID залогиненного пользователя), \"email\"\r\n                (email залогиненного пользователя) и \"login\" (логин залогиненного пользователя).\r\n                2. \"resultCode\" - код ответа сервера (0 - все хорошо, 1 - какая-то ошибка).\r\n                3. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время залогинивания).\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"getAuthUserData()\".*/\r\n                .then(response => response.data)\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на залогинивание через наше приложение. Перед этим не нужно залогиниваться на сайте\r\n    API для создания cookie-файлов. Нужно просто ввести свои данные для залогинивания в нашем приложении. На сервер\r\n    отправится запрос вместе с объектом данных, которые включают в себя email (должна быть строкой), пароль (должен быть\r\n    строкой), флаг \"Запомнить?\" (должен быть булева типа) и введенная капча (должна быть строкой или null, то есть быть\r\n    пустой), если таковая была.*/\r\n    login(email: string, password: string, rememberMe = false, captcha: null | string = null) {\r\n        return (\r\n            /*Делаем POST-запрос для залогинивания в нашем приложении на адрес как указано в API сервера. В результате\r\n            сервер создаст cookie-фалы. Указываем, что этот POST-запрос возвращает промис с типом\r\n            \"ResponseWithDataType<LoginResponseDataType, ResultCodeEnum | ResultCodeForCaptchaEnum>\".*/\r\n            instance.post<ResponseWithDataType<LoginResponseDataType, ResultCodeEnum | ResultCodeForCaptchaEnum>>\r\n            (`auth/login`, {email, password, rememberMe, captcha})\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли мы залогинились или нет (0 - все хорошо, 10 - нужно ввести\r\n                капчу).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время залогинивания).\r\n                3. \"data\" - объект, содержащий свойство \"userId\" с ID залогиненного пользователя.\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить логинизацию\r\n                пользователя при помощи TC \"login()\".*/\r\n                .then(response => response.data)\r\n        );\r\n    },\r\n\r\n    /*Эта функция является запросом на разлогинивание через наше приложение. Перед этим нужно быть уже залогинен, чтобы\r\n    были созданы cookie-файлы.*/\r\n    logout() {\r\n        return (\r\n            /*Делаем DELETE-запрос для разлогинивания в нашем приложении на адрес как указано в API сайта. В результате\r\n            сервер удалит cookie-файлы. Указываем, что этот DELETE-запрос возвращает промис с типом\r\n            \"ResponseWithDataType<LogoutResponseDataType>\".*/\r\n            instance.delete<ResponseWithDataType<LogoutResponseDataType>>(`auth/login`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                1. \"resultCode\" - код, означающий успешно ли мы залогинились или нет (0 - все хорошо, другие числа -\r\n                какая-то ошибка).\r\n                2. \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                время разлогинивания).\r\n                3. \"data\" - пустой объект, потенциально может содержать какую-то дополнительную информацию.\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить разлогинивание\r\n                пользователя при помощи TC \"logout()\".*/\r\n                .then(response => response.data)\r\n        );\r\n    }\r\n};","import {instance} from './api';\r\n\r\n/*Создаем тип для промиса, который будет возвращаться из GET-запроса в запросе \"getCaptchaURL()\" из объекта с запросами\r\n\"securityAPI\".*/\r\ntype getCaptchaURLResponseType = {\r\n    /*Информация о пути к изображению с капчей должна быть строкой.*/\r\n    url: string\r\n};\r\n\r\n/*Объект \"securityAPI\" содержит запросы, связанные с безопасностью нашего приложения.*/\r\nexport const securityAPI = {\r\n    /*Если нашему серверу необходимо, чтобы мы ввели капчу после нескольких неудачных попыток залогиниться, то он\r\n    сообщит браузеру, что тот должен сделать запрос на специальный endpoint и в ответ получить картинку с капчей (в виде\r\n    объекта, содержащего URL). Эта функция является запросом на получение капчи.*/\r\n    getCaptchaURL() {\r\n        return (\r\n            /*Указываем что добавляется к базовому URL внутри \"instance\", чтобы отправить запрос на сервер для получения\r\n            капчи. Указываем, что этот GET-запрос возвращает промис с типом \"getCaptchaURLResponseType\".*/\r\n            instance.get<getCaptchaURLResponseType>(`security/get-captcha-url`)\r\n                /*Метод \"then()\" создает промис. Какие-то данные придут от сервера и выполниться стрелочная функция c\r\n                объектом \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри свойства\r\n                \"response.data\". Это свойство \"data\" создается самим запросом и туда помещается информация от сервера.\r\n\r\n                Сама же структура данных в свойстве \"data\" определяется сервером. Согласно API сервера там находится\r\n                строковое свойство \"url\", в котором указан URL капчи.\r\n\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш state при\r\n                помощи TC \"getCaptchaURL()\".*/\r\n                .then(response => response.data)\r\n        );\r\n    }\r\n};","/*Импортируем блоки запросов, связанных с аутентификацией.*/\r\nimport {authAPI} from '../api/auth-api';\r\n/*Импортируем блоки запросов, связанных с капчей.*/\r\nimport {securityAPI} from '../api/security-api';\r\n/*Импортируем списки кодов ответов от сервера.*/\r\nimport {ResultCodeEnum, ResultCodeForCaptchaEnum} from '../api/api';\r\n/*Импортируем специальный AC \"stopSubmit()\" из библиотеки Redux Form, который сообщает UI, что что-то пошло не так, и\r\nостанавливает submit данных в форме. Импортируем \"FormAction\", чтобы создать тип для action-объектов, которые передаются\r\nв thunks и TC.*/\r\nimport {FormAction, stopSubmit} from 'redux-form';\r\n/*Импортируем типы \"InferActionsTypes\" и \"BaseThunkType\".*/\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store';\r\n\r\ntype InitialAuthStateType = typeof initialState;\r\n\r\nlet initialState = {\r\n    /*Свойство, которое хранит ID залогиненного пользователя. Указываем, что изначально это свойство может иметь тип\r\n    null, то есть быть пустым, или быть числом.*/\r\n    id: null as number | null,\r\n    /*Свойство, которое хранит email залогиненного пользователя. Указываем, что изначально это свойство может иметь тип\r\n    null, то есть быть пустым, или быть строкой.*/\r\n    email: null as string | null,\r\n    /*Свойство, которое хранит логин залогиненного пользователя. Указываем, что изначально это свойство может иметь тип\r\n    null, то есть быть пустым, или быть строкой.*/\r\n    login: null as string | null,\r\n    /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    isAuth: false,\r\n    /*Свойство, которое хранит URL изображения с капчей. Указываем, что изначально это свойство может иметь тип null, то\r\n    есть быть пустым, или быть строкой.*/\r\n    captchaURL: null as string | null\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за аутентификацию и связанные с ней процессы.*/\r\nexport const authReducer = (state = initialState, action: ActionsType): InitialAuthStateType => {\r\n    switch (action.type) {\r\n        /*Устанавливаем данные по залогиненному пользователю в state. Здесь для обоих случаев один и тот же код потому,\r\n        что в обоих соответствующих AC используется свойство \"payload\". Благодаря деструктуризации мы сможем передать\r\n        нужные значения свойств из \"payload\" в нужные свойства state при совпадении имен свойств.*/\r\n        case 'demo-spa/auth-reducer/SET-USER-DATA':\r\n        case 'demo-spa/auth-reducer/SET-CAPTCHA-URL':\r\n            return {\r\n                /*Делаем поверхностную копию state.*/\r\n                ...state,\r\n                /*Action-объект будет иметь объект \"payload\", который содержит \"id\", \"email\", \"login\" и \"isAuth\".\r\n                Аналогично может прийти такой же объект \"payload\", но он может содержать только \"captchaURL\" - URL\r\n                изображения с капчей. Делаем глубокую копию, чтобы установить эти данные в state, деструктурируя этот\r\n                объект \"payload\".*/\r\n                ...action.payload,\r\n            };\r\n\r\n        default: {\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\ntype ActionsType = InferActionsTypes<typeof authAC>;\r\n\r\nexport const authAC = {\r\n    /*AC для установки данных залогиненного пользователя в state.*/\r\n    setAuthUserData: (\r\n        /*На входе получает ID пользователя, который должен быть числом или null, то есть быть пустым.*/\r\n        id: number | null,\r\n        /*На входе получает email пользователя, который должен быть строкой или null, то есть быть пустым.*/\r\n        email: string | null,\r\n        /*На входе получает логин пользователя, который должен быть строкой или null, то есть быть пустым.*/\r\n        login: string | null,\r\n        /*На входе получает информацию залогинен ли пользователь, которая должна быть булева типа.*/\r\n        isAuth: boolean\r\n    ) => ({\r\n        type: 'demo-spa/auth-reducer/SET-USER-DATA',\r\n        /*Объект с данными по залогиненному пользователю. Далее мы его деструктурируем в \"authReducer()\".*/\r\n        payload: {\r\n            /*Свойство, которое хранит ID залогиненного пользователя.*/\r\n            id,\r\n            /*Свойство, которое хранит email залогиненного пользователя.*/\r\n            email,\r\n            /*Свойство, которое хранит логин залогиненного пользователя.*/\r\n            login,\r\n            /*Свойство, которое указывает залогинен ли пользователь.*/\r\n            isAuth\r\n        }\r\n    } as const),\r\n\r\n    /*AC для установки URL изображения с капчей в state. На входе получает \"captchaURL\", которое должно быть строкой.*/\r\n    setCaptchaURL: (captchaURL: string) => ({\r\n        type: 'demo-spa/auth-reducer/SET-CAPTCHA-URL',\r\n        /*Объект с URL изображения с капчей. Далее мы его деструктурируем в \"authReducer()\".*/\r\n        payload: {\r\n            /*Свойство, которое хранит URL изображения с капчей.*/\r\n            captchaURL\r\n        }\r\n    } as const)\r\n};\r\n\r\n/*Создаем тип для thunks. Поскольку в TC \"login()\" мы диспатчим AC \"stopSubmit()\" из библиотеки Redux Form, поэтому\r\nздесь мы указываем еще и \"FormAction\" из библиотеки Redux Form, так как в файле декларации AC \"stopSubmit()\" указано,\r\nчто он \"extends\" от \"FormAction\". Но из-за этого теперь мы можем диспатчить любой action-объект, что естественно\r\nнежелательно для нас.*/\r\ntype ThunkType = BaseThunkType<ActionsType | FormAction>;\r\n\r\n/*Это TC для запроса и установки данных залогиненного пользователя в state. Здесь вместо использования then мы\r\nиспользуем ключевые слова async/await. Промис будет ожидаться вместе с ключевым словом await. Ключевое слово async\r\nделает TC асинхронным. Этот TC на выходе возвращает thunk, который имеет тип \"ThunkType\", созданный нами выше.*/\r\nexport const getAuthUserData = (): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для получения данных залогиненного пользователя. Здесь будет ожидаться промис. Когда он\r\n    зарезольвится, он сохранится в \"response\". Здесь return не нужен, так как асинхронная функция автоматически вернет\r\n    промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n    const response = await authAPI.me();\r\n\r\n    /*Если свойство \"resultCode\", которое пришло в ответе от сервера, содержит код \"0\", то есть ошибки при залогинивании\r\n    не было, то*/\r\n    if (response.resultCode === ResultCodeEnum.Success) {\r\n        /*деструктурируем объект \"data\", который пришел в ответе от сервера, и получаем \"ID\", \"email\" и \"login\"\r\n        залогиненного пользователя*/\r\n        let {id, email, login} = response.data;\r\n        /*и устанавливаем эти данные в state при помощи AC \"setAuthUserData()\", четвертый параметр это \"isAuth\", чтобы\r\n        сообщить, что пользователь залогинился.*/\r\n        dispatch(authAC.setAuthUserData(id, email, login, true));\r\n    }\r\n};\r\n\r\n/*Это TC для осуществления логинизации через наше приложение.*/\r\nexport const login = (\r\n    /*На входе получает email пользователя, который должен быть строкой.*/\r\n    email: string,\r\n    /*На входе получает пароль пользователя, который должен быть строкой.*/\r\n    password: string,\r\n    /*На входе получает информацию запомнить ли пользователя, которая должна быть булева типа.*/\r\n    rememberMe: boolean,\r\n    /*На входе получает путь к капче, который должен быть строкой.*/\r\n    captcha: string\r\n): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для залогинивания пользователя.*/\r\n    const response = await authAPI.login(email, password, rememberMe, captcha);\r\n\r\n    /*Если свойство \"resultCode\", которое пришло в ответе от сервера, содержит код \"0\", то есть ошибки при залогинивании\r\n    не было, то*/\r\n    if (response.resultCode === ResultCodeEnum.Success) {\r\n        /*вызываем TC \"getAuthUserData()\" для запроса и установки данных залогиненного пользователя в state.*/\r\n        dispatch(getAuthUserData())\r\n    } else {\r\n        /*Иначе если свойство \"resultCode\", которое пришло в ответе от сервера, содержит код \"10\", то есть нужно ввести\r\n        капчу, то вызываем TC \"getCaptchaURL()\" для получения URL изображения с капчей с сервера и установки его в\r\n        state.*/\r\n        if (response.resultCode === ResultCodeForCaptchaEnum.CaptchaIsRequired) dispatch(getCaptchaURL());\r\n        /*Также иначе если пришло какое-то информационное сообщение об ошибке при логинизации от сервера в массиве\r\n        \"messages\", то мы положим первый элемент этого массива в переменную \"message\", если длина этого массива больше\r\n        нуля, или же положим в переменную \"message\" текст \"unknown error\".*/\r\n        const message = response.messages.length > 0 ? response.messages[0] : 'unknown error';\r\n        /*Затем диспатчим специальный AC \"stopSubmit()\" из библиотеки Redux Form, который сообщит UI, что что-то пошло\r\n        не так, и остановит submit данных.\r\n\r\n        Первым параметром указывается какую форму необходимо остановить. Вторым параметром указывается объект, в котором\r\n        должно быть свойство \"_error\" (это свойство из библиотеки Redux Form, означающее ошибку для всей формы, но здесь\r\n        можно использовать и имена других полей, созданных нами), присваиваемый значение с текстом ошибки.\r\n\r\n        Но сейчас с AC \"stopSubmit()\" проблемы. При его использовании возникает проблема асинхронности, так как\r\n        библиотека Redux Form вызывает функцию \"setSubmitSucceed()\" сразу после AC \"stopSubmit()\", не успев вернуть\r\n        ошибку. Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно\r\n        использовать такой костыль: setTimeout(async () => await dispatch(stopSubmit('login', {_error: message})))\r\n\r\n        Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки Redux Form (8.3.6).*/\r\n        dispatch(stopSubmit('login', {_error: message}));\r\n    }\r\n};\r\n\r\n/*Это TC для получения URL изображения с капчей с сервера и установки его в state.*/\r\nconst getCaptchaURL = (): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для получения капчи.*/\r\n    const response = await securityAPI.getCaptchaURL();\r\n    /*Получив ответ от сервера, сохраняем из ответа сервера URL капчи.*/\r\n    const captchaURL = response.url;\r\n    /*Затем устанавливаем этот URL капчи в state при помощи AC \"setCaptchaURL()\".*/\r\n    dispatch(authAC.setCaptchaURL(captchaURL));\r\n};\r\n\r\n/*Это TC для осуществления логаута.*/\r\nexport const logout = (): ThunkType => async (dispatch) => {\r\n    /*Делаем запрос на сервер для разлогинивания пользователя.*/\r\n    const response = await authAPI.logout();\r\n    /*Если свойство \"resultCode\", которое пришло в ответе от сервера, содержит код \"0\", то есть ошибки при\r\n    разлогинивании не было, то обнуляем данные пользователя в state при помощи AC \"setAuthUserData()\", четвертый\r\n    параметр это \"isAuth\", чтобы сообщить, что пользователь разлогинился.*/\r\n    if (response.resultCode === 0) dispatch(authAC.setAuthUserData(null, null, null, false));\r\n};","/*Импортируем TC \"getAuthUserData()\" для запроса и установки данных залогиненного пользователя в state.*/\r\nimport {getAuthUserData} from './auth-reducer';\r\n/*Импортируем типы \"InferActionsTypes\" и \"BaseThunkType\".*/\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store';\r\n\r\n/*Создаем тип state из самого state при помощи typeof.*/\r\ntype InitialAppStateType = typeof initialState;\r\n\r\n/*Создаем сам state. Указываем, что \"initialState\" имеет тип \"InitialStateType\", созданный нами выше.*/\r\nlet initialState = {\r\n    /*Свойство, которое показывает инициализировано ли приложение.*/\r\n    initialized: false\r\n};\r\n\r\n/*Создаем редьюсер, отвечающий за страницу профиля.\r\n\r\nReducer - это чистая функция, которая принимает action-объект и копию части state. Потом редьюсер изменяет (или не\r\nизменяет, если action-объект не подошел) определенную часть state и возвращает ее. После этого все возвращенные части\r\nstate всех редьюсеров собираются в новый state.\r\n\r\nКаждый reducer состоит из:\r\n1. констант, содержащих значения для свойства \"type\" объекта \"action\";\r\n2. \"initialState\" - своей части state;\r\n3. самой функции-редьюсера;\r\n4. Action Creators или AC\r\n5. Thunk Creators или TC.\r\n\r\nНам нужен этот редьюсер, чтобы избежать моргания страницы (кроме страницы профиля) после F5, так как после каждого\r\nобновления страницы отправляется запрос на логинизацию, и пока осуществляется этот запрос мы будем считаться\r\nнезалогиненными, соответственно, будем видеть страницу логинизации, а когда запрос на логинизацию завершится мы увидим\r\nстраницу профиля вместо нужной нам страницы. И чтобы этого не допустить, мы не будем ничего показывать, пока не убедимся\r\nчто мы залогинены.\r\n\r\nУказываем, что тип state на выходе имеет тот же тип \"InitialAppStateType\", что и state на входе. На входе action-объекты\r\nимеют тип \"ActionsType\", созданный нами ниже.*/\r\nexport const appReducer = (state = initialState, action: ActionsType): InitialAppStateType => {\r\n    switch (action.type) {\r\n        /*Указываем, что приложение успешно инициализировано.*/\r\n        case 'demo-spa/app-reducer/INITIALIZATION-SUCCESSFUL': {\r\n            return {\r\n                /*Делаем поверхностную копию state. На данный момент этого не требуется, так как далее мы меняем\r\n                примитив.*/\r\n                ...state,\r\n                /*Меняем свойство, показывающее инициализировано ли приложение.*/\r\n                initialized: true\r\n            };\r\n        }\r\n\r\n        /*Если action-объект никуда не подошел, то по default возвращается тот же state, чтобы не вызвать перерисовку.*/\r\n        default: {\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\n/*Создаем типы для action-объектов. Здесь мы все раннее созданные типы для action-объектов объединяем в один тип. Мы его\r\nполучаем следующим образом: используем тип \"InferActionsTypes\" для определения типов всех action-объектов, возвращаемых\r\nАС-ми, упакованными в единый объект \"appAC\".*/\r\ntype ActionsType = InferActionsTypes<typeof appAC>;\r\n\r\n/*Action Creators. AC создает объект, который передается в редьюсер. Этот объект как минимум должен иметь свойство\r\n\"type\", которое определяет, что необходимо выполнить в редьюсере.\r\n\r\nСоздаем специальный объект, содержащий все наши AC. Все AC мы помещаем в единый объект с целью избавиться от большого\r\nколичества отдельных типов для каждого AC в обмен на один общий для них тип, который мы создаем выше. Также удаляем все\r\nтипы, созданные раннее на основе каждого AC. Также вверху удаляем все константы со значениями для \"type\" и указываем их\r\nсразу в AC, так как Typescript не даст нам допустить ошибку при указании этих \"types\" в редьюсере.\r\n\r\nСогласно модульному паттерну Redux Ducks, чтобы избежать случаев одинаковых значений свойств \"type\" из-за чего один и\r\nтот же action-объект может сработать в нескольких редьюсерах, в значениях свойств \"type\" в action-объекте указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\".\r\n\r\nТакже в конце везде добавляем \"as const\", чтобы редьюсер адекватно воспринимал action-объекты.*/\r\nexport const appAC = {\r\n    /*AC для инициализации приложения.*/\r\n    initializingApp: () => ({\r\n        /*Обязательно свойство \"type\" для AC.*/\r\n        type: 'demo-spa/app-reducer/INITIALIZATION-SUCCESSFUL'\r\n    } as const)\r\n};\r\n\r\n/*Создаем тип для thunks.*/\r\ntype ThunkType = BaseThunkType<ActionsType>;\r\n\r\n/*Thunk creators. Thunk - это функция, которая может выполнять AJAX-запросы и dispatch-функцию. Поскольку редьюсерам\r\nнужны action-объекты и редьюсеры работают синхронно (AJAX-запросы несинхронные, поэтому будут замедлять этот процесс), а\r\nтакже редьюсеры являются чистыми функциями, то мы не можем напрямую диспатчить thunks. В таком случае, thunk должен\r\nсначала сам запуститься, внутри него задиспатчатся action-объекты и в дальнейшем будут раскиданы по редьюсерам.\r\n\r\nВ параметрах thunk всегда приходит dispatch-функция. store из Redux запускает thunk и закидывает в него dispatch-функцию\r\nпотому, что она у него есть.\r\n\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в thunk нам нужно\r\nиспользовать замыкание из JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то дополнительные\r\nданные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет доступ к данным\r\n1-й функции. Этой 1-й родительской функцией является Thunk creator (по аналогии с Action creator). В TC передается текст\r\nсообщения, а сам thunk возьмет это сообщения из замыкания. В итоге мы диспатчим TC, а не сам thunk.\r\n\r\nТакже для этого нам нужен некий промежуточный слой thunk middleware между \"store.dispatch\" и редьюсерами. Если в store\r\nпридет action-объект, то thunk middleware передаст его в редьюсеры. Если же в store придет thunk, то thunk middleware\r\nзапустить этот thunk, закинет в него dispatch-функцию и на выходе будет action-объект, который затем будет передан в\r\nредьюсеры. Если в thunk будет несколько AC, то сначала отправится первый AC в thunk middleware, потом второй AC и так\r\nдалее до тех пор, пока не переберутся все AC. Это и есть замыкание. Для установки thunk middleware нам нужна библиотека\r\nRedux Thunk. Установка происходит в файле со \"redux-store.ts\".\r\n\r\nВ TC мы диспатчим не сам AC, а их вызовы.*/\r\n\r\n/*TC для инициализации приложения. Этот TC на выходе возвращает thunk, который имеет тип \"ThunkType\", созданный нами\r\nвыше. Мы могли здесь также указать тип dispatch-функции, функцию \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть thunk, мы также типизируем, что в thunk будет передаваться дальше, то есть те самые\r\ndispatch-функцию, функцию \"getState()\" и дополнительные аргументы.\r\n\r\nЭтот TC работает примерно так:\r\n1. сначала срабатывает TC \"getAuthUserData\".\r\n2. ожидаем выполнения 1-го шага.\r\n3. после завершения 1-го шага указываем, что приложение инициализировано.*/\r\nexport const initializeApp = (): ThunkType => (dispatch) => {\r\n    /*Здесь dispatch-функция возвращает то, что вернет \"getAuthUserData()\" (TC отвечающий за запрос и установку данных\r\n    залогиненного пользователя в state), и поместит это в массив \"promise\" (потому, что вернется массив). В этом массиве\r\n    будет разная информация, в том числе и разные промисы.*/\r\n    const promise = dispatch(getAuthUserData());\r\n\r\n    /*Здесь мы будем ждать выполнения всех промисов в массиве \"promise\" (причем не важно успешно они завершатся или\r\n    нет). После этого сработает блок then.*/\r\n    Promise.all([promise])\r\n        /*Вызываем TC \"initializingApp()\" для указания, что инициализация приложения завершена.*/\r\n        .then(() => { dispatch(appAC.initializingApp()) });\r\n};","/*Этот файл содержит наш store, созданный при помощи библиотеки Redux.\r\n\r\nReact Developer Tools - это плагин для браузеров, который позволяет отслеживать какой компонент сколько раз рендерится,\r\nувидеть дерево компонентов (props, hooks) и прочее.\r\n\r\nRedux DevTools - это плагин для браузеров, показывающий, что находится в state и все action-объекты, которые диспатчатся\r\nв state.*/\r\n\r\n/*Библиотека Redux помогает организовать FLUX-круговорот и state management. В Redux есть свои аналоги функций\r\n\"getState()\", \"subscribe()\", \"callSubscriber()\" и \"dispatch()\".\r\n\r\nstore в Redux при уведомлении подписчиков не передает им state.\r\n\r\nМетод \"createStore()\" позволяет создать store. Для работы этого store нужно создавать отдельные редьюсеры. Метод\r\n\"combineReducers()\" позволяет объединить все редьюсеры.\r\n\r\nМетод \"applyMiddleware()\" добавляет возможность указывать и подключать в store промежуточный слой между методом\r\n\"store.dispatch()\" и редьюсерами. Нам нужен будет слой \"thunk middleware\" для работы с thunks.\r\n\r\nФункция \"compose()\" из функционального программирования. Эта функция создает композицию обработчиков. Библиотека Redux\r\nсодержит свою реализацию функции \"compose()\". При помощи функции \"compose()\" можно объединять, например, несколько\r\nоберток вокруг компонента и HOCs. Обертки и HOCs указываются снизу вверх. Функция \"compose()\" вызывается дважды и\r\nработает схожим образом, как и функция \"connect()\" из библиотеки React Redux.\r\n\r\nИмпортируем \"Dispatch\" из библиотеки Redux, чтобы создать тип для dispatch-функции, которая передается в thunks и TC.\r\nИмпортируем \"Action\" из библиотеки Redux, чтобы создать тип для action-объектов, которые передается в thunks и TC.*/\r\nimport {Action, applyMiddleware, combineReducers, compose, createStore, Dispatch} from 'redux';\r\n/*Для установки \"thunk middleware\" нам нужна библиотека Redux Thunk. \"thunk middleware\" это промежуточный слой между\r\nметодом \"store.dispatch()\" и редьюсерами для работы с thunks. Для добавления в наш проект этого слоя мы импортируем\r\n\"thunkMiddleWare\". Также импортируем \"ThunkAction\" из библиотеки Redux Thunk, чтобы создать тип для thunks.*/\r\nimport thunkMiddleWare, {ThunkAction} from 'redux-thunk';\r\n/*Библиотека Redux Form нужна для работы с формами. Эта библиотека добавляет в store, то есть в глобальный state свой\r\nредьюсер и обрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше\r\nделать работы по организации данных форм в state.\r\n\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обернет другой компонент, является\r\nобщаться со своей частью в редьюсере.\r\n\r\nЭта библиотека, добавляя свою часть в глобальный state, обязуется заниматься круговоротом данных (FLUX) со всеми формами\r\nв приложении. То есть нам самим не нужно будет что-то диспатчить. Часть state, которую создает эта библиотека, не\r\nявляется по сути данными, относящимися к BLL, но при этом находятся в глобальном state.\r\n\r\nИмпортируем редьюсер \"reducer()\" из библиотеки Redux Form, чтобы встроить работу этой библиотеки в наш store.*/\r\nimport {reducer as formReducer} from 'redux-form';\r\n/*Импортируем редьюсер \"profileReducer\", отвечающий за страницу профиля.*/\r\nimport {profileReducer} from './profile-reducer';\r\n/*Импортируем редьюсер \"dialogsReducer\", отвечающий за страницу диалогов.*/\r\nimport {dialogsReducer} from './dialogs-reducer';\r\n/*Импортируем редьюсер \"sidebarReducer\", отвечающий за сайдбар.*/\r\nimport {sidebarReducer} from './sidebar-reducer';\r\n/*Импортируем редьюсер \"usersReducer\", отвечающий за страницу пользователей.*/\r\nimport {usersReducer} from './users-reducer';\r\n/*Импортируем редьюсер \"authReducer\", отвечающий за аутентификацию пользователей.*/\r\nimport {authReducer} from './auth-reducer';\r\n/*Импортируем редьюсер \"appReducer\", отвечающий за инициализацию приложения.*/\r\nimport {appReducer} from './app-reducer';\r\n/*Импортируем редьюсер \"chatReducer\", отвечающий за чат в нашем приложении.*/\r\nimport {chatReducer} from './chat-reducer';\r\n\r\n/*Делаем на основе нашего корневого редьюсера \"rootReducer\" тип при помощи typeof. В итоге там получится что-то вроде\r\nфункции \"(globalState: AppStateType) => AppStateType\", то есть получает на входе state типа \"AppStateType\" (имя выдумано\r\nнами) и на выходе возвращает state того же типа. То есть мы получили тип для нашего корневого редьюсера \"rootReducer\".*/\r\ntype RootReducerType = typeof rootReducer;\r\n/*Сохраняем тип нашего state в тип \"AppStateType\", чтобы можно было указывать тип state в компонентах, при помощи\r\nReturnType (скорее всего, получает тип того, что возвращается, а редьюсер возвращает state) из типа нашего корневого\r\nредьюсера \"rootReducer\".*/\r\nexport type AppStateType = ReturnType<RootReducerType>;\r\n/*В данном случае наш тип \"PropertiesTypes\" является generic, который принимает подтип \"T\", что подразумевает, что будет\r\nуточняться тип объекта в этом \"T\" при помощи typeof (если конкретно, то typeof многих упакованных AC в единый объект).\r\n\r\nЕсли подтип \"T\" будет совпадать с объектом, у которого есть какой-то ключ \"[key: string]\" (\"string\" - так как имя ключа\r\nэто текст) с неким значением \"U\", то при помощи infer будет проанализировано это значение \"U\" и возвращено это значение\r\n\"U\", иначе будет возвращено never, что примерно означает ничего не сделать. И через такой алгоритм пройдет каждое\r\nсвойство объекта.\r\n\r\nЭто вспомогательный тип, который будет использоваться в типе \"InferActionsTypesOld\" ниже. Также этот тип можно\r\nиспользовать для определения типов AC, упакованных в единый объект.*/\r\ntype PropertiesTypes<T> = T extends { [key: string]: infer U } ? U : never;\r\n/*Здесь мы создаем специальный тип, позволяющий нам определять тип action-объектов, возвращаемых AC, которые в свою\r\nочередь должны быть упакованы в единый объект.\r\n\r\nСоздаем псевдоним для \"ReturnType<PropertiesType<T>>\", где \"T\" это \"typeof packedActions\" (\"packedActions\" - одно из\r\nвозможных имен объекта, содержащего все AC), под названием \"InferActionsTypesOld\". Здесь также уточняется, что в типе\r\n\"InferActionsTypesOld\" нужно указывать ограничение (constraint) для передаваемого \"T\", указав, что это обязательно\r\nдолжен быть объект, у которого в качестве значений свойств обязательно должны быть функции, принимающие что-нибудь и\r\nвозвращающие что-нибудь, коими являются AC.\r\n\r\nМы ранее экспортировали этот тип, чтобы компактно определять типы action-объектов в редьюсерах.*/\r\ntype InferActionsTypesOld<T extends { [key: string]: (...args: any[]) => any }> = ReturnType<PropertiesTypes<T>>;\r\n/*Это более краткий аналог сразу двух типов \"PropertiesTypes\" и \"InferActionsTypesOld\", которые мы создаем выше.*/\r\nexport type InferActionsTypes<T> = T extends { [key: string]: (...args: any[]) => infer U } ? U : never;\r\n\r\n/*Создаем типы для Thunk Creators и thunks.\r\n\r\nСоздаем тип для функции \"getState()\", которая получает thunks и TC. Функция \"getState()\" должна быть функцией, которая\r\nничего не получает на входе и возвращает объект с типом \"AppStateType\". Мы это пока не используем в проекте, так как\r\nтипизация thunks при помощи типа \"BaseThunkType\", который создаем ниже, перекрывает эту типизацию, поскольку типизируя\r\nто, что возвращает TC, то есть thunk, мы также типизируем то, что в thunk будет передаваться дальше, то есть те самые\r\nфункции \"dispatch()\", \"getState()\" и дополнительные аргументы.*/\r\nexport type BaseGetStateType = () => AppStateType;\r\n/*Создаем тип для dispatch-функции, которая передается в thunks и TC. Dispatch-функция должна быть типа \"Dispatch\" из\r\nбиблиотеки Redux, работающей с action-объектами типа \"ActionsType\". Тип \"ActionsType\" должен указываться первым\r\nпараметром и совпадать с типом \"Action\" из библиотеки Redux.*/\r\nexport type BaseDispatchType<ActionsType extends Action> = Dispatch<ActionsType>;\r\n/*Создаем тип для thunks. Thunks должны быть action-объектами для thunks с типом \"ThunkAction\" из библиотеки Redux\r\nThunk, работающими с:\r\n1. Промисами, которые ничего не возвращают. Используются промисы потому, что у нас асинхронные thunks из-за\r\nиспользования ключевых слов async/await, хотя обычно thunks ничего не возвращают. Указываем их вторым параметром \"R\" и\r\nпоскольку thunks обычно ничего не возвращают, то делаем значение void значением по умолчанию этого параметра \"R\", хотя в\r\nуроке было указано \"Promise<void>\" вместо void, но такой вариант не работал в типизации файла \"app-reducer.ts\",\r\nпоскольку там мы используем метод \"Promise.all()\".\r\n2. state с типом \"AppStateType\".\r\n3. Какими-то неизвестными дополнительными аргументами.\r\n4. Action-объектами типа \"ActionsType\", который указывается первым параметром \"ActionsType\" и должен совпадать с типом\r\n\"Action\" из библиотеки Redux.\r\n\r\nЭти уточнения мы нашли в файле декларации \"ThunkAction\".\r\n\r\nВ уроке (1:19) также было указано, что по умолчанию первый параметр \"ActionsType\" может быть типа \"Action\" из библиотеки\r\nRedux (\"= Action\"), но я пока этого не стал указывать.*/\r\nexport type BaseThunkType<ActionsType extends Action, R = void> = ThunkAction<R, AppStateType, unknown, ActionsType>;\r\n\r\n/*Это список наших редьюсеров в нашем store. При помощи функции \"combineReducers()\" объединяем все наши редьюсеры в\r\nкорневой редьюсер \"rootReducer()\". Иногда можно дробить редьюсеры на под-редьюсеры, которые вызываются внутри\r\nредьюсеров.\r\n\r\nНаш корневой редьюсер \"rootReducer()\" сначала берет весь начальный state, раздает его по кускам в редьюсеры, они в свою\r\nочередь возвращают обратно измененные куски state, которые корневой редьюсер \"rootReducer()\" собирает в новый state и\r\nвозвращает его.*/\r\nconst rootReducer = combineReducers({\r\n    profilePage: profileReducer,\r\n    dialogsPage: dialogsReducer,\r\n    sidebar: sidebarReducer,\r\n    usersPage: usersReducer,\r\n    auth: authReducer,\r\n    /*Здесь важно, чтобы часть state, которая создается библиотекой Redux Form, называлась именно \"form\", иначе придется\r\n    многое переписывать дополнительно.*/\r\n    form: formReducer,\r\n    app: appReducer,\r\n    chat: chatReducer\r\n});\r\n\r\n/*Здесь идет создание store и установка плагина Redux DevTools. Также далее идет комментарий, который говорит\r\nTypescript, чтобы он игнорировал следующий за этим комментарием код.*/\r\n// @ts-ignore\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\n/*\"window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\" - это какой-то глобальный объект из плагина Redux DevTools. Эта строчка\r\nявляется необходимой для того, чтобы плагин Redux DevTools работал. Функцией \"composeEnhancers()\" мы оборачиваем\r\nсоздание промежуточного слоя \"thunkMiddleWare\" в store, что также необходимо, чтобы плагин Redux DevTools работал.\r\n\r\nПри помощи функции \"createStore()\" создаем store, передавая ему наш корневой редьюсер \"rootReducer()\". При помощи\r\nфункции \"applyMiddleware()\" указываем, что подключаем в store промежуточный слой \"thunkMiddleWare\".*/\r\nconst store = createStore(rootReducer, composeEnhancers(applyMiddleware(thunkMiddleWare)));\r\n\r\n/*Далее идет комментарий, который говорит TypeScrip, чтобы он игнорировал следующий за этим комментарием код. Если же\r\nвсе-таки нужно будет типизировать объект \"window\", то вроде можно написать следующее:*/\r\n// declare global {\r\n//     interface Window {\r\n//         __REDUX_DEVTOOLS_EXTENSION_COMPOSE__: any,\r\n//         store: any\r\n//     }\r\n// }\r\n\r\n/*На случай если нам нужно будет глобально обратиться к store.*/\r\n// @ts-ignore\r\nwindow.__store__ = store;\r\n\r\nexport default store;","/*Селектор - это функция, которая принимает state, достает из него то, что ей нужно и возвращает это в BLL. Селекторы\r\nосуществляют определенную выборку данных из state. Здесь содержатся селекторы для данных из файла \"auth-reducer.ts\".*/\r\n\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from './redux-store';\r\n\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает информацию о том являемся ли мы залогиненными в\r\nприложение или нет. На входе этот селектор принимает state с типом \"AppStateType\", который мы создали и импортировали\r\nсюда.*/\r\nexport const getIsAuth = (state: AppStateType) => state.auth.isAuth;\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает URL капчи при логинизации.*/\r\nexport const getCaptchaURL = (state: AppStateType) => state.auth.captchaURL;\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает логин залогиненного пользователя.*/\r\nexport const getLogin = (state: AppStateType) => state.auth.login;","export default __webpack_public_path__ + \"static/media/headerlogo.790903fe.png\";","import React from 'react';\r\n/*Импортируем компонент \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно\r\nбудет отображаться элемент \"a\". Но компонент \"NavLink\" не перезагружает все приложение в отличие от обычного\r\nиспользования элемента \"a\", то есть компонент \"NavLink\" отменяет действие, которое есть у элемента \"a\" по умолчанию.\r\n\r\nКомпонент \"NavLink\" используется для перемещения по маршрутам компонентов \"Route\". Компонент \"NavLink\" вместо атрибута\r\n\"href\" использует атрибут \"to\".\r\n\r\n\"NavLink\" добавляет атрибут \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке. Но\r\nкласс \"active\" нам не подходит, поскольку React добавляет уникальные префиксы и суффиксы к значениям классов из-за\r\nиспользования CSS-модуля. Атрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\"\r\nвместо класса \"active\".\r\n\r\nНо в итоге здесь мы используем компонент \"Link\", который является аналогом компонент \"NavLink\".*/\r\nimport {Link} from 'react-router-dom';\r\n/*Из библиотеки React Redux импортируем хуки:\r\n1. \"useSelector()\" - это хук, который принимает селектор и возвращает данные, возвращающие этим селектором.\r\n2. \"useDispatch()\" - это хук, который принимает AC или TC и диспатчит их.*/\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*Импортируем TC \"logout()\".*/\r\nimport {logout} from '../../redux/auth-reducer';\r\n/*Импортируем селектор \"getLogin()\" и \"getIsAuth()\".*/\r\nimport {getLogin, getIsAuth} from '../../redux/auth-selectors';\r\n/*Импортируем из UI-фреймворка Ant Design несколько элементов. Компонент \"Layout\" для получения из него компонента\r\n\"Header\", чтобы использовать его как тег для реализации хэдера нашего приложения. Компонент \"Menu\" для реализации\r\nэлементов меню. Компонент \"Avatar\" для реализации заглушки для аватара пользователя. Компонент \"Row\" для реализации\r\nстрок. Компонент \"Col\" для реализации столбцов, в одной строке может быть 24 единицы столбцов. Компонент \"Button\" для\r\nреализации кнопок. Компонент \"Image\" для реализации элементов, отображающих изображения (в итоге не используем).*/\r\nimport {Layout, Menu, Avatar, Row, Col, Button} from 'antd';\r\n/*Импортируем иконки из UI-фреймворка Ant Design.*/\r\nimport {UserOutlined} from '@ant-design/icons';\r\nimport styles from './Header.module.css';\r\n/*Импортируем из ассетов проекта логотип сайта.*/\r\nimport headerLogoSource from '../../assets/images/headerlogo.png';\r\n\r\ntype PropsType = {};\r\n\r\n/*\"Header\" это функциональный компонент, который создан в виде стрелочной функции. \"Header\" является компонентом,\r\nкоторый отрисовывает хэдер нашего сайта, содержащий логотип сайта и отдельный блок, отображающий ссылку на форму логина\r\nили имя залогиненного пользователя с кнопкой логаута.\r\n\r\nКомпонент \"Header\" импортируется в файле \"App.tsx\".*/\r\nexport const Header: React.FC<PropsType> = (props) => {\r\n    /*При помощи деструктуризации берем компонент \"Header\" из компонента \"Layout\" из UI-фреймворка Ant Design, чтобы\r\n    использовать его как тег для реализации хэдера нашего приложения.*/\r\n    const {Header} = Layout;\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getIsAuth()\", получаем информацию являемся ли мы\r\n    залогиненными в приложение или нет.*/\r\n    const isAuth = useSelector(getIsAuth);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getLogin()\", получаем логин залогиненного\r\n    пользователя.*/\r\n    const login = useSelector(getLogin);\r\n    /*Сохраняем вызов хука \"useDispatch()\" для более краткого использования хука \"useDispatch()\".*/\r\n    const dispatch = useDispatch();\r\n    /*Таким образом используем TC \"logout()\" для использования его ниже.*/\r\n    const logoutCallback = () => { dispatch(logout()) };\r\n\r\n    return (\r\n        /*Внутри этот компонент \"Header\" содержит один компонент \"Row\", что означает, что внутри содержится только одна\r\n        строка элементов.*/\r\n        <Header className={styles.header}>\r\n            {/*Внутри этого компонента \"Row\" используется несколько компонентов \"Col\", обозначающих колонки в строке.*/}\r\n            <Row>\r\n                {/*Первый компонент \"Col\" занимает 2 единицы из 24-х. Внутри находится компонент \"Image\" c изображением\r\n                логотипа сайта \"headerLogoSource\". Этот компонент \"Image\" содержит атрибут \"preview\" со значением\r\n                \"false\", чтобы была отключена опция увеличения изображения для просмотра, которая предоставляется\r\n                UI-фреймворком Ant Design. Но в итоге вместо компонента \"Image\" используем элемент \"img\".*/}\r\n                <Col span={2}>\r\n                    <img src={headerLogoSource} alt=''/>\r\n                </Col>\r\n\r\n                {/*Второй компонент \"Col\" занимает 17 единиц из 24-х. Внутри находится компонент \"Menu\", представляющий\r\n                собой меню с одним компонентом, который в свою очередь содержит компонент \"Link\", представляющий собой\r\n                ссылку для перехода на страницу пользователей. Компонент \"Menu\" благодаря атрибуту \"theme\" со значением\r\n                \"dark\" имеет темную тему, а благодаря атрибуту \"mode\" со значением \"horizontal\" имеет горизонтальный тип\r\n                расположения.*/}\r\n                <Col span={17}>\r\n                    <Menu theme='dark' mode='horizontal'>\r\n                        <Menu.Item key='/users/'>\r\n                            <Link to='/users/'>Users</Link>\r\n                        </Menu.Item>\r\n                    </Menu>\r\n                </Col>\r\n\r\n                {/*Если свойство \"isAuth\", которое указывает залогинен ли пользователь, является true, то отрисуется\r\n                пустой элемент \"<>\", содержащий три компонента \"Col\". Первый компонент \"Col\" содержит компонент\r\n                \"Avatar\", представляющий собой заглушку для аватара пользователя, и занимает 1 единицу. Этот компонент\r\n                \"Avatar\" имеет атрибут \"style\" для стилизации цвета заднего фона этого элемента, и атрибут \"icon\" со\r\n                значением \"UserOutlined\", чтобы подгрузить иконку из списка иконок, которые предоставляются\r\n                UI-фреймворком Ant Design. Второй компонент \"Col\" содержит элемент \"a\", содержащий внутри себя логин\r\n                залогиненного пользователя, и занимает 2 единицы. Третий компонент \"Col\" содержит компонент \"Button\",\r\n                который является кнопкой логаута (при нажатии сработает TC \"logout()\"), и занимает 2 единицы.*/}\r\n                {isAuth\r\n                    ?\r\n                    <>\r\n                        <Col span={1}>\r\n                            <Avatar icon={<UserOutlined/>}/>\r\n                        </Col>\r\n\r\n                        <Col span={2}>\r\n                            <a href='/profile/'>{login}</a>\r\n                        </Col>\r\n\r\n                        <Col span={2}>\r\n                            <Button onClick={logoutCallback}>Log out</Button>\r\n                        </Col>\r\n                    </>\r\n                    /*Иначе отрисуется один компонент \"Col\", занимающий 2 единицы и содержащий компонент \"Button\",\r\n                    который в свою очередь содержит компонент \"Link\" для перехода на страницу логинизации. Этот\r\n                    компонент \"Col\" имеет атрибут \"offset\", благодаря которому этот компонент сдвигается вправо на 3\r\n                    единицы.*/\r\n                    :\r\n                    <Col span={2} offset={3}>\r\n                        <Button>\r\n                            <Link to={'/login/'}>Log in</Link>\r\n                        </Button>\r\n                    </Col>}\r\n            </Row>\r\n        </Header>\r\n    );\r\n};","/*Здесь содержатся селекторы для данных из файла \"sidebar-reducer.ts\".*/\r\n\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from './redux-store';\r\n\r\n/*Это созданный нами без библиотеки \"reselect\" селектор. Он возвращает весь state из файла \"sidebar-reducer.ts\".*/\r\nexport const getSidebar = (state: AppStateType) => { return state.sidebar};","import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\nimport styles from './Sidebar.module.css';\r\n/*Импортируем тип \"AvatarSourceType\".*/\r\nimport {AvatarSourceType} from '../../../types/types';\r\n\r\ntype PropsType = {\r\n    /*ID друга в онлайне должно быть числом.*/\r\n    id: number\r\n    /*Имя друга в онлайне должно быть строкой.*/\r\n    name: string\r\n    /*Аватар друга в онлайне должен быть типа \"AvatarSourceType\".*/\r\n    avatar: AvatarSourceType\r\n};\r\n\r\n/*\"Sidebar\" это функциональный компонент, который создан в виде стрелочной функции. \"SideBar\" является компонентом,\r\nописывающим типовое отображение друзей в онлайне в навигационном меню сайта.\r\n\r\nКомпонент \"Sidebar\" импортируется в файле \"Navbar.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем, чтобы не писать далее \"props.id\",\r\n\"props.name\" и так далее:\r\n1. \"id\" - ID друга в онлайне.\r\n2. \"name\" - имя друга в онлайне.\r\n3. \"avatar\" - аватар друга в онлайне.\r\nТакое мы делаем только в функциональных компонентах.*/\r\nexport const SideBar: React.FC<PropsType> = ({id, name, avatar}) => {\r\n    /*Путь для компонента \"NavLink\" формируется на основе ID пользователя, который берется из параметров props.*/\r\n    const path = '/dialogs/' + id;\r\n\r\n    return (\r\n        /*Этот элемент \"nav\" представляет собой типовой пункт меню навигации по друзьям в онлайне, который будет\r\n        отрисовываться в компоненте \"NavBar\" при помощи метода \"map()\".*/\r\n        <nav className={styles.sidebar}>\r\n            <div>\r\n                {/*Типовой пункт меню навигации по друзьям в онлайне содержит компонент \"NavLink\".*/}\r\n                <NavLink to={path} activeClassName={styles.active}>\r\n                    {/*Этот компонент \"NavLink\" содержит аватар пользователя, ссылка на который берется из параметров\r\n                    props.*/}\r\n                    <img src={avatar} alt=''/>\r\n\r\n                    {/*Также этот компонент \"NavLink\" содержит имя пользователя, которое берется из параметров props.*/}\r\n                    <div>{name}</div>\r\n                </NavLink>\r\n            </div>\r\n        </nav>\r\n    );\r\n};","import React from 'react';\r\nimport {Link} from 'react-router-dom';\r\nimport {useSelector} from 'react-redux';\r\n/*Импортируем селектор \"getSidebar()\".*/\r\nimport {getSidebar} from '../../redux/sidebar-selectors';\r\n/*Импортируем из UI-фреймворка Ant Design несколько компонентов. Компонент \"Layout\" для получения из него компонента\r\n\"Sider\", чтобы использовать его как тег для реализации навигационного меню.*/\r\nimport {Layout, Menu} from 'antd';\r\n/*Импортируем иконки из UI-фреймворка Ant Design.*/\r\nimport {\r\n    UserOutlined, ProfileOutlined, BuildOutlined, MessageOutlined, TeamOutlined, HeartOutlined, AlertOutlined,\r\n    ThunderboltOutlined, ToolOutlined, CommentOutlined, BookOutlined\r\n} from '@ant-design/icons';\r\nimport styles from './Navbar.module.css';\r\n/*Импортируем компонент \"Sidebar\".*/\r\nimport {SideBar} from './Sidebar/Sidebar';\r\n\r\n/*Создаем отдельный тип для объекта \"location\" из HOC \"withRouter()\" из библиотеки React Router DOM.*/\r\ntype PathnameType = {\r\n    location: {\r\n        pathname: string\r\n    }\r\n};\r\n\r\ntype PropsType = PathnameType;\r\n\r\n/*\"Navbar\" это функциональный компонент, который создан в виде стрелочной функции. \"Navbar\" является компонентом,\r\nкоторый отрисовывает меню навигации нашего сайта.\r\n\r\nВнутри компонента \"Navbar\" используются следующие компоненты:\r\n1. \"SideBar\" - компонент, описывающий типовое отображение друзей в онлайне в навигационном меню сайта. Импортирован.\r\n\r\nКомпонент \"Header\" импортируется в файле \"App.tsx\".*/\r\nexport const Navbar: React.FC<PropsType> = (props) => {\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getSidebar()\", получаем весь state из файла\r\n    \"sidebar-reducer.ts\".*/\r\n    const sidebar = useSelector(getSidebar);\r\n\r\n    /*В JSX в массив можно вкладывать компоненты. В React, если мы передаем какой-либо массив, то JSX отобразит каждый\r\n    элемент этого массива в виде строки.\r\n\r\n    Метод \"map()\" - это метод массивов из JS, который позволяет создать новый массив на основе преобразования исходного\r\n    массива. Метод \"map()\" принимает стрелочную функцию в виде параметра.\r\n\r\n    В нашем случае будет сначала браться первый объект из исходного массива объектов и на основе данных этого объекта\r\n    будет формироваться первый элемента нового массива, который будет из себя представлять JSX компонента, указанного в\r\n    стрелочной функции. Потом будет браться следующий объект из исходного массива объектов и на основе данных уже этого\r\n    объекта будет формироваться следующий элемент нового массива, который будет из себя представлять JSX компонента,\r\n    указанного в стрелочной функции.\r\n\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов. То есть\r\n    переданная в метод \"map()\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов. В итоге получится новый массив с элементами в виде компонентов, построенных на основе данных из BLL.\r\n\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты. При использовании метода \"map()\" нужно указывать атрибут\r\n    \"key\" для избежания ошибок.\r\n\r\n    Массив \"sidebarElements\" содержит список друзей в онлайне.*/\r\n    const sidebarElements = sidebar.friendsData.map(f => <SideBar name={f.name}\r\n                                                                  id={f.id}\r\n                                                                  avatar={f.avatar}\r\n                                                                  key={f.id}/>);\r\n\r\n    /*При помощи деструктуризации берем компонент \"SubMenu\" из компонента \"Menu\" из UI-фреймворка Ant Design, чтобы\r\n    использовать его, как тег для реализации подменю.*/\r\n    const {SubMenu} = Menu;\r\n    /*При помощи деструктуризации берем компонент \"Sider\" из компонента \"Layout\" из UI-фреймворка Ant Design, чтобы\r\n    использовать его как тег для реализации навигационного меню.*/\r\n    const {Sider} = Layout;\r\n    /*Создаем массив строк, который в дальнейшем будет хранить значение атрибута \"key\" компонентов \"SubMenu\" и\r\n    \"Menu.Item\" в меню ниже, чтобы мы могли знать какое подменю необходимо раскрывать исходя из пути, на котором мы\r\n    находимся.*/\r\n    const subMenuKey = [''];\r\n\r\n    /*Создаем специальную функцию \"getSubMenuKey()\", для получения атрибутов \"key\" компонентов \"SubMenu\" и \"Menu.Item\" и\r\n    записи их в массив \"subMenuKey\". На входе получает строковой параметр.*/\r\n    const getSubMenuKey = (key: string) => {\r\n        /*Каждый раз очищаем наш массив \"subMenuKey\", чтобы там не копились значения.*/\r\n        while (subMenuKey.length > 0) subMenuKey.pop();\r\n        /*Если наш массив \"subMenuKey\" пустой, то записываем в него соответствующий ключ пункта меню.*/\r\n        if (subMenuKey.length === 0) subMenuKey.push(key);\r\n    };\r\n\r\n    /*При помощи конструкции switch/case заполняем наш строковой массив \"subMenuKey\" в зависимости от пути, на котором\r\n    мы находимся. \"props.location.pathname\" содержит строковое значение пути благодаря HOC \"withRouter()\".*/\r\n    switch (props.location.pathname) {\r\n        case '/profile/':\r\n        case '/dialogs/':\r\n            getSubMenuKey('sub1');\r\n            break;\r\n\r\n        case '/friends/':\r\n        case '/users/':\r\n        case '/chat/':\r\n            getSubMenuKey('sub2');\r\n            break;\r\n\r\n        case '/news/':\r\n        case '/music/':\r\n        case '/settings/':\r\n        case '/usestatetheory/':\r\n        case '/useeffecttheory/':\r\n            getSubMenuKey('sub3');\r\n            break;\r\n    }\r\n\r\n    /*Создаем специальную функцию \"getSubMenuKeyCallback()\", которая будет вызываться при нажатии на пункты меню, брать\r\n    атрибут \"key\" из пункта меню и сохранять его в наш массив \"subMenuKey\". Нам это нужно, так как конструкция\r\n    switch/case выше после нажатия на один из пунктов меню не позволяла выбирать другие пункты меню, так как не\r\n    подхватывались атрибуты \"key\" других пунктов меню при нажатии на эти пункты. Для события \"event\" указываем тип\r\n    any, так как пока не знаем какого он именно типа.*/\r\n    const getSubMenuKeyCallback = (event: any) => { getSubMenuKey(event.key) };\r\n\r\n    return (\r\n        <>\r\n            {/*Отрисовываем компонент \"Sider\" для создания навигационного меню.*/}\r\n            <Sider>\r\n                {/*Отрисовываем компонент \"Menu\" для создания самого меню. Внутри используются компоненты \"Submenu\" для\r\n                создания подменю и компоненты \"Menu.Item\" для создания пунктов меню и подменю.*/}\r\n                <Menu\r\n                    className={styles.menu}\r\n                    mode='inline'\r\n                    /*Используем атрибут \"selectedKeys\" для выделения подпунктов меню при их выборе. Мы этого добились\r\n                    задав значения атрибутам \"key\" компонентов \"Menu.Item\" как пути, на которые эти подпункты меню\r\n                    переводят нас. Таким образом, при выборе любого подпункта меню мы получаем путь, на который перешли,\r\n                    по своему значению равный одному из значений атрибута \"key\" какого-то подпункта меню, что мы можем\r\n                    использовать для указания какой подпункт меню нам нужно подсветить.*/\r\n                    selectedKeys={[props.location.pathname]}\r\n                    /*Используем атрибут \"openKeys\" для разворачивания только тех подпунктов меню, пункты которых мы\r\n                    выбрали.*/\r\n                    openKeys={subMenuKey}\r\n                >\r\n                    <SubMenu key='sub1' icon={<UserOutlined/>} title='My Page' onTitleClick={getSubMenuKeyCallback}>\r\n                        <Menu.Item key='/profile/' icon={<ProfileOutlined/>}>\r\n                            <Link to='/profile/'>Profile</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/dialogs/' icon={<MessageOutlined/>}>\r\n                            <Link to='/dialogs/'>Dialogs</Link>\r\n                        </Menu.Item>\r\n                    </SubMenu>\r\n\r\n                    <SubMenu key='sub2' icon={<UserOutlined/>} title='People' onTitleClick={getSubMenuKeyCallback}>\r\n                        <Menu.Item key='/friends/' icon={<HeartOutlined/>}>\r\n                            <Link to='/friends/'>Friends</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/users/' icon={<TeamOutlined/>}>\r\n                            <Link to='/users/'>Users</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/chat/' icon={<CommentOutlined/>}>\r\n                            <Link to='/chat/'>Chat</Link>\r\n                        </Menu.Item>\r\n                    </SubMenu>\r\n\r\n                    <SubMenu key='sub3' icon={<BuildOutlined/>} title='Other' onTitleClick={getSubMenuKeyCallback}>\r\n                        <Menu.Item key='/news/' icon={<AlertOutlined/>}>\r\n                            <Link to='/news/'>News</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/music/' icon={<ThunderboltOutlined/>}>\r\n                            <Link to='/music/'>Music</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/settings/' icon={<ToolOutlined/>}>\r\n                            <Link to='/settings/'>Settings</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/usestatetheory/' icon={<BookOutlined/>}>\r\n                            <Link to='/usestatetheory/'>UseState Theory</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/useeffecttheory/' icon={<BookOutlined/>}>\r\n                            <Link to='/useeffecttheory/'>UseEffect Theory</Link>\r\n                        </Menu.Item>\r\n                    </SubMenu>\r\n\r\n                    {/*Отрисовываем элементы сайдбара, отображающие друзей в онлайне.*/}\r\n                    {sidebarElements}\r\n                </Menu>\r\n            </Sider>\r\n        </>\r\n    );\r\n};","/*Здесь содержатся селекторы для данных из файла \"users-reducer.ts\". Это селекторы для компонента \"UsersContainer\".*/\r\n\r\n/*Функция \"mapStateToProps()\" в функции \"connect()\" срабатывает каждый раз, когда что-то меняется в state. Если мы будем\r\nиспользовать сложные селекторы с дополнительной внутренней логикой, то такие селекторы будут вызывать большую нагрузку и\r\nзаставлять часто перерисовывать приложение. Также такие селекторы сложно дебажить. Чтобы избежать этих проблем мы\r\nиспользуем библиотеку Reselect. Эта библиотека помогает нам не перезапускать наши сложные селекторы, если в этом нет\r\nтакой необходимости.\r\n\r\nНаш селектор после запуска не только должен отправлять что-то в функцию \"mapStateToProps()\", но и сохранять это что-то в\r\nотдельном месте, чтобы в следующий вызов этого селектора он не сработал снова, а просто вернулось это сохраненное\r\nчто-то, если оно не было изменено, то есть мы должны указать от чего зависит наш селектор.\r\n\r\nИмпортируем функцию \"createSelector()\" из библиотеки Reselect, чтобы создавать наши селекторы. Функция\r\n\"createSelector()\" - это специальная функция, которая возвращает селектор, а внутри она получает функцию, описывающую\r\nлогику селектора. Для того чтобы передать state в функцию в \"createSelector()\" нам нужно создать примитивный селектор,\r\nполучающий state. Можно создавать сложные селекторы на основе нескольких примитивных селекторов или на основе нескольких\r\nпримитивных и сложных селекторов.*/\r\nimport {createSelector} from 'reselect';\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from './redux-store';\r\n\r\n/*Создаем примитивный селектор, получающий \"users\" из state. На входе этот селектор принимает state с типом\r\n\"AppStateType\".*/\r\nconst getUsersPrimitive = (state: AppStateType) => { return state.usersPage.users};\r\n/*Создаем сложный селектор на основе примитивного селектора \"getUsersPrimitive()\". Можно указать несколько таких\r\nселекторов через запятую. Этот примитивный селектор будет создавать \"users\" - данные по пользователям. Внутри второго\r\nпараметра просто передается весь \"users\" как есть. Если бы мы указали, например два селектора вместо одного, то\r\nи помимо \"users\" нужно было бы указать еще что-то. Этот сложный селектор возвращает данные по пользователям для\r\nпостраничного вывода.*/\r\nexport const getUsers = createSelector(getUsersPrimitive, (users) => { return users.filter(u => true)});\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает максимальное количество пользователей, которое\r\nвыводится в постраничном выводе пользователей.*/\r\nexport const getPageSize = (state: AppStateType) => { return state.usersPage.pageSize};\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает свойство, которое указывает какое количество\r\nномеров страниц в постраничном выводе может отображаться в одной порции таких страниц.*/\r\nexport const getPortionSize = (state: AppStateType) => { return state.usersPage.portionSize};\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает общее количество пользователей.*/\r\nexport const getTotalUsersCount = (state: AppStateType) => { return state.usersPage.totalUsersCount};\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает текущий номер выбранной страницы в постраничном\r\nвыводе пользователей.*/\r\nexport const getCurrentPage = (state: AppStateType) => { return state.usersPage.currentPage};\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает специальное свойство, обозначающее находится ли в\r\nпроцессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/\r\nexport const getIsFetching = (state: AppStateType) => { return state.usersPage.isFetching};\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает специальное свойство, содержащее массив, хранящий\r\nID пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним\r\nотправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\nexport const getWhoIsInFollowingProgress = (state: AppStateType) => { return state.usersPage.WhoIsInFollowingProgress};\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает свойство, которое содержит данные по фильтрам для\r\nотображения пользователей в постраничном выводе пользователей.*/\r\nexport const getUsersFilter = (state: AppStateType) => { return state.usersPage.filter};","import React, {useState} from 'react';\r\n/*Сlassnames - это библиотека для простого условного объединения имен классов. Для этого мы здесь используем функцию\r\n\"cn()\" из этой библиотеки.\r\nКак можно добавить два класса:\r\nclassName = {styles.first + ' ' + styles.second} (без библиотеки \"classnames\")\r\nclassName = {`${styles.first} ${styles.second}`} (без библиотеки \"classnames\")\r\nclassName = {cn(styles.second, styles.first)} (с библиотекой \"classnames\")\r\nТакже при использовании этой библиотеки можно добавлять условия:\r\nclassName = {cn(\r\n                styles.first,\r\n                {[styles.second] : true}\r\n                )\r\n            };*/\r\nimport cn from 'classnames';\r\nimport styles from './Paginator.module.css';\r\n\r\ntype PropsType = {\r\n    /*Общее количество элементов для постраничного вывода должно быть числом.*/\r\n    totalItemsCount: number\r\n    /*Максимальное количество элементов на одной странице в постраничном выводе должно быть числом.*/\r\n    pageSize: number\r\n    /*Текущая выбранная страница в постраничном выводе должна быть числом.*/\r\n    currentPage: number\r\n    /*Метод для обновления данных при смене текущей выбранной страницы в постраничном выводе должен быть функцией,\r\n    которая принимает числовой параметр и ничего не возвращает.*/\r\n    onPageChange: (p: number) => void\r\n    /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может отображаться\r\n    в одной порции таких страниц, должно быть числом. Не является обязательным.*/\r\n    portionSize?: number\r\n};\r\n\r\n/*\"Paginator\" это функциональный компонент, который создан в виде стрелочной функции. \"Paginator\" является компонентом,\r\nкоторый содержит логику для высчитывания и отображения текущей страницы в постраничном выводе пользователей. Этот\r\nкомпонент можно использовать и для постраничного вывода любых других элементов.\r\n\r\nКомпонент \"Paginator\" импортируется в файле \"Users.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"totalItemsCount\" - общее количество элементов для постраничного вывода.\r\n2. \"pageSize\" - максимальное количество элементов на одной странице в постраничном выводе.\r\n3. \"currentPage\" - текущая выбранная страница в постраничном выводе.\r\n4. \"onPageChange\" - метод для обновления данных при смене текущей выбранной страницы в постраничном выводе.\r\n5. \"portionSize\" - свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может\r\nотображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное\r\nколичество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между\r\nэтими порциями страниц. Если значение этого свойства не будет указано, то по умолчанию оно будет равно 10.*/\r\nexport const Paginator: React.FC<PropsType> = ({\r\n                                                   totalItemsCount,\r\n                                                   pageSize,\r\n                                                   currentPage,\r\n                                                   onPageChange,\r\n                                                   portionSize = 10\r\n                                               }) => {\r\n    /*Высчитываем сколько страниц пользователей нам нужно (делим общее количество элементов на максимальное количество\r\n    элементов на одной странице) и помещаем результат в переменную \"pagesCount\". Метод \"Math.ceil()\" округляет в большую\r\n    сторону.*/\r\n    const pagesCount = Math.ceil(totalItemsCount / pageSize);\r\n    /*Создаем массив, содержащий такое количество элементов (например, номера страниц: 1, 2, 3 и так далее), которое\r\n    будет равно количеству страниц в постраничном выводе пользователей \"pagesCount\". Далее мы будем мапить этот массив,\r\n    чтобы вывести список номеров страниц для навигации по постраничному выводу элементов. Этот массив имеет тип массива\r\n    чисел.*/\r\n    const pages: Array<number> = [];\r\n    /*Заполняем массив \"pages\" путем перебора \"pagesCount\". При помощи метода \"push()\" добавляем в конец массива \"pages\"\r\n    каждый \"i\".*/\r\n    for (let i = 1; i <= pagesCount; i++) pages.push(i);\r\n\r\n    /*\"portionCount\" - количество порций страниц, которое мы имеем.\r\n    \"portionSize\" - максимальное количество страниц в одной порции, берем из state.\r\n    \"lowerLimitOfCurrentPortion\" - номер страницы, который является нижней границей текущей порции страниц.\r\n    \"upperLimitOfCurrentPortion\" - номер страницы, который является верхней границей текущей порции страниц.\r\n    \"currentPortionNumber\" - номер текущей порции страниц, используется в хуке \"useState()\".\r\n    \"setCurrentPortionNumber\" - функция, меняющая номер текущей порции страниц, используется в хуке \"useState()\".*/\r\n\r\n    /*Вычисляем количество порций страниц, путем деления количества всех страниц с пользователями на максимальное\r\n    количество страниц в одной порции.*/\r\n    const portionCount = Math.ceil(pagesCount / portionSize);\r\n    /*При помощи деструктуризирующего присваивания создали две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать номер текущей порции страниц (изначально 1). Вторая\r\n    переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть менять номер\r\n    текущей порции страниц).*/\r\n    const [currentPortionNumber, setCurrentPortionNumber] = useState(1);\r\n    /*Высчитываем номер страницы, который является нижней границей текущей порции страниц. Изначально это будет\r\n    (1 - 1) + 1 = 1.*/\r\n    const lowerBoundOfCurrentPortion = (currentPortionNumber - 1) * portionSize + 1;\r\n    /*Высчитываем номер страницы, который является верхней границей текущей порции страниц. Изначально это будет\r\n    1 * 20 = 20.*/\r\n    const upperBoundOfCurrentPortion = currentPortionNumber * portionSize;\r\n\r\n    return (\r\n        <div className={styles.paginator}>\r\n            {/*Если текущий номер порции страниц больше 1, то отрисовываем элемент \"button\", при нажатии на который\r\n            будет уменьшаться текущий номер порции страниц на 1, то есть мы будем переходить назад на предыдущую порцию\r\n            страниц (например, с \"от 21 до 40\" до \"1 до 20\"). Соответственно, изначально это кнопка не отрисовывается,\r\n            так как мы по дефолту находимся на 1-й порции страниц.*/}\r\n            {currentPortionNumber > 1 &&\r\n                <button onClick={() => {\r\n                    setCurrentPortionNumber(currentPortionNumber - 1)\r\n                }}>\r\n                    {/*Текст кнопки \"предыдущая порция страниц\".*/}\r\n                    PREV\r\n                </button>}\r\n\r\n            {pages\r\n                /*Из массива \"pages\" берем только те номера страниц, которые больше или равны нижней границе текущей\r\n                порции страниц и меньше или равны верхней границе текущей порции страниц.*/\r\n                .filter(p => p >= lowerBoundOfCurrentPortion && p <= upperBoundOfCurrentPortion)\r\n                /*Далее мапим отфильтрованный массив \"pages\".*/\r\n                .map(p => {\r\n                    /*Здесь возвращаем JSX в виде \"span\" элементов. Количество этих \"span\" элементов будет равно\r\n                    количеству элементов в массиве \"pages\". Это будет список номеров страниц для навигации в\r\n                    постраничном выводе пользователей.*/\r\n                    return (\r\n                        <span\r\n                            /*Будет применяться особый стиль к странице \"p\", номер которой равен номеру текущей\r\n                            выбранной страницы в постраничном выводе из state, благодаря использованию функции \"cn()\".*/\r\n                            className={cn({[styles.selectedPage]: currentPage === p}, styles.pageNumber)}\r\n                            key={p}\r\n                            /*Это анонимная функция, которая будет вызываться при событии нажатия на элемент. Эта\r\n                            анонимная функция будет вызывать наш метод \"onPageChange()\" и передавать в него номер\r\n                            страницы, на которую мы нажали. В результате мы изменим текущую выбранную страницу в\r\n                            постраничном выводе в state.*/\r\n                            onClick={() => { onPageChange(p) }}>\r\n                            {/*Выводим текст самого номера страницы в элементе \"span\".*/}\r\n                            {p}\r\n                        </span>\r\n                    )\r\n                })\r\n            }\r\n\r\n            {/*Если количество порций страниц больше текущего номера порции страниц, то отрисовываем элемент \"button\",\r\n            при нажатии на который будет увеличиваться текущий номер порции страниц на 1, то есть мы будем переходить\r\n            вперед на следующую порцию страниц (например, с \"от 1 до 20\" до \"21 до 40\"). Соответственно, на последней\r\n            порции страниц это кнопка не отрисовывается, так как текущая порция страниц, которая является последней\r\n            порцией страниц, равна максимальному количеству порций страниц.*/}\r\n            {portionCount > currentPortionNumber &&\r\n                <button onClick={() => { setCurrentPortionNumber(currentPortionNumber + 1) }}>\r\n                    {/*Текст кнопки \"следующая порция страниц\".*/}\r\n                    NEXT\r\n                </button>}\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\nimport styles from './User.module.css';\r\n/*Импортируем из ассетов проекта аватар пользователя, на случай если у пользователя нет фото.*/\r\nimport userPhoto from '../../../assets/images/user.png';\r\n/*Импортируем тип \"UserType\".*/\r\nimport {UserType} from '../../../types/types';\r\n\r\ntype PropsType = {\r\n    /*Данные по одному пользователю для постраничного вывода должны быть в виде объекта с типом \"UserType\".*/\r\n    user: UserType\r\n    /*Специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то определенный момент\r\n    находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга\r\n    от пользователя, должно быть массивом чисел.*/\r\n    WhoIsInFollowingProgress: Array<number>\r\n    /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой параметр и ничего не\r\n    возвращает.*/\r\n    unfollow: (id: number) => void\r\n    /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой параметр и ничего не\r\n    возвращает.*/\r\n    follow: (id: number) => void\r\n};\r\n\r\n/*\"User\" это функциональный компонент, который создан в виде стрелочной функции. \"User\" является компонентом, который\r\nописывает, как должны выглядеть блоки с информацией о пользователе на странице с постраничным выводом пользователей.\r\n\r\nКомпонент \"User\" импортируется в файле \"Users.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"user\" - объект с данным по пользователю.\r\n2. \"WhoIsInFollowingProgress\" - специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то\r\nопределенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для\r\nанфолловинга/фолловинга от пользователя.\r\n3. \"unfollow\" - TC для анфолловинга пользователей.\r\n4. \"follow\" - TC для фолловинга пользователей.*/\r\nexport const User: React.FC<PropsType> = ({user, WhoIsInFollowingProgress, unfollow, follow}) => {\r\n    return (\r\n        <div>\r\n            <span>\r\n                {/*Это отдельный элемент \"div\" для отображения фото пользователя в виде компонента \"NavLink\" для\r\n                перехода на профиль пользователя.*/}\r\n                <div>\r\n                    {/*Создаем маршрут для пути перехода на страницу выбранного пользователя. Отрисуется компонент\r\n                    \"Profile\".*/}\r\n                    <NavLink to={'/profile/' + user.id}>\r\n                        {/*Отображаем фото пользователя, если его нет, то подгружаем дефолтный аватар из проекта\r\n                        приложения.*/}\r\n                        <img src={user.photos.small !== null ? user.photos.small : userPhoto}\r\n                             alt='' className={styles.userPhoto}/>\r\n                    </NavLink>\r\n                </div>\r\n\r\n                {/*Это отдельный элемент \"div\" для кнопок с функционалом \"Follow/Unfollow\".*/}\r\n                <div>\r\n                    {/*Если значение \"followed\" (свойство, которое говорит фолловим ли мы уже пользователя или нет, это\r\n                    свойство меняется в \"usersReducer\") у пользователя*/}\r\n                    {user.followed\r\n                        /*является true, то отображаем элемент кнопки, причем кнопка будет отключена, если на нее\r\n                        нажали и происходит процесс анфолловинга пользователя, то есть мы берем массив\r\n                        \"WhoIsInFollowingProgress\" и вызываем для него метод \"some()\", который вернет true если в\r\n                        указанном массиве есть ID пользователя равное ID пользователя, указанного при создании\r\n                        отдельного экземпляра компонента \"User\" в результате маппинга,*/\r\n                        ? <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)}\r\n                            /*и если нажать на кнопку, то*/\r\n                                  onClick={() => {\r\n                                      /*сработает TC \"unfollow()\", чтобы заанфолловить пользователя,*/\r\n                                      unfollow(user.id);\r\n                                      /*и отобразится текст \"Unfollow\" на кнопке.*/\r\n                                  }}>Unfollow</button>\r\n                        /*Иначе если значение \"followed\" является false, то отображаем элемент кнопки, причем кнопка\r\n                        будет отключена, если на нее нажали и происходит процесс фолловинга пользователя, то есть мы\r\n                        берем массив \"WhoIsInFollowingProgress\" и вызываем для него метод \"some()\", который вернет true\r\n                        если в указанном массиве есть ID пользователя равное ID пользователя, указанного при создании\r\n                        отдельного экземпляра компонента \"User\" в результате маппинга,*/\r\n                        : <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)}\r\n                            /*и если нажать на кнопку, то*/\r\n                                  onClick={() => {\r\n                                      /*сработает TC \"follow()\", чтобы зафолловить пользователя.*/\r\n                                      follow(user.id);\r\n                                      /*и отобразится текст \"Follow\" на кнопке.*/\r\n                                  }}>Follow</button>\r\n                    }\r\n                </div>\r\n            </span>\r\n\r\n            {/*Это отдельный элемент \"span\" для отображения информации с ID, именем и статусом пользователя. А также\r\n            имеется заглушка для страны и города пользователя, так как на данный момент на сервере такой информации\r\n            нет.*/}\r\n            <span>\r\n                {/*Это отдельный элемент \"span\" для отображения информации с ID, именем и статусом пользователя.*/}\r\n                <span>\r\n                    {/*Этот элемент \"div\" отображает ID пользователя.*/}\r\n                    <div>{user.id}</div>\r\n                    {/*Этот элемент \"div\" отображает имя пользователя.*/}\r\n                    <div>{user.name}</div>\r\n                    {/*Этот элемент \"div\" отображает статус пользователя.*/}\r\n                    <div>{user.status}</div>\r\n                </span>\r\n\r\n                {/*Это отдельный элемент \"span\" для отображения заглушки для страны и города пользователя.*/}\r\n                <span>\r\n                    {/*Этот элемент \"div\" отображает заглушку для страны пользователя.*/}\r\n                    <div>{'user.location.country'}</div>\r\n                    {/*Этот элемент \"div\" отображает заглушку для города пользователя.*/}\r\n                    <div>{'user.location.city'}</div>\r\n                </span>\r\n            </span>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\nimport {useSelector} from 'react-redux';\r\n/*Используем библиотеку Formik как аналог библиотеки Redux Form. Последнее нас не устраивает тем, что библиотека\r\nRedux Form использует store из библиотеки Redux, храня среди данных BLL данные UI, и может лишний раз спровоцировать\r\nперерисовку приложения.\r\n\r\nИмпортируем \"Formik\" из этой библиотеки, чтобы создавать компонент \"Formik\", внутри которого указывается код для\r\nсоздания формы. Внутри можно указать атрибут \"validate\", в котором можно указывать валидацию формы. Также внутри нужно\r\nуказывать атрибут \"onSubmit\", который должен содержать логику сабмита данных формы. Также внутри можно указать атрибут\r\n\"initialValues\", содержащий стартовые значения данных формы, которые будут в ней собираться.\r\n\r\nИмпортируем \"Form\" из этой библиотеки, чтобы создавать компонент \"Form\", внутри которого идет создание самой формы с ее\r\nполями.\r\n\r\nИмпортируем \"Field\" из этой библиотеки, чтобы создавать компонент \"Field\", внутри которого идет создание поля для формы.\r\nВнутри может указываться атрибут \"name\" для именования данных, которые будут собираться в этом поле и обрабатываться\r\nдалее в приложении, то есть это аналог атрибута \"name\" из библиотеки Redux Form.*/\r\nimport {Field, Form, Formik} from 'formik';\r\n/*Импортируем селекторы \"getUsersFilter()\" и \"getIsFetching()\".*/\r\nimport {getUsersFilter, getIsFetching} from '../../../redux/users-selectors';\r\n/*Импортируем тип \"UsersFilterType\".*/\r\nimport {UsersFilterType} from '../../../redux/users-reducer';\r\n\r\ntype PropsType = {\r\n    /*Метод для обновления данных по фильтрам для отображения пользователей в постраничном выводе пользователей при\r\n    изменении этих данных должен быть функцией, принимающей параметр типа \"UsersFilterType\" и ничего не возвращающей.*/\r\n    onFilterChange: (filter: UsersFilterType) => void\r\n};\r\n\r\n/*Указываем тип для свойства, содержащее значение для фильтра, работающее следующим образом: если указать в нем \"true\",\r\nто сервер выберет только тех пользователей, которых мы фолловим, если указать \"false\" - только тех, кого мы не фолловим,\r\nесли указать \"null\" или вообще не указывать, то выберет всех пользователей. Здесь мы специально указали это в виде\r\nстроковых значений, так как библиотека Formik работает внутри формы со строковыми значениями. Но в самой форме мы делаем\r\nпреобразования в булев тип и в null для нашего state и для запросов на сервер.*/\r\ntype FilterFriendFormType = 'true' | 'false' | 'null';\r\n\r\n/*Создаем отдельный тип для данных, которые собирает форма ниже в компоненте \"UsersSearchForm\".*/\r\ntype FormType = {\r\n    /*Свойство, содержащее значение для фильтра в виде строкового значения, которое будет получать сервер и искать\r\n    наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких пользователей.*/\r\n    term: string\r\n    /*Свойство, которое содержит значение для фильтра булева типа. Если указать в нем \"true\", то сервер выберет только\r\n    тех пользователей, которых мы фолловим, если указать \"false\" - только тех, кого мы не фолловим, если указать \"null\"\r\n    или вообще не указывать, то выберет всех пользователей. Должно быть типа \"FilterFriendFormType\", который мы создали\r\n    выше.*/\r\n    friend: FilterFriendFormType\r\n};\r\n\r\n/*Выносим отдельно функцию для валидации формы, которая указывается в атрибуте \"validate\" в компоненте \"Formik\" из\r\nбиблиотеки Formik.*/\r\nconst usersSearchFormValidate = (values: any) => {\r\n    /*В данном случае не указали никаких ошибок при валидации.*/\r\n    const errors = {};\r\n    return errors;\r\n};\r\n\r\n/*\"UsersSearchForm\" это функциональный компонент, который создан в виде стрелочной функции. \"UsersSearchForm\" является\r\nкомпонентом, который отображает форму с фильтрами для поиска пользователей на странице с постраничным выводом\r\nпользователей.\r\n\r\nКомпонент \"UsersSearchForm\" импортируется в файле \"Users.tsx\".\r\n\r\nДля оптимизации лишних отрисовок мы оборачиваем этот функциональный компонент при помощи \"React.memo()\".*/\r\nexport const UsersSearchForm: React.FC<PropsType> = React.memo(({onFilterChange}) => {\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getUsersFilter()\", получаем данные для фильтрации\r\n    пользователей в постраничном выводе.*/\r\n    const filter = useSelector(getUsersFilter);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getIsFetching()\", получаем специальное свойство,\r\n    находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного вывода (если в\r\n    процессе, то будет отрисовываться компонент-заглушка \"Preloader\").*/\r\n    const isFetching = useSelector(getIsFetching);\r\n\r\n    /*Создаем callback-функцию \"onSubmitForm()\", которая будет указываться в атрибуте \"onSubmit\" в компоненте \"Formik\"\r\n    из библиотеки Formik и содержать логику сабмита данных формы. Согласно библиотеке Formik эта функция должна\r\n    принимать значения данных формы в виде первого параметра \"values\", который имеет тип \"FormType\", созданный нами\r\n    выше. Вторым параметром эта функция должна принимать функцию \"setSubmitting()\" (будет получена при помощи\r\n    деструктуризации). Указываем, что эта функция \"setSubmitting()\" является функцией, принимающей булев параметр\r\n    \"isSubmitting\" (указываемый внутри стрелочной функции элемента \"Formik\", возвращающей элемент \"Form\", содержащий\r\n    саму форму) и ничего не возвращает. При срабатывании этой функции формируется объект \"filter\" на основе данных формы\r\n    при их сабмите, содержащий данные по фильтрам для отображения пользователей в постраничном выводе пользователей.\r\n    Затем вызывается метод \"onFilterChange()\", в который передается этот объект \"filter\", далее благодаря срабатыванию\r\n    метода \"onFilterChange()\" данные по фильтрам устанавливаются в наш state и формируется запрос данных по\r\n    пользователям для постраничного вывода на сервер, содержащий фильтры для отображения пользователей в постраничном\r\n    выводе. Также при помощи функции \"setSubmitting()\" мы отключаем нашу кнопку на время пока идет запрос данных по\r\n    пользователям на сервер.*/\r\n    const onSubmitForm = (values: FormType, {setSubmitting}: { setSubmitting: (isSubmitting: boolean) => void }) => {\r\n        /*Создаем объект, который содержит данные по фильтрам для отображения пользователей в постраничном выводе\r\n        пользователей. Он будет получать эти данные из формы, которые будут в ней собираться в объекте \"values\" при\r\n        сабмите данных и попадать в эту callback-функцию.*/\r\n        const filter: UsersFilterType = {\r\n            /*Строковое значение из \"values.term\" сохраняем как есть.*/\r\n            term: values.term,\r\n            /*Здесь же строковые значения из \"values.friend\" мы преобразовываем в null и булев тип для нашего state и\r\n            для запросов на сервер.*/\r\n            friend: values.friend === 'null' ? null : values.friend === 'true' ? true : false\r\n        };\r\n\r\n        onFilterChange(filter);\r\n\r\n        if (!isFetching) {\r\n            setSubmitting(false);\r\n        } else {\r\n            setSubmitting(true);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            {/*Создаем элемент \"Formik\" из библиотеки Formik для создания формы. Внутри указываем атрибуты\r\n            \"initialValues\", \"validate\" и \"onSubmit\".*/}\r\n            <Formik\r\n                /*Таким образом указываем библиотеке Formik, чтобы она переинициировала форму при получении новых props,\r\n                например, \"filter.term\" или \"filter.friend\". Если не указывать значение этого атрибута, то будет тоже\r\n                true.*/\r\n                enableReinitialize={true}\r\n                /*В атрибуте \"initialValues\", содержащем стартовые значения данных формы, которые будут в ней\r\n                собираться, указываем значения \"filter.term\" и \"filter.friend\" для свойств \"term\" и \"friend\"\r\n                соответственно. Значение \"filter.friend\" мы преобразовываем в строку при помощи функции \"String()\" и\r\n                указываем, чтобы полученное значение воспринималось как типа \"FilterFriendFormType\" при помощи\r\n                \"as FilterFriendFormType\". Нам нужны здесь строковые значения, так как библиотека Formik работает внутри\r\n                со строковыми значениями данных формы.*/\r\n                initialValues={{term: filter.term, friend: String(filter.friend) as FilterFriendFormType}}\r\n                /*В атрибуте \"validate\", ответственного за валидацию формы из библиотеки Formik, указываем функцию\r\n                \"usersSearchFormValidate()\", которую создали выше.*/\r\n                validate={usersSearchFormValidate}\r\n                /*В атрибуте \"onSubmit\", ответственного за логику сабмита данных формы из библиотеки Formik, указываем\r\n                функцию \"onSubmitForm()\", которую создали выше.*/\r\n                onSubmit={onSubmitForm}\r\n            >\r\n                {/*Внутри элемента \"Formik\" должна указываться таким образом стрелочная функция, которая принимает булев\r\n                параметр \"isSubmitting\" и возвращает элемент \"Form\", содержащий саму форму. Параметр \"isSubmitting\"\r\n                нужен для того, что знать происходит ли сейчас сабмит данных формы или нет. Пока происходит сабмит\r\n                данных формы библиотека Formik по умолчанию делает неактивной кнопку сабмита данных.*/}\r\n                {({isSubmitting}) => (\r\n                    /*При помощи элемента \"Form\" из библиотеки Formik создаем саму форму. Внутри указываем поля формы\r\n                    при помощи элементов \"Field\" из библиотеки Formik.*/\r\n                    <Form>\r\n                        {/*Первое поле формы имеет тип поля для ввода текста и собирает данные в виде свойства \"term\". В\r\n                        этом поле будет вводиться текст, отправляемый на сервер, чтобы сервер мог отфильтровать\r\n                        пользователей, которые содержат этот текст в своем имени, и выдать нам таких пользователей.*/}\r\n                        <Field type='text' name='term'/>\r\n\r\n                        {/*Второе поле формы имеет тип выпадающего списка и собирает данные в виде свойства \"friend\". В\r\n                        этом поле будет выбираться одна из трех опций, которые созданы ниже при помощи элементов\r\n                        \"option\", и значение этой выбранной опции будет отправляться на сервер, чтобы сервер в\r\n                        зависимости от полученного значение мог отфильтровать пользователей для выдачи их нам.*/}\r\n                        <Field as='select' name='friend'>\r\n                            {/*Первым значением в выпадающем списке будет \"null\", что для сервера будет означать вывести\r\n                            всех пользователей.*/}\r\n                            <option value='null'>All</option>\r\n                            {/*Вторым значением в выпадающем списке будет \"true\", что для сервера будет означать вывести\r\n                            только тех пользователей, которых мы фолловим.*/}\r\n                            <option value='true'>Followed</option>\r\n                            {/*Третьим значением в выпадающем списке будет \"false\", что для сервера будет означать\r\n                            вывести только тех пользователей, которых мы не фолловим.*/}\r\n                            <option value='false'>Unfollowed</option>\r\n                        </Field>\r\n\r\n                        {/*Внутри формы также создаем кнопку с текстом \"Find\" для сабмита данных формы. Также этот\r\n                        элемент содержит атрибут \"disabled\" со значением равным \"isSubmitting\". Если \"isSubmitting\"\r\n                        равен, то таким образом можно указать, что больше не происходит сабмит данных формы для того,\r\n                        чтобы кнопка сабмита данных снова стала активна, и мы могли указать новые данные фильтров и\r\n                        сделать сабмит данных.*/}\r\n                        <button type='submit' disabled={isSubmitting}>\r\n                            Find\r\n                        </button>\r\n                    </Form>\r\n                )}\r\n            </Formik>\r\n        </div>\r\n    )\r\n});","/*Классовый компонент позволяет реализовывать локальный state (смотри компонент \"ProfileStatus\") и методы жизненного\r\nцикла классового компонента, а функциональный компонент этого не может делать. Такие возможности классового компонента\r\nбыли созданы благодаря тому, что React на основе класса создает объект и всякий раз взаимодействует с этим объектом. А\r\nпоскольку это объект, значит он может хранить такие вещи как state и методы. Функция же просто вызывается и возвращает\r\nJSX, постоянное общение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция\r\nотработала и удалилась. Для решения этой проблемы в функциональных компонентах были созданы Hooks (хуки).\r\n\r\nHook - это функция, которая может делать side effects. React когда вызывает функциональную компоненту, в которой есть\r\nхуки, он запоминает вызов этих хуков и этого функционального компонента для того, чтобы потом соотносить side effects,\r\nсозданные этими хуками. В отличие от классового компонента React запоминает эту информацию где-то на своей стороне, а не\r\nвнутри объекта, созданного на основе компонента. Хуки нельзя писать в условиях и циклах, так как это нарушает порядок\r\nхуков, который является важным. Можно писать свои кастомные хуки.\r\n\r\nИмпортируем хук \"useState()\", который возвращает массив с двумя элементами. Первый элемент - это значение, которое\r\nхранится в state. Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя первый\r\nэлемент мы заставляем React перерисовывать функциональный компонент. Хук \"useState()\" работает асинхронно, то есть если\r\nмы изменяем какое-либо значение при помощи этого хука, то мы говорим, чтобы React изменил это значение как только\r\nсможет, не обращая внимание на порядок соседних инструкций рядом с кодом, где мы меняем какое-то значение из локального\r\nstate. Нужно помнить, что если наш JSX в компоненте не зависит от хука \"useState()\", то нежелательно хранить какие-то\r\nданные в таком хуке. При вызове нескольких вторых элементов из нескольких хуков \"useState()\" в асинхронных операциях\r\n(например, в запросах на сервер), нужно обращать внимание на порядок этих вторых элементов из нескольких хуков\r\n\"useState()\".\r\n\r\nИмпортируем хук \"useEffect()\", который принимает функцию первым параметром и выполняет ее, когда произойдет отрисовка\r\nкомпонента, то есть после каждого вызова функции \"render()\". Вторым параметром этот хук принимает зависимости - зависимо\r\nот чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то этот хук сработает\r\nтолько один раз. Этот хук используется для side effects. Хук \"useEffect()\" позволяет нам синхронизировать какие-то вещи\r\nв программе между собой. Такая синхронизация нужна для динамического изменения верстки с целью отображения ее\r\nактуального состояния пользователю. Синхронизация между двумя сторонами может работать двунаправленно. Синхронизация\r\nпроисходит после отрисовки компонента, а не до. В хуке \"useEffect()\" на самом деле желательно избегать пустой\r\nзависимости \"[]\" во втором параметре. Если не указать второй параметр в хуке \"useEffect()\" вообще, то он будет\r\nсрабатывать при каждой отрисовке компонента. В первом параметре хука \"useEffect()\" нельзя использовать ключевые слова\r\nasync/await.*/\r\nimport React, {useEffect, useState} from 'react';\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*Импортируем хук \"useHistory()\", который управляет данными, связанными с роутингом и маршрутами, например, с адресной\r\nстрокой (в виде объекта \"history\"). С похожими данными работает HOC \"withRouter()\".*/\r\nimport {useHistory} from 'react-router-dom';\r\n/*Импортируем объект \"queryString\" из библиотеки querystring, чтобы оттуда использовать функцию \"parse()\" для парсинга\r\nстроки и преобразования ее в объект, и функцию \"stringify()\" для обратного преобразования.*/\r\nimport * as queryString from 'querystring';\r\n/*Импортируем TC \"requestUsers()\", TC \"follow()\", TC \"unfollow()\".*/\r\nimport {requestUsers, follow, unfollow, UsersFilterType} from '../../redux/users-reducer';\r\n/*Импортируем объект \"usersAC\", что использовать оттуда ACs.*/\r\nimport {usersAC} from '../../redux/users-reducer';\r\n/*Импортируем селекторы \"getCurrentPage\", \"getPageSize\", \"getTotalUsersCount\", \"getWhoIsInFollowingProgress\",\r\n\"getUsers\", \"getPortionSize\", \"getUsersFilter\" и \"getIsFetching\".*/\r\nimport {\r\n    getCurrentPage, getPageSize, getTotalUsersCount, getWhoIsInFollowingProgress, getUsers, getPortionSize,\r\n    getUsersFilter, getIsFetching\r\n} from '../../redux/users-selectors';\r\n/*Импортируем компонент \"Paginator\".*/\r\nimport {Paginator} from '../common/Paginator/Paginator';\r\n/*Импортируем компонент \"User\".*/\r\nimport {User} from './User/User';\r\n/*Импортируем компонент \"UsersSearchForm\".*/\r\nimport {UsersSearchForm} from './UsersSearchForm/UsersSearchForm';\r\n/*Импортируем компонент \"Preloader\".*/\r\nimport {Preloader} from '../common/Preloader/Preloader';\r\n\r\ntype PropsType = {};\r\n\r\n/*Создаем тип для сформированного на основе параметров адресной строки объекта, который будет содержать свойства,\r\nобозначающие данные для фильтрации пользователей в постраничном выводе.*/\r\ntype QueryParamsType = {\r\n    term?: string,\r\n    friend?: string,\r\n    page?: string\r\n};\r\n\r\n/*\"Users\" это функциональный компонент, который создан в виде стрелочной функции. \"Users\" является компонентом, который\r\nотображает страницу с постраничным выводом пользователей.\r\n\r\nВнутри компонента \"Users\" используются следующие компоненты:\r\n1. \"Preloader\" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,\r\nпока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.\r\n2. \"User\" - компонент, который описывает, как должны выглядеть блоки с информацией о пользователе на странице с\r\nпостраничным выводом пользователей. Импортирован.\r\n3. \"UsersSearchForm\" - компонент, который отображает форму с фильтрами для поиска пользователей на странице с\r\nпостраничным выводом пользователей. Импортирован.\r\n4. \"Paginator\" - компонент, который содержит логику для высчитывания и отображения текущей страницы в постраничном\r\nвыводе пользователей. Импортирован.\r\n\r\nКомпонент \"Users\" импортируется в файле \"App.tsx\".*/\r\nexport const Users: React.FC<PropsType> = (props) => {\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getTotalUsersCount()\", получаем общее количество\r\n    пользователей.*/\r\n    const totalUsersCount = useSelector(getTotalUsersCount);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getCurrentPage()\", получаем номер текущей выбранной\r\n    страницы в постраничном выводе.*/\r\n    const currentPage = useSelector(getCurrentPage);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getPageSize()\", получаем максимальное количество\r\n    пользователей на одной странице в постраничном выводе.*/\r\n    const pageSize = useSelector(getPageSize);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getPortionSize()\", получаем свойство, которое указывает\r\n    какое максимальное количество номеров страниц в постраничном выводе может отображаться в одной порции таких страниц.\r\n    Это сделано, чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность выбирать\r\n    страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими порциями страниц.*/\r\n    const portionSize = useSelector(getPortionSize);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getUsers()\", получаем данные по пользователям для\r\n    постраничного вывода.*/\r\n    const users = useSelector(getUsers);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getWhoIsInFollowingProgress()\", получаем специальное\r\n    свойство, содержащее массив, хранящий ID пользователей, которые в какой-то определенный момент находятся в процессе\r\n    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\n    const WhoIsInFollowingProgress = useSelector(getWhoIsInFollowingProgress);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getUsersFilter()\", получаем данные для фильтрации\r\n    пользователей в постраничном выводе.*/\r\n    const filter = useSelector(getUsersFilter);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getIsFetching()\", получаем специальное свойство,\r\n    обозначающее находится ли в процессе запрос на сервер на получение данных по пользователям для постраничного вывода\r\n    (если в процессе, то будет отрисовываться компонент-заглушка \"Preloader\").*/\r\n    const isFetching = useSelector(getIsFetching);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать специальное свойство, которое показывает то, что мы успели\r\n    уже указать данные для фильтрации пользователей в постраничном выводе или не успели (изначально false). Нам это\r\n    нужно, чтобы затриггерить функцию \"push()\" в компоненте \"Users\", когда мы выбираем первую страницу после того как\r\n    уже выбрали другую страницу в постраничном выводе. Вторая переменная будет хранить функцию из хука \"useState()\",\r\n    которая будет изменять первый элемент (то есть указывать то, что мы успели уже указать данные для фильтрации\r\n    пользователей в постраничном выводе или не успели). При помощи типизации указываем, что первый параметр должен быть\r\n    булева типа.*/\r\n    const [isNotJustCreated, setIsNotJustCreated] = useState<boolean>(false);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать специальное свойство, которое показывает то, что мы еще не\r\n    успели указать данные для фильтрации пользователей в постраничном выводе или успели (изначально true). Нам это\r\n    нужно, чтобы не затриггерить функцию \"push()\" в компоненте \"Users\" при первой отрисовке, то есть когда не указано\r\n    параметров фильтрации пользователей и выбрана первая страница в постраничном выводе по умолчанию, так как\r\n    UI-фреймворк Ant Design при взаимодействии с некоторыми элементами интерфейса (например, при нажатии на кнопки или\r\n    при изменении параметров адресной строки) сворачивает все подменю, чего нам не хотелось бы видеть при первой\r\n    отрисовке компонента. Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый\r\n    элемент (то есть указывать то, что мы еще не успели уже указать данные для фильтрации пользователей в постраничном\r\n    выводе или успели). При помощи типизации указываем, что первый параметр должен быть булева типа.*/\r\n    const [isJustCreated, setIsJustCreated] = useState<boolean>(true);\r\n    const dispatch = useDispatch();\r\n    /*Используем хук \"useEffect()\", чтобы получить данные по пользователям для постраничного вывода при отрисовке\r\n    компонента. Первый параметр это TC \"requestUsers()\" для запроса и установки данных по пользователям в постраничном\r\n    выводе, передав значение текущей выбранной страницы, максимальное количество пользователей на одной странице в\r\n    постраничном выводе и данные для фильтрации пользователей в постраничном выводе. Второй параметр это пустой массив,\r\n    так как мы хотим, чтобы TC \"requestUsers()\" из первого параметра сработал только один раз после создания\r\n    компонента.*/\r\n    useEffect(() => { dispatch(requestUsers(currentPage, pageSize, filter)) }, []);\r\n    /*Сохраняем вызов хука \"useHistory()\" для более краткого использования хука \"useHistory()\".*/\r\n    const history = useHistory();\r\n\r\n    /*Используем хук \"useEffect()\", чтобы синхронизировать данные для фильтрации пользователей в постраничном выводе и\r\n    номер текущей выбранной страницы в постраничном выводе, указанные в параметрах адресной строки, с аналогичными\r\n    данными из глобального state при отрисовке компонента.*/\r\n    useEffect(() => {\r\n            /*Первым параметром мы получаем параметры, указанные в адресной строке (например, строку\r\n            \"?term=a&friend=true&page=2\"), обращаясь к объекту \"history\", который возвращается хуком \"useHistory()\".\r\n            Поскольку нам не нужен знак \"?\" в полученной строке, то мы используем функцию \"substr()\", передав в нее 1 в\r\n            качестве параметра, чтобы считывалось все после первого символа.*/\r\n            const search = history.location.search.substr(1);\r\n            /*Также в рамках первого параметра, при помощи функции \"parse()\" из библиотеки querystring мы парсим строку\r\n            с параметрами адресной строки, превращая ее в объект, например,\r\n            \"{term: \"a\", friend: \"true\", page: \"1\"}\". Также указываем, чтобы этот объект воспринимался как объект типа\r\n            \"QueryParamsType\".*/\r\n            const parsed = queryString.parse(search) as QueryParamsType;\r\n            /*Также в рамках первого параметра, получаем номер актуальной текущей выбранной страницы в постраничном\r\n            выводе.*/\r\n            let actualCurrentPage = currentPage;\r\n            /*Также в рамках первого параметра, получаем актуальные данные для фильтрации пользователей в постраничном\r\n            выводе.*/\r\n            let actualFilter = filter;\r\n            /*Также в рамках первого параметра, если в параметрах адресной строки была указана текущая выбранная\r\n            страница, то ее номер запишется в переменную \"actualCurrentPage\". При помощи функции \"Number()\" приводим\r\n            строку к числу. При помощи \"!!\" переводим значение \"parsed.page\" в булев тип.*/\r\n            if (!!parsed.page) actualCurrentPage = Number(parsed.page);\r\n            /*Также в рамках первого параметра, если в параметрах адресной строки был указан параметр \"term\", то\r\n            значение этого параметра запишется в переменную \"actualFilter\". Делаем здесь глубокое копирование, чтобы\r\n            соблюдать иммутабельность, поскольку работаем с объектом. Если мы укажем в адресной строке какой-либо\r\n            параметр больше одного раза, то ни один из них не будет перезатирать других. И если мы получаем эти\r\n            параметры в виде строки, переводя ее в объект, то этот параметр в объекте будет иметь значение массива со\r\n            всеми значениями этого параметра, указанными в адресной строке, поэтому мы указываем, чтобы значение\r\n            параметра \"term\" воспринималось как строка при помощи \"as string\". При помощи \"!!\" переводим значение\r\n            \"parsed.term\" в булев тип.*/\r\n            if (!!parsed.term) actualFilter = {...actualFilter, term: parsed.term as string};\r\n\r\n            /*Также в рамках первого параметра, если в параметрах адресной строки был указан параметр \"friend\", то\r\n            значение этого параметра запишется в переменную \"actualFilter\". Делаем здесь глубокое копирование, чтобы\r\n            соблюдать иммутабельность, поскольку работаем с объектом. Используем здесь конструкцию \"switch/case\", чтобы\r\n            преобразовывать строковые значения в булев тип или null.*/\r\n            switch (parsed.friend) {\r\n                case 'null': {\r\n                    actualFilter = {...actualFilter, friend: null};\r\n                    break;\r\n                }\r\n\r\n                case 'true': {\r\n                    actualFilter = {...actualFilter, friend: true};\r\n                    break;\r\n                }\r\n\r\n                case 'false': {\r\n                    actualFilter = {...actualFilter, friend: false};\r\n                    break;\r\n                }\r\n            }\r\n\r\n            /*Также в рамках первого параметра вызываем AC \"setCurrentPage()\" для установки значения текущей выбранной\r\n            страницы в постраничном выводе пользователей в state, передав номер актуальной текущей выбранной страницы,\r\n            который был получен из параметров адресной строки.*/\r\n            dispatch(usersAC.setCurrentPage(actualCurrentPage));\r\n            /*Также в рамках первого параметра вызываем TC \"requestUsers()\" для запроса и установки данных по\r\n            пользователям в постраничном выводе, передав значение актуальной текущей выбранной страницы, максимальное\r\n            количество пользователей на одной странице в постраничном выводе и актуальные данные для фильтрации\r\n            пользователей в постраничном выводе.*/\r\n            dispatch(requestUsers(actualCurrentPage, pageSize, actualFilter));\r\n        },\r\n        /*Второй параметр это пустой массив, так как мы хотим, чтобы все, что есть в первом параметре сработало только\r\n        один раз после отрисовки компонента.*/\r\n        []\r\n    );\r\n\r\n    /*Используем хук \"useEffect()\", чтобы синхронизировать данные для фильтрации пользователей в постраничном выводе и\r\n    номер текущей выбранной страницы в постраничном выводе из глобального state с аналогичными данными из UI, чтобы\r\n    указать эти данные в адресной строке в виде параметров. Это использование хука \"useEffect()\" должно обязательно идти\r\n    после предыдущего использования хука \"useEffect()\", иначе будут затираться полученные из параметров адресной строки\r\n    данные при отрисовке компонента, поскольку порядок хуков имеет значение.*/\r\n    useEffect(() => {\r\n            /*В рамках первого параметра создаем объект типа \"QueryParamsType\", в дальнейшем хранящий объект,\r\n            сформированный на основе параметров адресной строки, который будет содержать свойства, обозначающие данные\r\n            для фильтрации пользователей в постраничном выводе и номер текущей выбранной страницы в постраничном выводе.*/\r\n            const query: QueryParamsType = {};\r\n\r\n            /*Также в рамках первого параметра, если есть свойство \"term\" в объекте \"filter\", то добавляем его в наш\r\n            объект \"query\". При помощи \"!!\" переводим значение \"filter.term\" в булев тип. Также указываем, что успели\r\n            указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции\r\n            \"setIsJustCreated()\" и функции \"setIsNotJustCreated()\" из хуков \"useState()\" выше.*/\r\n            if (!!filter.term) {\r\n                query.term = filter.term;\r\n                setIsJustCreated(false);\r\n                setIsNotJustCreated(true);\r\n            }\r\n\r\n            /*Также в рамках первого параметра, если свойство \"friend\" в объекте \"filter\" не равно \"null\", то есть равно\r\n            true или false, то преобразовываем значение этого свойства в строку при помощи функции \"String()\" и\r\n            добавляем преобразованное значение в наш объект \"query\". Также указываем, что успели указать данные для\r\n            фильтрации пользователей в постраничном выводе при помощи вызова функции \"setIsJustCreated()\" и функции\r\n            \"setIsNotJustCreated()\" из хуков \"useState()\" выше.*/\r\n            if (filter.friend !== null) {\r\n                query.friend = String(filter.friend);\r\n                setIsJustCreated(false);\r\n                setIsNotJustCreated(true);\r\n            }\r\n\r\n            /*Также в рамках первого параметра, если номер текущей выбранной страницы не равен 1, то сохраняем этот\r\n            номер, переведя его в строку при помощи функции \"String()\", в наш объект \"query\". Также указываем, что\r\n            успели указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции\r\n            \"setIsJustCreated()\" и функции \"setIsNotJustCreated()\" из хуков \"useState()\" выше.*/\r\n            if (currentPage !== 1) {\r\n                query.page = String(currentPage);\r\n                setIsJustCreated(false);\r\n                setIsNotJustCreated(true);\r\n            }\r\n\r\n            /*Также в рамках первого параметра, если номер текущей выбранной страницы равен 1 и мы успели уже указать\r\n            данные для фильтрации пользователей в постраничном выводе, то сохраняем этот номер, переведя его в строку\r\n            при помощи функции \"String()\", в наш объект \"query\". Также указываем, что успели указать данные для\r\n            фильтрации пользователей в постраничном выводе при помощи вызова функции \"setIsJustCreated()\" из хука\r\n            \"useState()\" выше, но в этот раз вызываем функцию \"setIsNotJustCreated()\" из хука \"useState()\" выше, чтобы\r\n            изменить свойство \"isNotJustCreated\" в локальном state на false, чтобы если мы после того, как мы совершим\r\n            следующие операции:\r\n\r\n            1. отрисовать компонент \"Users\";\r\n            2. указать какие-либо параметры для фильтрации пользователей в постраничном выводе и сделать запрос\r\n            пользователей;\r\n            3. сбросить все параметры (в том числе выбрать первую страницу) для фильтрации пользователей в постраничном\r\n            выводе и сделать запрос пользователей;\r\n            4. отрисовать другой компонент;\r\n            5. еще раз отрисовать компонент \"Users\";\r\n\r\n            мы не затриггерили функцию \"push()\", чтобы библиотека Ant Design не свернула все подменю в навигационном\r\n            меню, так как по стандартному поведению библиотеки Ant Design если мы взаимодействуем с некоторыми\r\n            элементами UI (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все\r\n            подменю.*/\r\n            if (currentPage === 1 && isNotJustCreated) {\r\n                query.page = String(currentPage);\r\n                setIsJustCreated(false);\r\n                setIsNotJustCreated(false);\r\n            }\r\n\r\n            /*Поскольку работа функции \"push()\" по изменению адресной строки считается UI-фреймворком Ant Design за\r\n            взаимодействие с UI, поэтому при первом нажатии на пункт \"Users\" свернется подменю \"People\", так как по\r\n            стандартному поведению UI-фреймворка Ant Design если мы взаимодействуем с некоторыми элементами UI\r\n            (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все подменю. Поэтому\r\n            мы добавили проверку, чтобы выполнять эту функцию \"push()\" только в том случае, когда какие-либо из данных в\r\n            state, которые используются для формирования параметров адресной строки, были изменены.*/\r\n            if (!isJustCreated) {\r\n                /*Также в рамках первого параметра вызываем функцию \"push()\" объекта \"history\", который возвращается\r\n                хуком \"useHistory()\", для того, чтобы перенаправить нас на адрес по пути \"/users\", дописав к этому пути\r\n                параметры адресной строки из свойства \"search\" объекта \"history\".*/\r\n                history.push({\r\n                    pathname: '/users',\r\n                    /*Здесь при помощи функции \"stringify()\" из библиотеки querystring мы преобразовываем наш объект\r\n                    \"query\" в строку, в итоге, например, получая строку \"?term=dad&friend=false&page=2\". Аналогично мы\r\n                    могли бы не формировать наш объект \"query\" сверху и написать здесь так:\r\n                    \"search: `?term=${filter.term}&friend=${filter.friend}&page=${currentPage}`\".*/\r\n                    search: queryString.stringify(query)\r\n                });\r\n            }\r\n        },\r\n        /*Второй параметр это данные для фильтрации пользователей в постраничном выводе, номер текущей выбранной\r\n        страницы в постраничном выводе из глобального state и специальное свойство, которое показывает то, что мы еще не\r\n        успели указать данные для фильтрации пользователей в постраничном выводе или успели. Последнее нам нужно, так\r\n        как после первого выбора страницы по какой-то причине факт того, что \"isJustCreated\" становился false,\r\n        игнорировался и не было обновления параметров адресной строки. Если эти данные будут меняться, то будет\r\n        срабатывать каждый раз все то, что указано в первом параметре.*/\r\n        [filter, currentPage, isJustCreated]\r\n    );\r\n\r\n    /*Создаем специальную функцию, которая будет вызываться при смене страницы в постраничном выводе пользователей. Эта\r\n    функция принимает номер новой текущей выбранной страницы.*/\r\n    const onPageChange = (pageNumber: number) => {\r\n        /*Вызываем AC \"setCurrentPage()\" для установки значения текущей выбранной страницы в постраничном выводе\r\n        пользователей в state, передав номер новой текущей выбранной страницы.*/\r\n        dispatch(usersAC.setCurrentPage(pageNumber));\r\n        /*Вызываем TC \"requestUsers()\" для запроса и установки данных по пользователям в постраничном выводе, передав\r\n        значение новой текущей выбранной страницы, максимальное количество пользователей на одной странице в\r\n        постраничном выводе и данные для фильтрации пользователей в постраничном выводе.*/\r\n        dispatch(requestUsers(pageNumber, pageSize, filter));\r\n    };\r\n\r\n    /*Создаем специальную функцию, которая будет вызываться при изменении данных по фильтрам для отображения\r\n    пользователей в постраничном выводе пользователей. Эта функция принимает данные по фильтрам для отображения\r\n    пользователей в постраничном выводе пользователей, имеющие тип \"UsersFilterType\", который мы создали и импортировали\r\n    сюда.*/\r\n    const onFilterChange = (filter: UsersFilterType) => {\r\n        /*Вызываем TC \"requestUsers()\" для запроса и установки данных по пользователям в постраничном выводе, передав\r\n        значение новой текущей выбранной страницы (указали 1, так как если бы передавали сюда последнюю текущую\r\n        выбранную страницу, то могли бы быть случаи, когда уже вывели несколько страниц пользователей, затем перешли на\r\n        какую-то страницу, кроме первой, потом сделали новый запрос пользователей с другими фильтрами, и в ответ могло\r\n        прийти меньшее количество страниц пользователей, чем номер страницы, которую мы до этого выбрали, например,\r\n        были на 6-й странице, а пришло 5 страниц, в итоге мы окажемся на пустой 6-й странице, а указав 1, после\r\n        каждого нового запроса пользователей нас будет всегда сбрасывать на первую страницу), максимальное количество\r\n        пользователей на одной странице в постраничном выводе и данные для фильтрации пользователей в постраничном\r\n        выводе.*/\r\n        dispatch(requestUsers(1, pageSize, filter));\r\n        /*Вызываем AC \"setCurrentPage()\" для установки значения текущей выбранной страницы в постраничном выводе\r\n        пользователей в state, передав 1 как номер новой текущей выбранной страницы, чтобы избежать случая, когда уже\r\n        вывели несколько страниц пользователей, затем перешли на какую-то страницу, кроме первой, потом сделали новый\r\n        запрос пользователей с другими фильтрами, и в ответ могло прийти меньшее количество страниц пользователей, чем\r\n        номер страницы, которую мы до этого выбрали, например, были на 6-й странице, а пришло 5 страниц, в итоге мы\r\n        окажемся на пустой 6-й странице, а указав 1, после каждого нового запроса пользователей нас будет всегда\r\n        сбрасывать на первую страницу.*/\r\n        dispatch(usersAC.setCurrentPage(1));\r\n    };\r\n\r\n    /*Таким образом используем TC \"unfollow()\" для передачи его в компонент \"User\" ниже.*/\r\n    const unfollowCallback = (userID: number) => { dispatch(unfollow(userID)) };\r\n    /*Таким образом используем TC \"follow()\" для передачи его в компонент \"User\" ниже.*/\r\n    const followCallback = (userID: number) => { dispatch(follow(userID)) };\r\n\r\n    return (\r\n        <div>\r\n            {/*Если в state значение \"isFetching\" является true, то показываем компонент \"Preloader\". Если же компонент\r\n            \"Preloader\" не отрисовывается, то далее отрисовываем компоненты \"UsersSearchForm\", \"Paginator\" и \"User\".*/}\r\n            {isFetching ? <Preloader/> : null}\r\n\r\n            {/*Отрисовываем компонент \"UsersSearchForm\" и передаем ему через props необходимые для него данные. Этот\r\n            компонент представляет собой форму с фильтрами для поиска пользователей по различным критериям. Функция\r\n            \"onFilterChange()\" нужны для обновления данных по фильтрам для отображения пользователей в постраничном\r\n            выводе пользователей при изменении этих данных.*/}\r\n            <UsersSearchForm onFilterChange={onFilterChange}/>\r\n\r\n            {/*Далее отрисовываем компонент \"Paginator\" и передаем ему через props необходимые для него данные.*/}\r\n            <Paginator\r\n                /*Общее количество пользователей. Переименовываем в \"totalItemsCount\", так как компонент \"Paginator\"\r\n                может использоваться для постраничного вывода любых элементов, не только пользователей.*/\r\n                totalItemsCount={totalUsersCount}\r\n                /*Максимальное количество пользователей на одной странице в постраничном выводе.*/\r\n                pageSize={pageSize}\r\n                /*Номер текущей выбранной страницы в постраничном выводе.*/\r\n                currentPage={currentPage}\r\n                /*Функция \"onPageChange()\" для обновления данных при смене текущей выбранной страницы в постраничном\r\n                выводе.*/\r\n                onPageChange={onPageChange}\r\n                /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе может\r\n                отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих\r\n                огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до\r\n                40) и переключаться между этими порциями страниц.*/\r\n                portionSize={portionSize}\r\n            />\r\n\r\n            {/*Далее в отдельном элементе \"div\" отрисовываем компонент \"User\" при помощи функции \"map()\".*/}\r\n            <div>\r\n                {/*В этом элементе <div> будут выводиться компоненты \"User\", отображающие информацию о каждом\r\n                пользователе в постраничном выводе пользователей. */}\r\n                {users.map(u => <User\r\n                    key={u.id}\r\n                    /*Объект с данным по пользователю.*/\r\n                    user={u}\r\n                    /*Специальное свойство, содержащее массив, хранящий ID пользователей, которые в какой-то\r\n                    определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются\r\n                    AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\n                    WhoIsInFollowingProgress={WhoIsInFollowingProgress}\r\n                    /*TC для анфолловинга пользователей.*/\r\n                    unfollow={unfollowCallback}\r\n                    /*TC для фолловинга пользователей.*/\r\n                    follow={followCallback}\r\n                />)}\r\n            </div>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\nimport styles from './Music.module.css';\r\n\r\ntype PropsType = {};\r\n\r\n/*\"Music\" это функциональный компонент, который создан в виде стрелочной функции. \"Music\" является компонентом, который\r\nотображает музыку пользователя.\r\n\r\nКомпонент \"Music\" импортируется в файле \"App.tsx\".*/\r\nexport const Music: React.FC<PropsType> = (props) => {\r\n    return (\r\n        <div>\r\n            Music\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\nimport styles from './News.module.css';\r\n\r\ntype PropsType = {};\r\n\r\n/*\"News\" это функциональный компонент, который создан в виде стрелочной функции. \"News\" является компонентом, который\r\nотображает новости пользователя.\r\n\r\nКомпонент \"News\" импортируется в файле \"App.tsx\".*/\r\nexport const News: React.FC<PropsType> = (props) => {\r\n    return (\r\n        <div>\r\n            News\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\nimport styles from './Settings.module.css';\r\n\r\ntype PropsType = {};\r\n\r\n/*\"Settings\" это функциональный компонент, который создан в виде стрелочной функции. \"Settings\" является компонентом,\r\nкоторый отображает настройки сайта.\r\n\r\nКомпонент \"Settings\" импортируется в файле \"App.tsx\".*/\r\nexport const Settings: React.FC<PropsType> = (props) => {\r\n    return (\r\n        <div>\r\n            Settings\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\nimport styles from './Friends.module.css';\r\n\r\ntype PropsType = {};\r\n\r\n/*\"Friends\" это функциональный компонент, который создан в виде стрелочной функции. \"Friends\" является компонентом,\r\nкоторый отображает друзей пользователя. Но в данный момент этот компонент используется для рассмотрения работы хука\r\n\"useState()\" из React.\r\n\r\nКомпонент \"Friends\" импортируется в файле \"App.tsx\".*/\r\nexport const Friends: React.FC<PropsType> = (props) => {\r\n    return (\r\n        <div>\r\n            Friends\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\nimport {useDispatch, useSelector} from 'react-redux';\r\nimport {Redirect} from 'react-router-dom';\r\n/*Библиотека Redux Form нужна для работы с формами. Эта библиотека добавляет в store, то есть в глобальный state свой\r\nредьюсер и обрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше\r\nделать работы по организации данных форм в редьюсере.\r\n\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обернет другой компонент, является\r\nобщаться со своей частью в редьюсере.\r\n\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, React Final Form,\r\nкоторая работает на хуках. Так же может подойти Formik.\r\n\r\nЭта библиотека, добавляя свою часть в глобальный state, обязуется заниматься круговоротом данных (FLUX) со всеми формами\r\nв приложении. То есть нам самим не нужно будет что-то диспатчить. Часть state, которую создает эта библиотека, не\r\nявляется по сути данными, относящимися к BLL, но при этом находятся в глобальном state.\r\n\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее state есть полезные для этого данные (поля и\r\nсвойства).\r\n\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер, что является\r\nиндикатором для перерисовки в React.\r\n\r\nПосле создания части в глобальном state, нужно необходимые формы оборачивать в функцию \"reduxForm()\" из библиотеки Redux\r\nForm. Как и функция \"connect()\", функция \"reduxForm()\" вызывается дважды, сначала вызывается функция \"reduxForm()\" и мы\r\nнастраиваем ее, а потом она уже возвращает нам некий HOC, и этим HOC-ом при помощи замыкания мы оборачиваем форму,\r\nвследствие чего вокруг компонента с формой появится контейнерный компонент, который будет диспатчить и общаться с\r\nглобальным state.\r\n\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой Redux Form.\r\n\r\nВместо \"input\" необходимо использовать компонент \"Field\" из библиотеки Redux Form. Указывая в нем атрибут \"component\",\r\nмы указываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека Redux Form будет реагировать\r\nна эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особая callback-функция \"handleSubmit()\" в props, который создается при\r\nоборачивании функцией \"reduxForm()\". В форме в событии \"onSubmit\" нужно указывать эту callback-функцию. В этой\r\ncallback-функции отключено дефолтное поведение по перезагрузке страницы. Также в нем идет сбор всех данных и они\r\nупаковываются в объект, а затем вызывается \"props.onSubmit()\" у родителя (то есть у контейнерного компонента над\r\nкомпонентом с формой), в который передается этот объект с данными. То есть мы должны в контейнерный компонент над\r\nкомпонентом с формой передать некий метод, срабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться\r\nдля передачи данных формы во внешний мир, то есть в глобальный state.\r\n\r\nТо есть в нашем случае происходит следующее:\r\n1. callback-функция \"handleSubmit()\" указана в компоненте \"LoginForm\".\r\n2. оборачиваем компонент \"LoginForm\" функцией \"reduxForm()\" в компоненте \"LoginReduxForm\", тем самым предоставляя\r\ncallback-функцию \"handleSubmit()\" для компонента \"LoginForm\".\r\n3. компонент \"LoginReduxForm\" указывается в компоненте \"Login\", куда в событие \"onSubmit\" будет попадать объект с\r\nданными, сформированный в событии \"onSubmit\" при помощи callback-функции \"handleSubmit()\" в компоненте \"LoginForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback-функция \"handleSubmit()\" в компоненте\r\n\"LoginForm\", которая собирает все данные из формы и помещает их в объект. Потом внутри callback-функции \"handleSubmit()\"\r\nвызывается нами созданная callback-функция \"onSubmitForm()\" (доступна из контейнерного компонента \"LoginReduxForm\") из\r\nкомпонента \"Login\". В компонент \"Login\" передается указанный объект с данными и собираются в одном месте, потом эти\r\nданные передаются в компонент \"LoginReduxForm\", из которого перенаправляются в глобальный state в виде объекта под\r\nименем \"login\".\r\n\r\nТо есть общая логика при работе с библиотекой Redux Form такова:\r\n1. выночим саму форму в отдельный компонент;\r\n2. вешаем callback-функцию \"handleSubmit()\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n3. в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n4. оборачиваем эту форму функцией \"reduxForm()\".\r\n\r\nВ компонент \"LoginForm\" внедряются некие дополнительные props (например, та же callback-функция \"handleSubmit()\") ХОКом,\r\nкоторый образуется при помощи компонента \"LoginReduxForm\". Эти props содержатся под именем \"InjectedFormProps\". Эти\r\n\"InjectedFormProps\" также содержат добавленные нами props. Поэтому мы импортировали \"InjectedFormProps\" из библиотеки\r\nRedux Form, чтобы типизировать такие props в компоненте \"LoginForm\".*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\n/*Импортируем TC \"login()\".*/\r\nimport {login} from '../../redux/auth-reducer';\r\n/*Импортируем селекторы \"getCaptchaURL()\" и \"getIsAuth()\".*/\r\nimport {getCaptchaURL, getIsAuth} from '../../redux/auth-selectors';\r\nimport styles from './Login.module.css';\r\nimport style from '../common/FormsControls/FormsControls.module.css';\r\n/*Импортируем созданный нами компонент \"Input\" для создания элемента \"input\" с возможностью указывать валидацию. Также\r\nимпортируем функцию \"createField()\", которая принимает параметры и создает элементы формы. Мы ее используем для создания\r\nформы в компоненте \"LoginForm\". Дополнительно импортируем тип \"GetValuesKeysType\".*/\r\nimport {createField, GetValuesKeysType, Input} from '../common/FormsControls/FormsControls';\r\n/*Импортируем валидаторы для полей форм.*/\r\nimport {maxLengthCreator, required} from '../../utils/validators/validators';\r\n\r\n/*Создаем общий тип для всех props компонента \"Login\".*/\r\ntype LoginPropsType = {};\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"LoginForm\".*/\r\ntype LoginFormOwnPropsType = {\r\n    /*Путь к капче, который должен быть строкой или null, то есть быть пустым.*/\r\n    captchaURL: string | null\r\n};\r\n\r\n/*Создаем тип для props компонента \"LoginForm\", которые будут использоваться в \"formData\" для компонента \"Login\".*/\r\ntype LoginFormValuesType = {\r\n    /*Email пользователя, который должен быть строкой.*/\r\n    email: string\r\n    /*Пароль пользователя, который должен быть строкой.*/\r\n    password: string\r\n    /*Информация запомнить ли пользователя, которая должна быть булева типа.*/\r\n    rememberMe: boolean\r\n    /*Путь к капче, который должен быть строкой.*/\r\n    captcha: string\r\n};\r\n\r\n/*Следующий тип мы создаем специально, чтобы мы не могли допустить ошибок при указании свойства \"name\" в функции\r\n\"createField()\". Это свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы\r\nиспользуем вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"LoginFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"LoginFormValuesType\".*/\r\ntype LoginFormValuesKeysType = GetValuesKeysType<LoginFormValuesType>;\r\n\r\n/*Создаем валидатор, который проверяет не введено ли больше 30 символов в поле.*/\r\nconst maxLength30 = maxLengthCreator(30);\r\n\r\n/*\"LoginForm\" это функциональный компонент, который создан в виде стрелочной функции. \"LoginForm\" является компонентом,\r\nкоторый представляет собой форму логинизации в виде заготовки для оборачивания ее функцией \"reduxForm()\".\r\n\r\nВнутри компонента \"LoginForm\" используются следующие компоненты:\r\n1. \"Input\" - компонент, который используется для отрисовки элементов \"input\" в других местах, где в таких элементах\r\nтребуется валидация. Импортирован.\r\n\r\nКомпонент \"LoginForm\" используется в компоненте \"LoginReduxForm\" в этом же файле и оборачивается функцией \"reduxForm()\",\r\nтем самым получая callback-функцию \"handleSubmit()\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"handleSubmit\" - callback-функция \"handleSubmit()\".\r\n2. \"error\" - текст ошибки, которая может появиться при использовании формы, формируется при помощи библиотеки Redux\r\nForm.\r\n3. \"captchaURL\" - URL капчи при логинизации.\r\n\r\nУказываем при помощи \"React.FC<>\", что props в этом функциональном компоненте имеют тип\r\n\"InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType>\".\r\n\r\nТакая комбинация получилась следующим образом:\r\n1. \"InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType>\" - здесь мы уточняем внедренные ХОКом, который\r\nобразуется при помощи компонента \"LoginReduxForm\", \"InjectedFormProps\". \"LoginFormValuesType\" указывает, что приходит из\r\nэтого ХОКа, а \"LoginFormOwnPropsType\" указывает, что приходит со стороны - \"captchaURL\".\r\n2. \"& LoginFormOwnPropsType\" - также этот компонент содержит некие свои \"собственные props\", которые не приходят от ХОКа\r\nвыше - тот же \"captchaURL\".\r\n\r\nЭто мы делаем на основании файла декларации \"InjectedFormProps\". Там указано, что первым параметром принимаются\r\n\"formData\" - то есть какие именно данные собирает форма в компоненте, оборачиваемый функцией \"reduxForm()\" (то есть\r\nкомпонент \"LoginForm\"), и \"собственные props\" этого компонента \"LoginForm\", непреходящие от ХОКа выше (так нужно для\r\nвнутренней работы \"InjectedFormProps\"). А вторым параметром принимаются еще раз некие свои \"собственные props\", которые\r\nне приходят от ХОКа выше (так уже надо для работы самого этого компонента \"LoginForm\"). Третьим параметром принимается\r\nвид ошибки формы с типом строки, но в данном случае мы этого не указываем.\r\n\r\nТолько все эти три параметра указываются как бы вместе как единый параметр, а не через запятую как три разных параметра.\r\nВОЗМОЖНО, это так потому, что \"InjectedFormProps\" является объектом (как единое целое состоит из разных свойств, которые\r\nможно типизировать суммой разных типов), а та же функция \"reduxForm()\" является функцией (принимает последовательность\r\nпараметров, где каждый параметр нужно отдельно типизировать).*/\r\nconst LoginForm: React.FC<InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType> =\r\n    ({handleSubmit, error, captchaURL}) => {\r\n        return (\r\n            /*Здесь в элементе \"form\" в событии \"onSubmit\" указываем callback-функцию \"handleSubmit()\".*/\r\n            <form onSubmit={handleSubmit}>\r\n                {/*Создаем поле для ввода почты на основе импортированной функции \"createField()\". Уточняем здесь\r\n                функцию \"createField()\", что она имеет тип \"LoginFormValuesKeysType\", созданный нами выше.*/}\r\n                {createField<LoginFormValuesKeysType>(\r\n                    'Email',\r\n                    'email',\r\n                    Input,\r\n                    [required, maxLength30]\r\n                )}\r\n\r\n                {/*Создаем поле для ввода пароля на основе импортированной функции \"createField()\".*/}\r\n                {createField<LoginFormValuesKeysType>(\r\n                    'Password',\r\n                    'password',\r\n                    Input,\r\n                    [required, maxLength30],\r\n                    {type: 'password'}\r\n                )}\r\n\r\n                {/*Добавляем чек-бокс \"Запомнить меня?\" на основе импортированной функции \"createField()\". undefined\r\n                означает отсутствие свойства.*/}\r\n                {createField<LoginFormValuesKeysType>(\r\n                    undefined,\r\n                    'rememberMe',\r\n                    Input,\r\n                    [],\r\n                    {type: 'checkbox'},\r\n                    'Remember me?'\r\n                )}\r\n\r\n                {/*Если есть капча, то отрисуем элемент \"img\" с изображением капчи.*/}\r\n                {captchaURL && <img src={captchaURL} alt=''/>}\r\n\r\n                {/*Если есть капча, то отрисуем поле для ввода текста с капчи. Это поле создается на основе\r\n                импортированной функции \"createField()\".*/}\r\n                {captchaURL && createField<LoginFormValuesKeysType>(\r\n                    'Enter the captcha',\r\n                    'captcha',\r\n                    Input,\r\n                    [required]\r\n                )}\r\n\r\n                {/*Если произошла какая-то ошибка, то выведем ее в отдельном элементе \"div\". Свойство \"error\" будет в\r\n                объекте props благодаря библиотеке Redux Form, в него подцепится значение из TC \"login()\" из файла\r\n                \"auth-reducer.ts\".*/}\r\n                {error && <div className={style.formSummaryError}>{error}</div>}\r\n\r\n                {/*Создаем специальный элемент \"div\", внутри которого будет находиться элемент \"button\", используемый\r\n                как кнопка для сабмита данных введенных в форму.*/}\r\n                <div>\r\n                    <button>Log in</button>\r\n                </div>\r\n            </form>\r\n        );\r\n    };\r\n\r\n/*Компонент \"LoginReduxForm\" является отдельным контейнерным компонентом, цель которого в этом же файле обернуть\r\nкомпонент \"LoginForm\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\". Именно компонент\r\n\"LoginReduxForm\" будет заниматься общением с глобальным state.\r\n\r\nВнутри компонента \"LoginReduxForm\" используются следующие компоненты:\r\n1. \"LoginForm\" - компонент, который представляет собой форму логинизации в виде заготовки для оборачивания ее функцией\r\n\"reduxForm()\". Из этого же файла.\r\n\r\nКомпонент \"LoginReduxForm\" используется в компоненте \"Login\" в этом же файле.\r\n\r\nФункция \"reduxForm()\" является generic, поэтому мы ее уточняем. В файле декларации функции \"reduxForm()\" указано, что\r\nона принимает следующие данные:\r\n1. \"formData\" - какие именно данные собирает форма в компоненте (то есть в компоненте \"LoginForm\"), оборачиваемым\r\nфункцией \"reduxForm()\";\r\n2. \"собственные props\" компонента (то есть компонента \"LoginForm\"), которого оборачиваем функцией \"reduxForm()\";\r\n3. вид ошибки формы с типом строки, но в данном случае мы этого не указываем.*/\r\nconst LoginReduxForm = reduxForm<LoginFormValuesType, LoginFormOwnPropsType>({\r\n    /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный state.*/\r\n    form: 'login'\r\n})(LoginForm);\r\n\r\n/*\"Login\" это функциональный компонент, который создан в виде стрелочной функции. \"Login\" является компонентом, который\r\nпредставляет собой финальную страницу с формой логинизации.\r\n\r\nВнутри компонента \"LoginForm\" используются следующие компоненты:\r\n1. \"LoginReduxForm\" - отдельный контейнерный компонентом, цель которого в этом же файле обернуть компонент \"LoginForm\"\r\nфункцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\". Из этого же файла.\r\n\r\nКомпонент \"Login\" импортируется в файле \"App.tsx\".*/\r\nexport const Login: React.FC<LoginPropsType> = (props) => {\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getCaptchaURL()\", получаем URL капчи при логинизации.*/\r\n    const captchaURL = useSelector(getCaptchaURL);\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getIsAuth()\", получаем информацию являемся ли мы\r\n    залогиненными в приложение или нет.*/\r\n    const isAuth = useSelector(getIsAuth);\r\n    const dispatch = useDispatch();\r\n\r\n    /*Создаем специальную callback-функцию \"onSubmitForm()\", которая будет вызываться при срабатывании события\r\n    \"onSubmit\" в форме. Эта callback-функция будет собирать все данные формы (email пользователя, пароль пользователя,\r\n    указание запомнить ли данные входа, и капча, если присутствует) в одном месте. Эти данные будут отдаваться в TC\r\n    \"login()\" для осуществления логинизации. Эта callback-функция получает указанные данные на входе в объекте\r\n    \"formData\" с типом \"LoginFormValuesType\".*/\r\n    const onSubmitForm = (formData: LoginFormValuesType) => {\r\n        dispatch(login(formData.email, formData.password, formData.rememberMe, formData.captcha));\r\n    };\r\n\r\n    /*Если пользователь залогинен, то его должно перенаправить на страницу профиля, вместо показа формы для\r\n    логинизации.*/\r\n    if (isAuth) return <Redirect to={'/profile/'}/>;\r\n\r\n    return (\r\n        <div>\r\n            {/*Отрисовываем элемент \"h1\" c текстом \"Log in\".*/}\r\n            <h1>Log in</h1>\r\n            {/*Здесь в событии \"onSubmit\" будет приходить объект с данными из callback-функции \"handleSubmit()\" из\r\n            компонента \"LoginForm\", который обернут компонентом \"LoginReduxForm\". Далее будет вызываться при этом\r\n            событии нами созданная callback-функция \"onSubmitForm\", в которую будет передаваться этот объект с данными.\r\n            После этого эти данные будут отправлены в часть глобального state, которую обрабатывает библиотека Redux\r\n            Form, с целью осуществления работы нашей формы логина. Поскольку мы вызываем функцию \"onSubmitForm()\" как\r\n            callback-функцию, то поэтому не ставим \"()\" после имени функции.*/}\r\n            <LoginReduxForm onSubmit={onSubmitForm} captchaURL={captchaURL}/>\r\n        </div>\r\n    );\r\n};","import React, {useState} from 'react';\r\nimport styles from './UseStateTheory.module.css';\r\n\r\ntype PropsType = {};\r\n\r\n/*\"UseStateTheory\" это функциональный компонент, который создан в виде стрелочной функции. \"UseStateTheory\" является\r\nкомпонентом, который используется для рассмотрения работы хука \"useState()\" из React. Является аналогом компонента\r\n\"UseEffectTheory1\".\r\n\r\nКомпонент \"UseStateTheory\" импортируется в файле \"App.tsx\".*/\r\nexport const UseStateTheory: React.FC<PropsType> = (props) => {\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать количество жизней у первого игрока (изначально 10). Вторая\r\n    переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть менять\r\n    количество жизней у первого игрока). Используется в примере использования хука \"useState()\" №1.*/\r\n    const [playerOneLife, setPlayerOneLife] = useState(10);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать количество жизней у второго игрока (изначально 10). Вторая\r\n    переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть менять\r\n    количество жизней у второго игрока). Используется в примере использования хука \"useState()\" №1.*/\r\n    const [playerTwoLife, setPlayerTwoLife] = useState(10);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать количество жизней у игроков (данные здесь уже в виде\r\n    объекта). Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то\r\n    есть менять количество жизней у игроков). Используется в примере использования хука \"useState()\" №2.*/\r\n    const [playersLives, setPlayersLives] = useState({p1: 10, p2: 10});\r\n\r\n    /*Представим, что это массив с данными по очкам игроков. Каждый игрок имеет два числа очков, далее нам нужно будет\r\n    вычислить игрока, у которого одно из двух чисел будет самым больших из всех. Используется в примере использования\r\n    хука \"useState()\" №3.*/\r\n    const players: Array<[number, number]> = [\r\n        // ... a lot of players,\r\n        [34, 27],\r\n        [68, 68],\r\n        [22, 69],\r\n        [50, 54]\r\n    ];\r\n\r\n    /*Создаем алгоритм для поиска наилучшей пары очков у игроков. Сложность этого алгоритма \"O(n)\", так как мы\r\n    пробегаемся по каждому элементу в массиве. Используется в примере использования хука \"useState()\" №3.*/\r\n    function findBestPlayer(players: Array<[number, number]>) {\r\n        /*Для отслеживания сколько раз срабатывает эта функция.*/\r\n        console.log('O(n) again');\r\n        /*Переменная, которая будет хранить лучшую пару очков.*/\r\n        let maxPair = null;\r\n\r\n        /*Пробегаемся по массиву \"players\".*/\r\n        for (let i = 0; i < players.length; i++) {\r\n            /*Если нет лучшей пары очков, то говорим, что текущая пара является лучше.*/\r\n            if (maxPair === null) {\r\n                maxPair = players[i]\r\n                /*Иначе находим наибольшее число из двух в текущей паре очков и сравниваем с наибольшим числом в текущей\r\n                лучшей паре очков. Если в текущей паре есть число больше, то эта текущая пара становится лучшей.*/\r\n            } else if (Math.max(players[i][0], players[i][1]) > Math.max(maxPair[0], maxPair[1])) {\r\n                maxPair = players[i];\r\n            }\r\n        }\r\n\r\n        /*В итоге возвращаем пару очков, в которой одно из двух чисел больше любого другого числа в других парах\r\n        очков.*/\r\n        return maxPair;\r\n    };\r\n\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать количество жизней у третьего игрока (изначально 10).\r\n    Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть менять\r\n    количество жизней у третьего игрока).\r\n\r\n    В целях оптимизации в стартовом значении лучше указывать функцию, которая возвращает это значение, а не просто само\r\n    значение, если это стартовое значение получается при помощи какой-то сложной логики. Если представить, что \"players\"\r\n    мы будем получать через props и укажем здесь стартовое значение как \"bestPair[0]\" (или \"bestPair[1]\" в хуке\r\n    \"useState()\" дальше), оставив код для поиска этого значения за пределами хука \"useState()\", то при каждой отрисовке\r\n    компонента будет срабатывать сложный алгоритм из функции \"findBestPlayer()\", что будет плохо влиять на оптимизацию.\r\n    Используется в примере использования хука \"useState()\" №3.*/\r\n    const [playerThreeLife, setPlayerThreeLife] = useState(() => {\r\n        /*Находим лучшую пару очков.*/\r\n        const bestPair = findBestPlayer(players);\r\n        /*Если не нашли лучшую пару очков, то возвращаем 10 как стартовое значение.*/\r\n        if (bestPair === null) return 10;\r\n        /*Если нашли лучшую пару очков, то возвращаем из нее первое число как стартовое значение.*/\r\n        return bestPair[0];\r\n    });\r\n\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать количество жизней у четвертого игрока (изначально 10).\r\n    Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть менять\r\n    количество жизней у четвертого игрока). Используется в примере использования хука \"useState()\" №3.*/\r\n    const [playerFourLife, setPlayerFourLife] = useState(() => {\r\n        /*Находим лучшую пару очков.*/\r\n        const bestPair = findBestPlayer(players);\r\n        /*Если не нашли лучшую пару очков, то возвращаем 10 как стартовое значение.*/\r\n        if (bestPair === null) return 10;\r\n        /*Если нашли лучшую пару очков, то возвращаем из нее второе число как стартовое значение.*/\r\n        return bestPair[1];\r\n    });\r\n\r\n    return (\r\n        <div>\r\n            {/*Пример использования хука \"useState()\" №1.*/}\r\n            <div className={styles.wholeGame}>\r\n                <div className={styles.playerOneSection}>\r\n                    <div className={styles.playerOneName}>\r\n                        <span>Player One</span>\r\n                    </div>\r\n\r\n                    <div className={styles.playerOneLife}>\r\n                        <span>{playerOneLife}</span>\r\n                    </div>\r\n\r\n                    <div className={styles.increasePlayerOneLifeSection}>\r\n                        <button\r\n                            className={styles.increasePlayerOneLifeButton}\r\n                            /*При вызове функции из хука \"useState()\", которая меняет значения в локальном state, лучше\r\n                            передавать в нее отдельную функцию, а не само значение из локального state, поскольку хук\r\n                            \"useState()\" работает асинхронно и мы можем получить неактуальное значение из локального\r\n                            state. То есть так лучше не делать: \"setPlayerOneLife(playerOneLife + 1)\".*/\r\n                            onClick={() => setPlayerOneLife((actualValue) => actualValue + 1)}>+\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className={styles.decreaseAllLivesSection}>\r\n                    <button\r\n                        className={styles.decreaseAllLivesButton}\r\n\r\n                        onClick={() => {\r\n                            setPlayerOneLife((actualValue) => actualValue - 1);\r\n                            setPlayerTwoLife((actualValue) => actualValue - 1);\r\n                        }}>-\r\n                    </button>\r\n                </div>\r\n\r\n                <div className={styles.playerTwoSection}>\r\n                    <div className={styles.playerTwoName}>\r\n                        <span>Player Two</span>\r\n                    </div>\r\n\r\n                    <div className={styles.playerTwoLife}>\r\n                        <span>{playerTwoLife}</span>\r\n                    </div>\r\n\r\n                    <div className={styles.increasePlayerTwoLifeSection}>\r\n                        <button\r\n                            className={styles.increasePlayerTwoLifeButton}\r\n                            onClick={() => setPlayerTwoLife((actualValue) => actualValue + 1)}>+\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            {/*Пример использования хука \"useState()\" №2.*/}\r\n            <div className={styles.wholeGame}>\r\n                <div className={styles.playerOneSection}>\r\n                    <div className={styles.playerOneName}>\r\n                        <span>Player One</span>\r\n                    </div>\r\n\r\n                    <div className={styles.playerOneLife}>\r\n                        <span>{playersLives.p1}</span>\r\n                    </div>\r\n\r\n                    <div className={styles.increasePlayerOneLifeSection}>\r\n                        <button\r\n                            className={styles.increasePlayerOneLifeButton}\r\n                            /*Правило иммутабельности важно для React, так как когда мы изменяем входной объект в\r\n                            функции, то не происходит создания ссылки на новый объект и React не перерисовывает\r\n                            компонент. То есть перерисовки не будет, если использовать такой код:\r\n                            \"onClick={() => setPlayersLives((actualValue) => {\r\n                                actualValue.p1++;\r\n                                return actualValue;\r\n                            })}\"*/\r\n                            onClick={() => setPlayersLives((actualValue) => {\r\n                                return {...actualValue, p1: actualValue.p1 + 1};\r\n                            })}>+\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className={styles.decreaseAllLivesSection}>\r\n                    <button\r\n                        className={styles.decreaseAllLivesButton}\r\n\r\n                        onClick={() => setPlayersLives((actualValue) => {\r\n                            /*Здесь можно и не писать \"...actualValue\", так как после этой деструктуризации мы отдельно\r\n                            создаем новый объект с новыми свойствами. Но лучше это писать, так как при использовании\r\n                            хука \"useState()\" новые свойства затирают старые (тогда как в локальном state в классовом\r\n                            компоненте свойства дописываются), то есть если мы добавим в дальнейшем еще и \"p3\" в\r\n                            локальный state, то мы потеряем это.*/\r\n                            return {...actualValue, p1: actualValue.p1 - 1, p2: actualValue.p2 - 1};\r\n                        })}>-\r\n                    </button>\r\n                </div>\r\n\r\n                <div className={styles.playerTwoSection}>\r\n                    <div className={styles.playerTwoName}>\r\n                        <span>Player Two</span>\r\n                    </div>\r\n\r\n                    <div className={styles.playerTwoLife}>\r\n                        <span>{playersLives.p2}</span>\r\n                    </div>\r\n\r\n                    <div className={styles.increasePlayerTwoLifeSection}>\r\n                        <button\r\n                            className={styles.increasePlayerTwoLifeButton}\r\n\r\n                            onClick={() => setPlayersLives((actualValue) => {\r\n                                return {...actualValue, p2: actualValue.p2 + 1};\r\n                            })}>+\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            {/*Пример использования хука \"useState()\" №3.*/}\r\n            <div className={styles.wholeGame}>\r\n                <div className={styles.playerOneSection}>\r\n                    <div className={styles.playerOneName}>\r\n                        <span>Player One</span>\r\n                    </div>\r\n\r\n                    <div className={styles.playerOneLife}>\r\n                        <span>{playerThreeLife}</span>\r\n                    </div>\r\n\r\n                    <div className={styles.increasePlayerOneLifeSection}>\r\n                        <button\r\n                            className={styles.increasePlayerOneLifeButton}\r\n                            onClick={() => setPlayerThreeLife((actualValue) => actualValue + 1)}>+\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className={styles.decreaseAllLivesSection}>\r\n                    <button\r\n                        className={styles.decreaseAllLivesButton}\r\n\r\n                        onClick={() => {\r\n                            setPlayerThreeLife((actualValue) => actualValue - 1);\r\n                            setPlayerFourLife((actualValue) => actualValue - 1);\r\n                        }}>-\r\n                    </button>\r\n                </div>\r\n\r\n                <div className={styles.playerTwoSection}>\r\n                    <div className={styles.playerTwoName}>\r\n                        <span>Player Two</span>\r\n                    </div>\r\n\r\n                    <div className={styles.playerTwoLife}>\r\n                        <span>{playerFourLife}</span>\r\n                    </div>\r\n\r\n                    <div className={styles.increasePlayerTwoLifeSection}>\r\n                        <button\r\n                            className={styles.increasePlayerTwoLifeButton}\r\n                            onClick={() => setPlayerFourLife((actualValue) => actualValue + 1)}>+\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};","import React, {useState, useEffect} from 'react';\r\nimport axios from 'axios';\r\nimport styles from './SearchUsersArea.module.css';\r\n/*Импортируем типы \"SelectedGitHubUserType\", \"GitHubSearchResult\" и \"selectedGitHubUserDetailsType\".*/\r\nimport {SelectedGitHubUserType, GitHubSearchResult, selectedGitHubUserDetailsType} from '../UseEffectTheory';\r\n\r\ntype PropsType = {\r\n    /*Callback-функция для установки массива с пользователями GitHub, которая принимает массив с элементами типа\r\n    \"SelectedGitHubUserType\" и ничего не возвращает.*/\r\n    setGitHubUsers: (gitHubUsers: SelectedGitHubUserType[]) => void\r\n    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа\r\n    \"selectedGitHubUserDetailsType\" или null, и ничего не возвращает.*/\r\n    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void\r\n    /*Детали профиля выбранного пользователя GitHub должны быть типа \"selectedGitHubUserDetailsType\" или null.*/\r\n    selectedGitHubUserDetails: selectedGitHubUserDetailsType | null\r\n    /*Callback-функция для установки значения, показывающего идет ли сейчас запрос пользователей GitHub или нет, которая\r\n    принимает параметр булева типа и ничего не возвращает.*/\r\n    setIsRequestingGitHubUsers: (isRequestingGitHubUsers: boolean) => void\r\n};\r\n\r\n/*\"SearchUsersArea\" это функциональный компонент, который создан в виде стрелочной функции. \"SearchUsersArea\" является\r\nкомпонентом, используемым для создания поля для ввода текста, по которому будет осуществляться поиск пользователя\r\nGitHub.\r\n\r\nКомпонент \"SearchUsersArea\" импортируется в файле \"UseEffectTheory\".*/\r\nexport const SearchUsersArea: React.FC<PropsType> = ({\r\n                                                         setGitHubUsers,\r\n                                                         setSelectedGitHubUserDetails,\r\n                                                         selectedGitHubUserDetails,\r\n                                                         setIsRequestingGitHubUsers\r\n                                                     }) => {\r\n    console.log('RENDERING THE SEARCH AREA');\r\n    /*Изначальный текст для поиска.*/\r\n    const initialSearchText = 'alty';\r\n    /*Текст №1 для поиска после сброса.*/\r\n    const resetSearchText = 'Enter something';\r\n    /*Текст №2 для поиска после сброса.*/\r\n    const resetSearchText2 = 'Enter something';\r\n    /*Изначальное имя вкладки.*/\r\n    const initialTabName = 'React App';\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать то, что введено в данным момент в строку поиска\r\n    пользователей GitHub (изначально берется из переменной \"initialSearchText\") для осуществления FLUX-круговорота в\r\n    этой строке поиска. Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый\r\n    элемент (то есть указывать, что должно быть введено в строку поиска пользователей GitHub).*/\r\n    const [localSearchTerm, setLocalSearchTerm] = useState(initialSearchText);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать текст, по которому будет отправлен запрос поиска\r\n    пользователей GitHub (изначально берется из переменной \"initialSearchText\"). Вторая переменная будет хранить функцию\r\n    из хука \"useState()\", которая будет изменять первый элемент (то есть указывать текст, по которому будет отправлен\r\n    запрос поиска пользователей GitHub).*/\r\n    const [gitHubSearchTerm, setGitHubSearchTerm] = useState(initialSearchText);\r\n\r\n    /*Используем хук \"useEffect()\", чтобы при каждом изменении текста, по которому будет отправлен запрос поиска\r\n    пользователей GitHub, вызывать такой запрос.*/\r\n    useEffect(\r\n        /*Первый параметр это функция для запроса поиска пользователей GitHub.*/\r\n        () => {\r\n            console.log('REQUESTING USERS');\r\n            /*Указываем, что идет запрос пользователей GitHub, чтобы в компоненте \"SearchUsersAreaResults\" отобразить\r\n            компонент-заглушку \"Preloader\" пока запрос не завершится.*/\r\n            setIsRequestingGitHubUsers(true);\r\n\r\n            axios\r\n                .get<GitHubSearchResult>(`https://api.github.com/search/users?q=${gitHubSearchTerm}`)\r\n                .then(response => {\r\n                    setGitHubUsers(response.data.items);\r\n                    /*Указываем, что запрос пользователей GitHub больше не идет, чтобы в компоненте\r\n                    \"SearchUsersAreaResults\" отключить компонент-заглушку \"Preloader\".*/\r\n                    setIsRequestingGitHubUsers(false);\r\n                });\r\n        },\r\n        /*Второй параметр это текст, по которому будет отправлен запрос поиска пользователей GitHub, из хука\r\n        \"useState()\". Если это значение будет меняться, то будет срабатывать каждый раз функция из первого параметра.*/\r\n        [gitHubSearchTerm]\r\n    );\r\n\r\n    return (\r\n        <div className={styles.searchUsersArea}>\r\n            <input\r\n                className={styles.searchUsersAreaInput}\r\n                placeholder='Enter a GitHub username'\r\n                /*Это поле берет значение из \"localSearchTerm\" из хука \"useState()\". Мы не можем напрямую ввести в это\r\n                поле текст, только через FLUX-круговорот.*/\r\n                value={localSearchTerm}\r\n                /*При изменении нами текста в поле будет вызываться функция \"setLocalSearchTerm()\" из хука \"useState()\",\r\n                чтобы осуществлять FLUX-круговорот текста в этом поле.*/\r\n                onChange={(e) => { setLocalSearchTerm(e.currentTarget.value) }}\r\n            />\r\n\r\n            <button\r\n                className={styles.searchUsersAreaButton}\r\n                /*При нажатии на эту кнопку при помощи функции \"setGitHubSearchTerm()\" из хука \"useState()\" мы\r\n                устанавливаем текст, по которому будет отправлен запрос поиска пользователей GitHub. Будет\r\n                подхватываться из \"localSearchTerm\" из хука \"useState()\".*/\r\n                onClick={() => { setGitHubSearchTerm(localSearchTerm) }}>\r\n                Find\r\n            </button>\r\n\r\n            <button className={styles.searchUsersAreaResetButton}\r\n                    onClick={() => {\r\n                        /*При нажатии на эту кнопку при помощи функции \"setGitHubSearchTerm()\" из хука \"useState()\" мы\r\n                        устанавливаем текст, по которому будет отправлен запрос поиска пользователей GitHub. Нужно для\r\n                        сброса текста, который указан в переменной \"resetSearchText2\".*/\r\n                        setGitHubSearchTerm(resetSearchText2);\r\n                        /*При нажатии на эту кнопку при помощи функции \"setLocalSearchTerm()\" из хука \"useState()\" мы\r\n                        устанавливаем текст, который будет введен в поле ввода текста и по нему в дальнейшем будет\r\n                        запрос поиска пользователей GitHub. Нужно для сброса текста, который указан в переменной\r\n                        \"resetSearchText\".*/\r\n                        setLocalSearchTerm(resetSearchText);\r\n                        /*При нажатии на эту кнопку при помощи функции \"setSelectedGitHubUserDetails()\" из хука\r\n                        \"useState()\" мы сбрасываем детали профиля выбранного пользователя GitHub.*/\r\n                        if (selectedGitHubUserDetails !== null) setSelectedGitHubUserDetails(null);\r\n                        /*При нажатии на эту кнопку сбрасываем заголовок страницы.*/\r\n                        document.title = initialTabName;\r\n                        /*При нажатии на эту кнопку при помощи функции \"setGitHubUsers*()\" из хука \"useState()\" мы\r\n                        сбрасываем массив с пользователями GitHub, чтобы очистить список.*/\r\n                        setGitHubUsers([]);\r\n                    }}>\r\n                Reset\r\n            </button>\r\n        </div>\r\n    );\r\n};","import React, {useState, useEffect} from 'react';\r\nimport axios from 'axios';\r\nimport styles from './SearchUsersAreaResults.module.css';\r\n/*Импортируем компонент \"Preloader\".*/\r\nimport {Preloader} from '../../../common/Preloader/Preloader';\r\n/*Импортируем типы \"SelectedGitHubUserType\" и \"selectedGitHubUserDetailsType\".*/\r\nimport {SelectedGitHubUserType, selectedGitHubUserDetailsType} from '../UseEffectTheory';\r\n\r\ntype PropsType = {\r\n    /*Массив с пользователями GitHub должен быть массивом с элементами типа \"SelectedGitHubUserType\".*/\r\n    gitHubUsers: SelectedGitHubUserType[]\r\n    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа\r\n    \"selectedGitHubUserDetailsType\" или null, и ничего не возвращает.*/\r\n    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void\r\n    /*Значение, показывающее идет ли сейчас запрос пользователей GitHub или нет, должно быть булева типа.*/\r\n    isRequestingGitHubUsers: boolean\r\n    /*Callback-функция для установки значения, показывающего идет ли сейчас запрос профиля выбранного пользователей\r\n    GitHub или нет, которая принимает параметр булева типа и ничего не возвращает.*/\r\n    setIsRequestingSelectedGitHubUserDetails: (isRequestingSelectedGitHubUserDetails: boolean) => void\r\n};\r\n\r\n/*\"SearchUsersAreaResults\" это функциональный компонент, который создан в виде стрелочной функции.\r\n\"SearchUsersAreaResults\" является компонентом, который используется для вывода списка пользователей GitHub.\r\n\r\nВнутри компонента \"SearchUsersAreaResults\" используются следующие компоненты:\r\n1. \"Preloader\" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,\r\nпока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.\r\n\r\nКомпонент \"SearchUsersAreaResults\" импортируется в файле \"UseEffectTheory.tsx\".*/\r\nexport const SearchUsersAreaResults: React.FC<PropsType> = ({\r\n                                                                gitHubUsers,\r\n                                                                setSelectedGitHubUserDetails,\r\n                                                                isRequestingGitHubUsers,\r\n                                                                setIsRequestingSelectedGitHubUserDetails\r\n                                                            }) => {\r\n    console.log('RENDERING THE SEARCH AREA RESULTS');\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать выбранного пользователя GitHub (изначально никого не\r\n    выбрано), должен быть типа \"SelectedGitHubUserType\" или отсутствовать. Вторая переменная будет хранить функцию из\r\n    хука \"useState()\", которая будет изменять первый элемент (то есть указывать какой пользователь GitHub является\r\n    выбранным).*/\r\n    const [selectedGitHubUser, setSelectedGitHubUser] = useState<SelectedGitHubUserType | null>(null);\r\n\r\n    /*Используем хук \"useEffect()\", чтобы синхронизировать логин выбранного пользователя GitHub и имени вкладки\r\n    страницы.*/\r\n    useEffect(\r\n        /*Первый параметр это функция для изменения имени вкладки страницы.*/\r\n        () => {\r\n            console.log('UPDATING THE TITLE');\r\n            if (selectedGitHubUser) document.title = selectedGitHubUser.login;\r\n        },\r\n        /*Второй параметр это выбранный пользователя GitHub из хука \"useState()\". Если это значение будет меняться, то\r\n        будет срабатывать каждый раз функция из первого параметра.*/\r\n        [selectedGitHubUser]\r\n    );\r\n\r\n    /*Используем хук \"useEffect()\", чтобы при выборе пользователя GitHub вызывать запрос на получение его профиля.*/\r\n    useEffect(\r\n        /*Первый параметр это функция для запроса на получение профиля пользователя GitHub.*/\r\n        () => {\r\n            console.log('REQUESTING THE PROFILE');\r\n\r\n            if (selectedGitHubUser) {\r\n                /*Указываем, что идет запрос профиля выбранного пользователей GitHub, чтобы в компоненте \"UserInfo\"\r\n                отобразить компонент-заглушку \"Preloader\" пока запрос не завершится.*/\r\n                setIsRequestingSelectedGitHubUserDetails(true);\r\n\r\n                axios\r\n                    .get<selectedGitHubUserDetailsType>(`https://api.github.com/users/${selectedGitHubUser.login}`)\r\n                    .then(response => {\r\n                        setSelectedGitHubUserDetails(response.data);\r\n                        /*Указываем, что запрос профиля выбранного пользователей GitHub больше не идет, чтобы в\r\n                        компоненте \"UserInfo\" отключить компонент-заглушку \"Preloader\".*/\r\n                        setIsRequestingSelectedGitHubUserDetails(false);\r\n                    });\r\n            }\r\n        },\r\n        /*Второй параметр это выбранный пользователя GitHub из хука \"useState()\". Если это значение будет меняться, то\r\n        будет срабатывать каждый раз функция из первого параметра.*/\r\n        [selectedGitHubUser]\r\n    );\r\n\r\n    /*Пока идет запрос пользователей GitHub, показываем компонент \"Preloader\".*/\r\n    if (isRequestingGitHubUsers) return <Preloader/>;\r\n\r\n    return (\r\n        <div>\r\n            <ul className={styles.searchUsersAreaResults}>\r\n                {/*Мапим массив с пользователями GitHub, чтобы вывести этих пользователей списком.*/}\r\n                {gitHubUsers\r\n                    .map(u =>\r\n                        <li key={u.id}\r\n                            /*Если какой-то пользователь GitHub в списке совпадает с выбранным нами пользователем\r\n                            GitHub, то применяем к этому элементу списка дополнительный стиль.*/\r\n                            className={selectedGitHubUser === u ? styles.selectedUser : ''}\r\n                            /*При нажатии на элемент списка при помощи функции \"setSelectedGitHubUser()\" из хука\r\n                            \"useState()\" мы указываем выбранного пользователя GitHub.*/\r\n                            onClick={() => { setSelectedGitHubUser(u) }}>\r\n                            {u.login}\r\n                        </li>)}\r\n            </ul>\r\n        </div>\r\n    );\r\n};","import React, {useState, useEffect} from 'react';\r\nimport styles from './Timer.module.css';\r\n/*Импортируем тип \"selectedGitHubUserDetailsType\".*/\r\nimport {selectedGitHubUserDetailsType} from '../../UseEffectTheory';\r\n\r\ntype PropsType = {\r\n    /*Детали профиля выбранного пользователя GitHub должны быть типа \"selectedGitHubUserDetailsType\" или null.*/\r\n    selectedGitHubUserDetails: selectedGitHubUserDetailsType | null\r\n    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа\r\n    \"selectedGitHubUserDetailsType\" или null, и ничего не возвращает.*/\r\n    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void\r\n    /*ID выбранного пользователя GitHub должно быть числом.*/\r\n    timerKey: number\r\n};\r\n\r\n/*\"Timer\" это функциональный компонент, который создан в виде стрелочной функции. \"Timer\" является компонентом, который\r\nиспользуется для отображения таймера для просмотра профиля пользователя GitHub.\r\n\r\nКомпонент \"Timer\" импортируется в файле \"UserInfo.tsx\".*/\r\nexport const Timer: React.FC<PropsType> = ({selectedGitHubUserDetails, setSelectedGitHubUserDetails, timerKey}) => {\r\n    console.log('RENDERING THE TIMER');\r\n    /*Изначальное время таймера.*/\r\n    const initialSecondsToLive = 60;\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать секунды в таймере (изначально берется из переменной\r\n    \"initialSecondsToLive\"). Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый\r\n    элемент (то есть менять секунды в таймере).*/\r\n    const [secondsToLive, setSecondsToLive] = useState(initialSecondsToLive);\r\n\r\n    /*Используем хук \"useEffect()\" для реализации отсчета секунд в таймере.*/\r\n    useEffect(\r\n        () => {\r\n            console.log('INITIALIZING THE TIMER');\r\n            /*Здесь можно было использовать функцию \"setTimeout()\" и указать вторым параметром в этом хуке \"useEffect()\"\r\n            секунды таймера, но мы решили так не делать, чтобы не перезапускать эту функцию \"setTimeout()\" каждую\r\n            секунду.\r\n\r\n            Поэтому мы использовали потом функцию \"setInterval()\" без указания зависимости в хуке \"useEffect()\". Но это\r\n            приводило к тому, что хоть секунды и менялись в хуке \"useState()\", значение для отображения застревало на\r\n            одном и том же месте после отсчета одной секунды.\r\n\r\n            Так происходило из-за замыкания. Изначально таймер фиксировал у себя значение 60 секунд в локальном state.\r\n            Дальше фиксировался хук \"useEffect()\", но не запускался. Потом происходила отрисовка 60 секунд. После этой\r\n            отрисовки запускалась функция \"setInterval()\" из этого хука \"useEffect()\". Эта функция \"setInterval()\"\r\n            обращалась к секундам таймера, которых у нее самой нет, поэтому она пыталась взять их через замыкание у\r\n            родителя - у хука \"useEffect()\", но поскольку и у этого хука не было секунд таймера, то в итоге эти секунду\r\n            брались через замыкание у функции \"Timer()\" (наш функциональный компонент). Брались они из первой отрисовки\r\n            компонента \"Timer\", то есть из первого вызова функции \"Timer()\". После первой отрисовки компонента \"Timer\"\r\n            функция \"setInterval()\" срабатывала и количество секунд становилось 59, то есть менялось значение в\r\n            локальном state, что вызывало еще одну отрисовку компонента \"Timer\", то есть вызов функции \"Timer()\", и\r\n            отрисовывалось уже 59 секунд.\r\n\r\n            Но поскольку не было указано зависимостей в этом хуке \"useEffect()\", то при второй и последующих отрисовках\r\n            компонента \"Timer\" регистрации этого хука \"useEffect()\" уже не происходило, поэтому запуска и\r\n            пересинхронизации функции \"setInterval()\" с новой отрисовкой компонента \"Timer\" тоже не происходило. То есть\r\n            далее когда в локальном state становилось 58 секунд, поскольку больше не происходило регистрации этого хука\r\n            \"useEffect()\" и, соответственно, больше не пересинхронизировалась функция \"setInterval()\" c новыми\r\n            отрисовками компонента \"Timer\", то этой функцией \"setInterval()\" каждый раз бралось значение 60 секунд из\r\n            первой отрисовки компонента \"Timer\", то есть первого вызова функции \"Timer()\". Поэтому мы и видели только 59\r\n            секунд в таймере.\r\n\r\n            Чтобы этого избежать, поскольку наше новое значение секунд таймера зависит от старого значения секунд\r\n            таймера из локального state, то вместо \"() => {setSecondsToLive(secondsToLive - 1)}\" в качестве параметра\r\n            функции \"setInterval()\" мы используем \"() => {setSecondsToLive((prev) => prev - 1)}\", то есть мы используем\r\n            функцию \"(prev) => prev - 1\", которая при помощи React рассчитывает именно актуальное значение секунд\r\n            таймера. То есть использование такого написания функции позволяет нам брать актуальные значения из хука\r\n            \"useState()\".*/\r\n            const intervalID = setInterval(() => {setSecondsToLive((prev) => prev - 1)}, 1000);\r\n            /*Хоть мы в хуке \"useEffect()\" ниже и \"убиваем\" компонент \"UserInfo\", что в итоге скрывает и компонент\r\n            \"Timer\", сам таймер продолжает тикать и меняется значение в локальном state. Чтобы подчистить это нам нужна\r\n            функция зачистки (cleanup-функция). Эта cleanup-функция будет вызываться, когда компонент будет \"умирать\"\r\n            или каждый раз когда будет меняться второй параметр хука \"useEffect()\", чтобы подчистить мусор перед новым\r\n            запуском.\r\n\r\n            Такую функцию нужно поместить в return. В данном случае нам нужно отключить функцию \"setInterval()\", поэтому\r\n            для этого есть специальная функция \"clearInterval()\", в которой нужно указать ID этой функции\r\n            \"setInterval()\", для чего мы ее оборачиваем в отдельную переменную \"intervalID\" выше, в которую функция\r\n            \"setInterval()\" отдает на выходе свой ID. Такие функции зачистки нужны еще, например, для функции\r\n            \"setTimeout()\", для отписки от DOM-библиотек (например, yandex карты или google карты), для отписки от\r\n            событий, для закрытия WebSocket-каналов и так далее.*/\r\n            return () => { clearInterval(intervalID) };\r\n        },\r\n        /*Если это значение будет меняться, то будет срабатывать каждый раз функция из первого параметра. Если вторым\r\n        параметром здесь ничего не указывать, то секундомер будет работать, но при переключении профилей таймер будет\r\n        сбрасываться на изначальное значение, но первая секунда будет длиться короче, так как она будет сливаться с\r\n        последней секундой предыдущего таймера.\r\n\r\n        Чтобы этого избежать мы будем получать некий параметр извне и сделаем его зависимостью в этом хуке\r\n        \"useEffect()\". В данном случае мы будем получать ID пользователя GitHub (можно на самом деле получать любые\r\n        данные профиля пользователя, суть работы не поменяется), которого выбрали. То есть когда мы будем получать такой\r\n        ID, соответственно, когда мы загружаем новый профиль и хотим, чтобы таймер полностью сбросился, этот хук\r\n        \"useEffect()\" будет полностью перезапускать функцию из своего первого параметра при помощи нашей функции\r\n        зачистки, что в итоге поможет нам избежать случаев \"склеивания\" первой секунды нового таймера и последней\r\n        секунды старого таймера.*/\r\n        [timerKey]\r\n    );\r\n\r\n    /*Используем хук \"useEffect()\", чтобы сбрасывать таймер при переключении профилей пользователей GitHub.*/\r\n    useEffect(\r\n        () => {\r\n            console.log('RESETTING THE TIMER');\r\n            /*Используем функцию \"setSecondsToLive()\" из хука \"useState()\", чтобы сбрасывать секунды таймера в\r\n            изначальное состояние.*/\r\n            setSecondsToLive(initialSecondsToLive);\r\n        },\r\n        /*Второй параметр это детали профиля выбранного пользователя GitHub. Если эти детали будут меняться, то будет\r\n        срабатывать каждый раз функция из первого параметра.*/\r\n        [selectedGitHubUserDetails]\r\n    );\r\n\r\n    /*Используем хук \"useEffect()\", чтобы отключать таймер и закрывать профиль пользователя GitHub, когда истекает сам\r\n    таймер.*/\r\n    useEffect(\r\n        () => {\r\n            console.log('TRYING TO TURN THE TIMER OFF');\r\n\r\n            /*Когда время таймера истечет, мы сбрасываем данные профиля пользователя GitHub, тем самым отключая\r\n            компонент \"UserInfo\", в котором также содержится и компонент \"Timer\".*/\r\n            if (secondsToLive < 1) {\r\n                setSelectedGitHubUserDetails(null);\r\n                console.log('TURNING TIMER OFF');\r\n            }\r\n        },\r\n        /*Второй параметр это секунды в таймере. Если это значение будет меняться, то будет срабатывать каждый раз\r\n        функция из первого параметра.*/\r\n        [secondsToLive]\r\n    );\r\n\r\n    return (\r\n        <div className={styles.timerSeconds}>\r\n            {/*Отображаем секунды таймера из хука \"useState()\".*/}\r\n            {secondsToLive}\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\nimport styles from './UserInfo.module.css';\r\n/*Импортируем компонент \"Preloader\".*/\r\nimport {Preloader} from '../../../common/Preloader/Preloader';\r\n/*Импортируем компонент \"Timer\".*/\r\nimport {Timer} from './Timer/Timer';\r\n/*Импортируем тип \"selectedGitHubUserDetailsType\".*/\r\nimport {selectedGitHubUserDetailsType} from '../UseEffectTheory';\r\n\r\ntype PropsType = {\r\n    /*Детали профиля выбранного пользователя GitHub должны быть типа \"selectedGitHubUserDetailsType\" или null.*/\r\n    selectedGitHubUserDetails: selectedGitHubUserDetailsType | null\r\n    /*Callback-функция для установки деталей профиля выбранного пользователя GitHub, которая принимает параметр типа\r\n    \"selectedGitHubUserDetailsType\" или null, и ничего не возвращает.*/\r\n    setSelectedGitHubUserDetails: (selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => void\r\n    /*Значение, показывающее идет ли сейчас запрос профиля выбранного пользователей GitHub или нет, должно быть булева\r\n    типа.*/\r\n    isRequestingSelectedGitHubUserDetails: boolean\r\n};\r\n\r\n/*\"UserInfo\" это функциональный компонент, который создан в виде стрелочной функции. \"UserInfo\" является компонентом,\r\nкоторый используется для вывода деталей профиля выбранного нами пользователя GitHub.\r\n\r\nВнутри компонента \"UserInfo\" используются следующие компоненты:\r\n1. \"Preloader\" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,\r\nпока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.\r\n2. \"Timer\" - компонент, который используется для отображения таймера для просмотра профиля пользователя GitHub.\r\nИмпортирован.\r\n\r\nКомпонент \"UserInfo\" импортируется в файле \"UseEffectTheory.tsx\".*/\r\nexport const UserInfo: React.FC<PropsType> = ({\r\n                                                  selectedGitHubUserDetails,\r\n                                                  setSelectedGitHubUserDetails,\r\n                                                  isRequestingSelectedGitHubUserDetails\r\n                                              }) => {\r\n    console.log('RENDERING THE PROFILE');\r\n    /*Пока идет запрос профиля выбранного пользователей GitHub, мы будем показывать компонент-заглушку \"Preloader\".*/\r\n    if (isRequestingSelectedGitHubUserDetails) return <Preloader/>;\r\n\r\n    return (\r\n        <div className={styles.userInfo}>\r\n            {/*Если есть данные профиля выбранного пользователя GitHub, тогда выводим эти данные.*/}\r\n            {selectedGitHubUserDetails && <div>\r\n                {/*Отрисовываем компонент \"Timer\" и передаем в него детали профиля выбранного пользователя GitHub\r\n                \"selectedGitHubUserDetails\", callback-функцию \"setSelectedGitHubUserDetails()\" для установки деталей\r\n                профиля выбранного пользователя GitHub, и \"timerKey\" - ID выбранного пользователя GitHub.*/}\r\n                <Timer\r\n                    selectedGitHubUserDetails={selectedGitHubUserDetails}\r\n\r\n                    setSelectedGitHubUserDetails={(selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => {\r\n                        setSelectedGitHubUserDetails(selectedGitHubUserDetails);\r\n                    }}\r\n\r\n                    timerKey={selectedGitHubUserDetails.id}\r\n                />\r\n\r\n                GitHub profile: {selectedGitHubUserDetails.login}\r\n                <br/>\r\n                ID: {selectedGitHubUserDetails.id}\r\n                <br/>\r\n                Followers: {selectedGitHubUserDetails.followers}\r\n                <br/>\r\n                <img src={selectedGitHubUserDetails.avatar_url} alt={'avatar'}/>\r\n            </div>}\r\n        </div>\r\n    );\r\n};","import React, {useState} from 'react';\r\nimport styles from './UseEffectTheory.module.css';\r\n/*Импортируем компонент \"SearchUsersArea\".*/\r\nimport {SearchUsersArea} from './SearchUsersArea/SearchUsersArea';\r\n/*Импортируем компонент \"SearchUsersAreaResults\".*/\r\nimport {SearchUsersAreaResults} from './SearchUsersAreaResults/SearchUsersAreaResults';\r\n/*Импортируем компонент \"UserInfo\".*/\r\nimport {UserInfo} from './UserInfo/UserInfo';\r\n\r\ntype PropsType = {};\r\n\r\n/*Создаем тип для выбранного пользователя GitHub.*/\r\nexport type SelectedGitHubUserType = {\r\n    /*Логин пользователя GitHub должен быть строкой.*/\r\n    login: string\r\n    /*ID пользователя GitHub должно быть числом.*/\r\n    id: number\r\n};\r\n\r\n/*Создаем тип для данных, которые будем получать в ответ на запрос пользователей GitHub.*/\r\nexport type GitHubSearchResult = {\r\n    /*Массив с пользователями GitHub должен быть массивом с элементами типа \"SelectedGitHubUserType\".*/\r\n    items: SelectedGitHubUserType[]\r\n};\r\n\r\n/*Создаем тип для данных, которые будем получать в ответ на запрос деталей профиля выбранного пользователя GitHub.*/\r\nexport type selectedGitHubUserDetailsType = {\r\n    /*Логин пользователя GitHub должен быть строкой.*/\r\n    login: string\r\n    /*ID пользователя GitHub должно быть числом.*/\r\n    id: number\r\n    /*Ссылка на аватар пользователя GitHub должна быть строкой.*/\r\n    avatar_url: string\r\n    /*Количество подписчиков пользователя GitHub должно быть числом.*/\r\n    followers: number\r\n};\r\n\r\n/*\"UseEffectTheory\" это функциональный компонент, который создан в виде стрелочной функции. \"UseEffectTheory\" является\r\nкомпонентом, который используется для рассмотрения работы хука \"useEffect()\" из React. Здесь мы делаем форму для запроса\r\nинформации по пользователям GitHub, используя API GitHub.\r\n\r\nВнутри компонента \"UseEffectTheory\" используются следующие компоненты:\r\n1. \"SearchUsersArea\" - компонент, используемый для создания поля для ввода текста, по которому будет осуществляться\r\nпоиск пользователя GitHub. Импортирован.\r\n2. \"SearchUsersAreaResults\" - компонент, который используется для вывода списка пользователей GitHub. Импортирован.\r\n3. \"UserInfo\" - компонент, который используется для вывода деталей профиля выбранного нами пользователя GitHub.\r\nИмпортирован.\r\n\r\nКомпонент \"UseEffectTheory\" импортируется в файле \"App.tsx\".*/\r\nexport const UseEffectTheory: React.FC<PropsType> = (props) => {\r\n    console.log('RENDERING THE WHOLE PAGE');\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать массив с пользователями GitHub (изначально пустой), должен\r\n    быть типа массива элементов с типом \"SelectedGitHubUserType\". Вторая переменная будет хранить функцию из хука\r\n    \"useState()\", которая будет изменять первый элемент (то есть указывать массив с пользователями GitHub).*/\r\n    const [gitHubUsers, setGitHubUsers] = useState<SelectedGitHubUserType[]>([]);\r\n\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать детали профиля выбранного пользователя GitHub (изначально\r\n    отсутствуют), должен быть типа \"selectedGitHubUserDetailsType\" или отсутствовать. Вторая переменная будет хранить\r\n    функцию из хука \"useState()\", которая будет изменять первый элемент (то есть указывать детали профиля выбранного\r\n    пользователя GitHub).*/\r\n    const [selectedGitHubUserDetails, setSelectedGitHubUserDetails] =\r\n        useState<selectedGitHubUserDetailsType | null>(null);\r\n\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать идет ли запрос пользователей GitHub (изначально false),\r\n    должен быть булева типа. Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый\r\n    элемент (то есть указывать идет ли запрос пользователей GitHub).*/\r\n    const [isRequestingGitHubUsers, setIsRequestingGitHubUsers] = useState<boolean>(false);\r\n\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать идет ли запрос профиля выбранного пользователей GitHub\r\n    (изначально false), должен быть булева типа. Вторая переменная будет хранить функцию из хука \"useState()\", которая\r\n    будет изменять первый элемент (то есть указывать идет ли запрос профиля выбранного пользователей GitHub).*/\r\n    const [isRequestingSelectedGitHubUserDetails, setIsRequestingSelectedGitHubUserDetails] =\r\n        useState<boolean>(false);\r\n\r\n    return (\r\n        <div className={styles.wholeGitHubSearch}>\r\n            <div className={styles.userList}>\r\n                {/*Отрисовываем компонент \"SearchUsersArea\" и передаем в него:\r\n                1. callback-функцию \"setGitHubUsers()\" для установки массива с пользователями GitHub.\r\n                2. callback-функцию \"setSelectedGitHubUserDetails()\" для установки деталей профиля выбранного\r\n                пользователя GitHub.\r\n                3. детали профиля выбранного пользователя GitHub \"selectedGitHubUserDetails\".\r\n                4. callback-функцию \"setIsRequestingGitHubUsers()\" для установки значения, показывающего идет ли сейчас\r\n                запрос пользователей GitHub или нет.*/}\r\n                <SearchUsersArea\r\n                    setGitHubUsers={(gitHubUsers: SelectedGitHubUserType[]) => { setGitHubUsers(gitHubUsers) }}\r\n\r\n                    setSelectedGitHubUserDetails={(selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => {\r\n                        setSelectedGitHubUserDetails(selectedGitHubUserDetails);\r\n                    }}\r\n\r\n                    selectedGitHubUserDetails={selectedGitHubUserDetails}\r\n\r\n                    setIsRequestingGitHubUsers={(isRequestingGitHubUsers: boolean) => {\r\n                        setIsRequestingGitHubUsers(isRequestingGitHubUsers);\r\n                    }}\r\n                />\r\n\r\n                {/*Отрисовываем компонент \"SearchUsersAreaResults\" и передаем в него:\r\n                1. массив с пользователями GitHub \"gitHubUsers\".\r\n                2. callback-функцию \"setSelectedGitHubUserDetails()\" для установки деталей профиля выбранного\r\n                пользователя GitHub.\r\n                3. значение \"isRequestingGitHubUsers\", показывающее идет ли сейчас запрос пользователей GitHub или нет.\r\n                4. callback-функцию \"setIsRequestingSelectedGitHubUserDetails()\" для установки значения, показывающего\r\n                идет ли сейчас запрос профиля выбранного пользователей GitHub или нет.*/}\r\n                <SearchUsersAreaResults\r\n                    gitHubUsers={gitHubUsers}\r\n\r\n                    setSelectedGitHubUserDetails={(selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => {\r\n                        setSelectedGitHubUserDetails(selectedGitHubUserDetails);\r\n                    }}\r\n\r\n                    isRequestingGitHubUsers={isRequestingGitHubUsers}\r\n\r\n                    setIsRequestingSelectedGitHubUserDetails={(isRequestingSelectedGitHubUserDetails: boolean) => {\r\n                        setIsRequestingSelectedGitHubUserDetails(isRequestingSelectedGitHubUserDetails);\r\n                    }}\r\n                />\r\n            </div>\r\n\r\n            {/*Отрисовываем компонент \"UserInfo\" и передаем в него:\r\n            1. детали профиля выбранного пользователя GitHub \"selectedGitHubUserDetails\".\r\n            2. callback-функцию \"setSelectedGitHubUserDetails()\" для установки деталей профиля выбранного пользователя\r\n            GitHub.\r\n            3. значение \"isRequestingSelectedGitHubUserDetails\", показывающее идет ли сейчас запрос профиля выбранного\r\n            пользователя GitHub или нет.*/}\r\n            <UserInfo\r\n                selectedGitHubUserDetails={selectedGitHubUserDetails}\r\n\r\n                setSelectedGitHubUserDetails={(selectedGitHubUserDetails: selectedGitHubUserDetailsType | null) => {\r\n                    setSelectedGitHubUserDetails(selectedGitHubUserDetails);\r\n                }}\r\n\r\n                isRequestingSelectedGitHubUserDetails={isRequestingSelectedGitHubUserDetails}\r\n            />\r\n        </div>\r\n    );\r\n};","/*При отрисовке приложения в браузере файлы проекта собираются в отдельные группы файлов - бандлы (bundles). При помощи\r\nих HTTP быстрее загружает приложение. Можно сделать так, чтобы подгружалось только то, что необходимо для отображения,\r\nа не все бандлы сразу. Все остальное будет загружаться по необходимости. Это называется lazy loading. В зависимости от\r\nцелей можно использовать lazy loading или загружать большее количество бандлов. Бандлы собираются путем пробега WebPack\r\nпо импортам в проекте. Компоненты в lazy loading нужно оборачивать в компонент \"Suspense\" из React. Для этого\r\nоборачивания мы создаем этот HOC \"WithSuspense()\". Далее мы используем этот HOC в файле \"App.tsx\" для компонентов\r\n\"ProfileContainer\" и \"ChatPage\".\r\n\r\nИмпортируем компонент \"Suspense\" для реализации lazy loading. Импортируем тип \"ComponentType\" для типизации.*/\r\nimport React, {Suspense, ComponentType} from 'react';\r\n/*Импортируем компонент \"Preloader\".*/\r\nimport {Preloader} from '../components/common/Preloader/Preloader';\r\n\r\n/*HOC \"withSuspense()\" - это HOC, который реализует lazy loading в нашем приложении.\r\n\r\nЭтот HOC, в качестве параметра принимает какой-либо компонент \"Component\". Не используем здесь синтаксис стрелочной\r\nфункции, чтобы можно было уточнить props как \"WrappedProps\", как мы это сделали здесь. Этот HOC принимает какой-то\r\ngeneric компонент \"Component\", который ожидает props c типом \"WrappedProps\".\r\n\r\nКомпонент \"Component\" должен быть типа \"ComponentType\", то есть быть каким-то компонентом из React.\r\n\r\nУточняем, что внутри ожидаются props c типом \"WrappedProps\", то есть те же props компонента \"Component\", который мы\r\nбудем передавать в этот HOC, так как наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\".\r\n\r\nHOC \"withSuspense()\" импортируется в файле \"App.tsx\".*/\r\nexport function withSuspense<WrappedProps>(Component: ComponentType<WrappedProps>) {\r\n    /*Наш HOC возвращает другой компонент, props которого являются тоже типа \"WrappedProps\", так как опять же наш HOC не\r\n    будет снабжать новыми данными переданный в него компонент \"Component\".*/\r\n    return (props: WrappedProps) => {\r\n        /*Этот HOC оборачивает полученный компонент \"Component\" в компонент \"Suspense\" для реализации lazy loading.\r\n        Также в этот компонент \"Component\" передаются все его изначальные props.*/\r\n        return (\r\n            /*Пока будет идти загрузка компонента будет показываться компонент-заглушка \"Preloader\".*/\r\n            <Suspense fallback={<Preloader/>}>\r\n                <Component {...props}/>\r\n            </Suspense>\r\n        )\r\n    };\r\n};","/*Импортируем компонент \"Suspense\" для реализации lazy loading, больше об этом в файле \"WithSuspense.tsx\". Также\nимпортируем тип \"ComponentType\" для типизации.*/\nimport React, {Suspense, ComponentType} from 'react';\n/*Библиотека React Router DOM необходима для создания роутинга и маршрутов в приложении.\n\nИмпортируем компонент \"Route\" для создания маршрутов. В каждом компоненте \"Route\" указывается путь в атрибуте \"path\",\nкоторый будет прослушиваться. Также в каждом компоненте \"Route\" указывается в атрибуте \"render\" компонент, который\nотрисовывается если активируется какой-то прослушиваемый путь. Чтобы маршруты компонентов \"Route\" работали их нужно всех\nобернуть в корневой компонент \"BrowserRouter\".\n\nДля перемещения по маршрутам в компонентах \"Route\" может использоваться компонент \"NavLink\". Хотя в этом компоненте мы\nего не используем, но используем в некоторых других.\n\nФункция \"withRouter()\" это HOC. HOC - это High Order Component (компонент высшего порядка). HOC - это функция, которая\nпринимает на входе один компонент, оборачивает его, чтобы передать компоненту какие-то данные, и на выходе возвращает\nдругой компонент. HOC позволяет создавать однообразные контейнерные компоненты.\n\nПоскольку URL также является источником данных, то компоненту иногда могут понадобиться эти данные. Чтобы их получить,\nможно воспользоваться HOC \"withRouter()\". HOC \"withRouter()\" принимает в качестве параметра компонент и передает ему\nчерез props данные из URL, чтобы компонент знал где он находиться, то есть знал какой у него маршрут. Если подключить на\nсамом высоком уровне дерева компонентов этот HOC, например, в файле \"App.tsx\", то данные URL будут доступны в дочерних\nкомпонентах.\n\nПри использовании функции \"connect()\" роутинг сбивается. Чтобы решить эту проблемы мы оборачиваем функцию \"connect()\"\nпри помощи HOC \"withRouter()\". Но сейчас вроде и без этого все работает.\n\nКомпонент \"Redirect\" позволяет осуществлять редирект. Для указания пути редиректа используется атрибут \"to\". Маршрут для\nпути редиректа уже должен быть создан.\n\nКомпонент \"Switch\" - это аналог для реализации атрибута \"exact\" (смотри в коде ниже). Работает по принципу\n\"switch/case\", то есть как только нашли компонент \"Route\" с подходящим путем, то его сразу и отрисовываем.\n\nКомпонент \"HashRouter\" используем только для сборки билда приложения для его последующего развертывания на GitHub.*/\nimport {Route, BrowserRouter, HashRouter, withRouter, Redirect, Switch} from 'react-router-dom';\n/*Библиотека React Redux является прослойкой между UI (React) и BLL (Redux). Эта прослойка необходима потому, что UI\nнежелательно общаться с BLL напрямую. Библиотека React Redux предоставляет продвинутые инструкции по созданию\nконтейнерных компонентов и контекста.\n\nФункция \"connect()\" это HOC. Точнее она возвращает HOC, а этот HOC получает компонент и обрабатывает его. Функция\n\"connect()\" используется для создания компонентов и контейнеров. Функция \"connect()\" знает о нашем store из Redux и сама\nпередает данные оттуда в указанный компонент. Функция \"connect()\" упрощает перекидывание props. Функция \"connect()\"\nимеет улучшенную оптимизацию перерисовки, так как она перерисовывает только нужную часть Virtual DOM. При помощи функции\n\"connect()\" можно удобно создавать контейнерные компоненты.\n\nУ функции \"connect()\" есть свои аналоги функций \"getState()\", \"subscribe()\", \"callSubscriber()\" и \"dispatch()\".\n\nФункция \"connect()\" вызывается дважды. Первый раз она вызывается с параметрами в виде двух функций, которые она вызовет:\n1. Данные state, в виде функции \"mapStateToProps()\".\n2. Функция \"dispatch()\", в виде наших callback-функций - AC, TC и функция \"mapDispatchToProps().\nПричем функция \"connect()\" в первую функцию закинет весь state из store, а во вторую функцию закинет\n\"store.dispatch.bind(store)\", то есть наши callback-функции. Затем функция \"connect()\" вернет другую функцию, тот самый\nHOC, после чего вызовется этот HOC с параметрами в виде какого-то указанного компонента.\n\nПри каждом изменении state вызывается функция \"mapStateToProps()\", формируется новый объект с данными из state и\nсравнивается со старым объектом с данными из state (их внутренностями). Если были изменения в нужной для компонента\nчасти state, которая указана в функции \"mapStateToProps()\", то функция \"connect()\" перерисовывает компонент. Именно\nпоэтому в редьюсерах мы создаем копии state. Если создается копия state, то получается, что создается ссылка на другой\nобъект. Исходя из этого функция \"connect()\" считает, что произошли изменения.\n\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например, AC\nили TC в контейнерном компоненте это ссылки на AC или TC из редьюсеров. Учитывая это, в функции \"connect()\" можно сразу\nуказывать AC или TC, так как функция \"connect()\" создает контейнерный классовый компонент и сама может создавать\ncallback-функции вокруг AC или TC, как это делается в функции \"mapDispatchToProps()\". И тогда можно не писать функцию\n\"mapDispatchToProps()\".\n\nКомпонент \"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\nBLL и DAL. Компонент \"Provider\" позволяет указать компонент, в нашем случае это компонент \"AppContainer\", который будет\nпоставщиком данных BLL и DAL для всех его дочерних компонентов. Так же использование компонента \"Provider\" избавляет нас\nот обязанности прокидывать указанные данные через все дерево компонентов.*/\nimport {connect, Provider} from 'react-redux';\n/*Функция \"compose()\" из функционального программирования. Эта функция создает композицию обработчиков. Библиотека\nRedux содержит свою реализацию функции \"compose()\". При помощи функции \"compose()\" можно объединять, например, несколько\nоберток вокруг компонента и HOC-ов. Обертки и HOCs указываются снизу вверх. Функция \"compose()\" вызывается дважды и\nработает схожим образом, как и функция \"connect()\" из библиотеки React Redux.*/\nimport {compose} from 'redux';\n/*Импортируем наш store из Redux. Также Импортируем тип \"AppStateType\" оттуда.*/\nimport store, {AppStateType} from './redux/redux-store';\n/*Импортируем TC \"initializeApp()\".*/\nimport {initializeApp} from './redux/app-reducer';\n/*Импортируем CSS-стили из UI-фреймворка Ant Design.*/\nimport 'antd/dist/antd.css';\n/*Импортируем из UI-фреймворка Ant Design компонент \"Layout\" для получения из него объектов компонентов \"Content\" и\n\"Footer\", чтобы использовать их как теги для реализации основного содержания страницы и футера.*/\nimport {Layout} from 'antd';\n/*Импортируем файл CSS.*/\nimport './App.css';\n/*Импортируем компонент \"Preloader\".*/\nimport {Preloader} from './components/common/Preloader/Preloader';\n/*Импортируем компонент \"Header\".*/\nimport {Header} from './components/Header/Header';\n/*Импортируем компонент \"Navbar\".*/\nimport {Navbar} from './components/Navbar/Navbar';\n/*Импортируем компонент \"Users\".*/\nimport {Users} from './components/Users/Users';\n/*Импортируем компонент \"Music\".*/\nimport {Music} from './components/Music/Music';\n/*Импортируем компонент \"News\".*/\nimport {News} from './components/News/News';\n/*Импортируем компонент \"Settings\".*/\nimport {Settings} from './components/Settings/Settings';\n/*Импортируем компонент \"Friends\".*/\nimport {Friends} from './components/Friends/Friends';\n/*Импортируем компонент \"Login\".*/\nimport {Login} from './components/Login/Login';\n/*Импортируем компонент \"UseStateTheory\".*/\nimport {UseStateTheory} from './components/theory/UseStateTheory/UseStateTheory';\n/*Импортируем компонент \"UseStateTheory\".*/\nimport {UseEffectTheory} from './components/theory/UseEffectTheory/UseEffectTheory';\n/*Импортируем компонент \"UseStateTheory1\".*/\nimport {UseEffectTheory1} from './components/theory/UseEffectTheory/UseEffectTheory1';\n/*Импортируем HOC \"withSuspense()\" с целью реализации lazy loading для компонентов \"ProfileContainer\" и \"ChatPage\".*/\nimport {withSuspense} from './hoc/WithSuspense';\n/*Здесь вместо стандартного импорта компонентов \"DialogContainer\", \"ProfileContainer\" и \"ChatPage\" в целях реализации\nlazy loading, то есть чтобы они не попали в бандлы, мы используем функцию \"React.lazy()\". Ниже в роутах мы оборачиваем\nэти компоненты в компонент \"Suspense\" или в наш HOC \"withSuspense()\" для реализации lazy loading. Также здесь нужно\nпомнить, что надо делать экспорт компонентов по DEFAULT при использовании функции \"React.lazy()\", иначе придется писать\nдополнительный код.*/\nconst DialogsContainer = React.lazy(() => import('./components/Dialogs/DialogsContainer'));\nconst ProfileContainer = React.lazy(() => import('./components/Profile/ProfileContainer'));\nconst ChatPage = React.lazy(() => import('./pages/ChatPage/ChatPage'));\n\n/*Создаем тип для функции \"MapStateToProps()\". Любой тип указывает, какие поля и какого-то типа должна содержать\nкакая-то сущность или какого типа она сама должны быть.*/\ntype MapStateToPropsType = {\n    /*Свойство, которое показывает инициализировано ли приложение, должно быть булева типа.*/\n    initialized: boolean\n};\n\n/*Создаем тип для функции \"MapDispatchToPropsType()\".*/\ntype MapDispatchToPropsType = {\n    /*TC для инициализации приложения должен быть функцией, которая ничего не принимает и ничего не возвращает.*/\n    initializeApp: () => void\n};\n\n/*Создаем отдельный тип для объекта \"location\" из HOC \"withRouter()\" из библиотеки React Router DOM. Эти данные мы\nпередаем в компонент \"Navbar\" ниже.*/\ntype PathnameType = {\n    location: {\n        pathname: string\n    }\n};\n\n/*Создаем общий тип для всех props путем комбинации трех созданных выше типов. Все это нужно для указания типа props в\nклассовом компоненте \"App\".*/\ntype PropsType = MapStateToPropsType & MapDispatchToPropsType & PathnameType;\n\n/*Оборачиваем вызов HOC \"withSuspense(ProfileContainer)\" в отдельную переменную \"ProfileContainerWithSuspense\", чтобы\nэто можно было использовать как тег ниже в маршруте \"/profile/:userID?\". Мы это делаем после типизации HOC\n\"withSuspense()\", нам из-за этого пришлось добавить в этот маршрут \"() => \", поскольку HOC \"withSuspense()\" возвращает\nновый компонент, но не отрисовывает его. Поэтому для отрисовки нам теперь там нужен тег (в маршруте \"/dialogs/\" мы уже\nиспользовали тег так-то).*/\nconst ProfileContainerWithSuspense = withSuspense(ProfileContainer);\n/*Оборачиваем вызов HOC \"withSuspense(ChatPage)\" в отдельную переменную \"ChatPageWithSuspense\", чтобы это можно было\nиспользовать как тег ниже в маршруте \"/chat/\". Мы это делаем после типизации HOC \"withSuspense()\", нам из-за этого\nпришлось добавить в этот маршрут \"() => \", поскольку HOC \"withSuspense()\" возвращает новый компонент, но не отрисовывает\nего. Поэтому для отрисовки нам теперь там нужен тег (в маршруте \"/dialogs/\" мы уже использовали тег так-то).*/\nconst ChatPageWithSuspense = withSuspense(ChatPage);\n\n/*\"App\" это классовый компонент, который создан в виде класса. \"App\" является главным корневым компонентом, к которому в\nдереве компонентов подключаются остальные компоненты древовидным способом.\n\nВнутри компонента \"App\" используются следующие компоненты:\n1. \"Preloader\" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,\nпока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.\n2. \"Header\" - компонент, который отрисовывает хэдер нашего сайта, содержащий логотип сайта и отдельный блок,\nотображающий ссылку на форму логина или имя залогиненного пользователя с кнопкой логаута. Импортирован.\n3. \"Navbar\" - компонент, который отрисовывает меню навигации нашего сайта. Импортирован.\n4. \"Users\" - компонент, который отображает страницу с постраничным выводом пользователей. Импортирован.\n5. \"Music\" - компонент, который отображает музыку пользователя. Импортирован.\n6. \"News\" - компонент, который отображает новости пользователя. Импортирован.\n7. \"Settings\" - компонент, который отображает настройки сайта. Импортирован.\n8. \"Friends\" - компонент, который отображает друзей пользователя. Импортирован.\n9. \"Login\" - компонент, который представляет собой финальную страницу с формой логинизации. Импортирован.\n10. \"DialogsContainer\" - контейнерный компонент для компонента \"Dialogs\". Импортирован.\n11. \"ProfileContainer\" - контейнерный компонент для компонента \"Profile\". Импортирован.\n12. \"ChatPage\" - компонент, который собирает компоненты для реализации чата в нашем приложении. Импортирован.\n13. \"UseStateTheory\" - компонент, который используется для рассмотрения работы хука \"useState()\" из React. Импортирован.\n14. \"UseEffectTheory\" - компонент, который используется для рассмотрения работы хука \"useEffect()\" из React. Аналог\nкомпонента \"UseEffectTheory1\". Импортирован.\n15. \"UseEffectTheory1\" - компонент, который используется для рассмотрения работы хука \"useEffect()\" из React.Аналог\nкомпонента \"UseEffectTheory\". Импортирован.\n\nЭтот компонент оборачивается в этом же файле компонентом \"AppContainer\", который в свою очередь оборачивается\nкомпонентом \"AppMain\". Последний экспортируется по default для импортирования в файле \"index.js\".\n\nКлассы нужны для того, чтобы создавать однотипные объекты на основе этих классов, благодаря чему можно реализовывать\nконцепции ООП. React определяет классовый компонент и на его основе создает экземпляр класса, и далее уже\nвзаимодействует с этим экземпляром класса (использует его свойства и методы). Этот объект хранится постоянно в памяти и\nReact с ним постоянно взаимодействует. Например, у него можно постоянно запрашивать JSX. При переходе по разным\nмаршрутам компонентов \"Route\" экземпляры классовых компонентов удаляются из памяти.\n\nКлассовые компоненты могут содержать side effects. Для этого используются методы жизненного цикла.\n\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи ключевого слова\n\"extends\".\n\nКаждый компонент это новый тег в React, и эти теги используются для вызова этих компонентов. Теги компонентов можно\nвкладывать друг в друга, тем самым образуя дерево компонентов. Каждый компонент желательно помещать в отдельный файл.\nКаждый компонент всегда вызывается с объектом, внутри которого есть какие-то параметры. Если параметры не указаны, то им\nвсе равно передается пустой объект в качестве параметров. Принято такой объект с параметрами именовать как \"props\".\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\n\nКомпонент это функция, которая возвращает JSX. JSX совмещает в себе JS и HTML. В JSX для указания класса в стилях нужно\nиспользовать \"className\" вместо \"class\". В JSX скобки {} позволяют использовать JS-код внутри HTML-кода. У классового\nкомпонента всегда есть метод \"render()\", который возвращает JSX.\n\nУказываем, что props в этом классовом компоненте имеют тип \"PropsType\". Еще здесь можно указать тип state, но мы не\nделаем этого.*/\nclass App extends React.Component<PropsType/*, StateType*/> {\n    /*Далее идет код, который отлавливает отклоненные промисы. \"promiseRejectionEvent\" - это перехватчик событий.\n    Желательно вместо функции \"alert()\" сделать красивый вывод ошибки.\n\n    Внизу в методе жизненного цикла классового компонента \"componentDidMount()\" совместно с методом жизненного цикла\n    классового компонента \"componentWillUnmount()\" есть еще одна реализация перехвата отклоненных промисов. В данный\n    момент мы не используем ни один из этих способов, так как используем для перехвата ошибок конструкцию try/catch в\n    TC \"updateUserStatus()\" в файле \"profile-reducer.ts\", что будет мешать работать прослушиванию событий (хотя возможно\n    первый способ будет работать).*/\n    // catchAllUnhandledErrors = (promiseRejectionEvent: promiseRejectionEvent) => { alert('some error occurred') };\n\n    /*\"componentDidMount()\" - это метод жизненного цикла классового компонента. Он вызывается в момент первой отрисовки\n    (монтирования) компонента.*/\n    componentDidMount() {\n        /*При монтировании компонента вызывается TC \"initializeApp()\" для инициализации приложения. Поскольку это\n        происходит в компоненте \"App\", который является точкой входа (то есть мы всегда видим его), то это будет\n        работать и во всем приложении.*/\n        this.props.initializeApp();\n\n        /*Еще одна реализация перехвата отклоненных промисов, продолжение ниже в методе жизненного цикла классового\n        компонента \"componentWillUnmount()\". Вызов метода \"window.addEventListener()\" - это side effects, где мы\n        подписываемся на прослушивание событий типа \"unhandledrejection\". Когда происходит такое событие, то вызывается\n        метод \"this.catchAllUnhandledErrors()\".*/\n        /*window.addEventListener(\"unhandledrejection\", this.catchAllUnhandledErrors);*/\n    };\n\n    /*\"componentWillUnmount()\" - это метод жизненного цикла классового компонента. Он вызывается в момент, когда\n    компонент перестает быть отрисованным. Здесь при демонтировании компонента мы отписываемся от прослушивания событий,\n    указанного в методе жизненного цикла классового компонента \"componentDidMount()\".*/\n\n    // componentWillUnmount() { window.removeEventListener(\"unhandledrejection\", this.catchAllUnhandledErrors) };\n\n    render() {\n        /*Пока мы не убедимся, что приложение инициализировано, будем показывать компонент \"Preloader\", тем самым\n        избегая мигания сайта из-за редиректов.*/\n        if (!this.props.initialized) return <Preloader/>;\n        /*При помощи деструктуризации берем компоненты \"Content\" и \"Footer\" из компонента \"Layout\" из UI-фреймворка Ant\n        Design, чтобы использовать их как теги внутри для реализации основного содержания страницы и футера.*/\n        const {Content, Footer} = Layout;\n\n        /*Здесь после return в компоненте начинается JSX. Нужно помнить, что в этом JSX должен быть только один корневой\n        элемент. Все возвращаемое помещено в круглые скобки, так как то, что возвращается return указано с новой\n        строки.*/\n        return (\n            /*Этот компонент \"Layout\" и есть наш корневой элемент. Компонент \"Layout\" - это макет, то есть это самая\n            внешняя структура проекта, обычно состоящая из навигации, футера, сайдбара, уведомлений и содержания.*/\n            <Layout>\n                {/*Отрисовываем компонент \"Header\", указывая его тег в JSX.*/}\n                <Header/>\n\n                {/*Компонент \"Content\" - это элемент для включения в него содержания страницы. В данном случае мы\n                включаем все содержимое страницы в этот элемент.*/}\n                <Content className='main-content'>\n                    <Layout>\n                        {/*Отрисовываем компонент \"Navbar\". Передаем в этот компонент информацию о пути, на котором\n                        сейчас находимся.*/}\n                        <Navbar location={this.props.location}/>\n\n                        {/*Этот компонент \"Content\" содержит основной контент нашего приложения.*/}\n                        <Content className='actual-content'>\n                            <Switch>\n                                {/*Создаем маршрут для пути '/'. Атрибут \"exact\" говорит о том, что путь должен\n                                совпадать точь-в-точь, то есть если, например, будет какой-то подпуть, то такой путь не\n                                подойдет.\n\n                                Атрибут \"render\" содержит анонимную функцию из библиотеки React Router Dom, которую\n                                вызовет компонент \"Route\" при совпадении пути. Эта функция позволяет передавать\n                                параметры. В данном случае произойдет редирект на путь '/profile'.*/}\n                                <Route exact path='/' render={() => <Redirect to='/profile'/>}/>\n\n                                {/*Это еще одна версия вышеуказанного компонента \"Route\" при помощи компонента\n                                \"Redirect\". Оба варианта рабочие, если они обернуты в компонент <Switch>.*/}\n                                {/*<Route exact path='/'>*/}\n                                {/*    <Redirect to='/profile'/>*/}\n                                {/*</Route>*/}\n\n                                {/*Создаем маршрут для пути '/dialogs/'.*/}\n                                <Route path='/dialogs/'\n                                       render={() => <Suspense fallback={<Preloader/>}><DialogsContainer/></Suspense>}/>\n                                {/*Здесь мы используем компонент \"Suspense\", чтобы реализовать lazy loading без нашего\n                                HOC \"withSuspense()\". Также здесь указываем, что пока будет идти загрузка компонента\n                                будет показываться компонент-заглушка \"Preloader\".*/}\n\n                                {/*Создаем маршрут для пути '/profile/:userID?'. \":userID\" означает, что у пути может\n                                быть какое-то дополнение по типу ID пользователя, что не является параметром запроса.\n                                \"?\" в конце означает, что это дополнение является опциональным, если это не указать, то\n                                просто переход в \"/profile\" не отрисует компонент.\n\n                                Здесь мы используем компонент c HOC-ом \"withSuspense()\" для реализации lazy loading.*/}\n                                <Route path='/profile/:userID?' render={() => <ProfileContainerWithSuspense/>}/>\n\n                                {/*Далее представлен еще один способ реализации lazy loading для компонентов\n                                \"DialogsContainer\" и \"ProfileContainer\" без использования нашего HOC \"withSuspense().\n                                Здесь мы сразу несколько компонентов \"Route\" оборачиваем в компонент \"Suspense\". В\n                                данный момент этот вариант не используется в нашем приложении.*/}\n                                {/*<Suspense fallback={<Preloader/>}>*/}\n                                {/*    <Route path='/dialogs/'*/}\n                                {/*        render={() => <DialogsContainer/>}/>*/}\n                                {/*    <Route path='/profile/:userID?'*/}\n                                {/*        render={() => <ProfileContainer/>}/>*/}\n                                {/*</Suspense>*/}\n\n                                {/*Создаем маршрут для пути '/users/'.*/}\n                                <Route path='/users/' render={() => <Users/>}/>\n\n                                {/*Создаем маршрут для пути '/news/'.*/}\n                                <Route path='/news/' render={() => <News/>}/>\n\n                                {/*Создаем маршрут для пути '/music/'.*/}\n                                <Route path='/music/' render={() => <Music/>}/>\n\n                                {/*Создаем маршрут для пути '/settings/'.*/}\n                                <Route path='/settings/' render={() => <Settings/>}/>\n\n                                {/*Создаем маршрут для пути '/friends/'.*/}\n                                <Route path='/friends/' render={() => <Friends/>}/>\n\n                                {/*Создаем маршрут для пути '/login/'. Если нужно, чтобы в компонент \"Login\" можно было\n                                попасть только по одному адресу, то нужно использовать атрибуты \"exact path='/login/'\".\n                                Тогда, например, если перейти по пути '/login/facebook', то мы не попадем в этот\n                                компонент. Аналогичный результат можно получить, если обернуть все компоненты \"Route\" в\n                                компонент \"Switch\".*/}\n                                <Route path='/login/' render={() => <Login/>}/>\n\n                                {/*Создаем маршрут для пути '/usestatetheory/'.*/}\n                                <Route path='/usestatetheory/' render={() => <UseStateTheory/>}/>\n\n                                {/*Создаем маршрут для пути '/usestatetheory/'.*/}\n                                <Route path='/useeffecttheory/' render={() => <UseEffectTheory/>}/>\n\n                                {/*Создаем маршрут для пути '/chat/'.*/}\n                                <Route path='/chat/' render={() => <ChatPageWithSuspense/>}/>\n\n                                {/*Создаем маршрут для пути '*'. Этот путь обозначает неверный URL, то есть любой путь\n                                отличающийся от путей указанных нами в маршрутах. Нужно для отображения \"404\" в таких\n                                случаях. Чтобы это работало нужно обернуть все компоненты \"Route\" в компонент\n                                \"Switch\".*/}\n                                <Route path='*' render={() => <div>404 NOT FOUND</div>}/>\n                            </Switch>\n                        </Content>\n                    </Layout>\n                </Content>\n\n                {/*Отрисовываем футер при помощи элемента \"Footer\".*/}\n                <Footer className='main-footer'>It's 2021 and there is a footer here</Footer>\n            </Layout>\n        );\n    }\n};\n\n/*При помощи функции \"mapStateToProps()\" указываются данные из state, которые необходимо передать в компонент \"App\". Эта\nфункция возвращает указанные данные в виде объекта. На входе функция \"mapStateToProps()\" принимает state с типом\n\"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает данные с типом \"MapStateToPropsType\".*/\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => ({\n    /*Свойство, которое показывает инициализировано ли приложение.*/\n    initialized: state.app.initialized\n});\n\n/*Поскольку мы не можем оборачивать компонент \"App\" в файле \"index.js\", мы это делаем здесь. Создаем внутри этого файла\nконтейнерный компонент \"AppContainer\", который оборачивает наш компонент \"App\" при помощи функции \"compose()\". При\nпомощи функции \"compose()\" объединяем HOC \"withRouter()\" и функцию \"connect()\", возвращая контейнерный компонент\n\"AppContainer\".\n\nЗдесь мы уточняем тип только одним параметром, так как согласно файлу декларации функции \"compose()\" (Ctrl+click в\nWebStorm, раздел \"rest\"), нам нужно уточнить только такой компонент, свойства props которого не будут переданы в этот\nкомпонент функциями, переданными внутрь функции \"compose()\", то есть HOC-ом \"withRouter()\" и функцией \"connect()\", а это\nникакие свойства, так как мы не передаем извне ничего в компонент \"AppContainer\" снизу, когда оборачиваем компонент\n\"AppContainer\" компонентом \"AppMain\".*/\nconst AppContainer = compose<ComponentType>(\n    /*При помощи HOC \"withRouter()\" передаем в этот контейнерный компонент данные из URL.*/\n    withRouter,\n    /*При помощи функции \"connect()\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\n    компоненту \"App\".*/\n    connect(mapStateToProps, {initializeApp})\n)(App);\n\n/*Далее мы оборачиваем созданный выше контейнерный компонент \"AppContainer\" в компоненты \"Provider\" и \"BrowserRouter\".\nПолучившийся итоговый компонент \"AppMain\" экспортируется, чтобы использоваться в файле \"index.js\". При помощи\nкомпонентов \"AppContainer\" и \"AppMain\" мы избавились от оберток вокруг компонента \"App\" в файле \"index.js\".\n\nТакже указываем, что компонент \"AppMain\" имеет тип \"React.FC\", без уточнения типов props, так как ничего внутрь не\nпередаем.*/\nconst AppMain: React.FC = () => {\n    return (\n        /*Оборачиваем компонент \"AppContainer\" в компонент \"BrowserRouter\", чтобы работали маршруты компонентов \"Route\"\n        в компоненте \"App\". Для развертывания нашего приложения на GitHub Pages нужно заменить компонент \"BrowserRouter\"\n        на компонент \"HashRouter\".*/\n        <HashRouter>\n            {/*Оборачиваем компонент \"AppContainer\" в компонент \"Provider\", чтобы указать, что этот компонент будет\n            поставщиком данных BLL и DAL для дочерних компонентов, то есть для создания контекста, из которого\n            контейнерные компоненты смогут брать указанные данные. Также в компоненте \"Provider\" указываем наш store.*/}\n            <Provider store={store}>\n                <AppContainer/>\n            </Provider>\n        </HashRouter>\n    )\n};\n\n/*Экспортируем компонент \"AppMain\" по default и будем его использовать в нашем проекте под именем \"AppMain\". Ключевое\nслово export необходима для импорта чего-то в других файлах.*/\nexport default AppMain;","/*\nУстановка Typescript: npm install --save typescript @types/node @types/react @types/react-dom @types/jest\nУстановка типизации библиотеки Redux Form: npm install --save @types/redux-form\nУстановка типизации библиотеки Classnames: npm install --save @types/classnames\nУстановка типизации библиотеки React Redux: npm install --save @types/react-redux\nУстановка типизации библиотеки React Router DOM: npm install --save @types/react-router-dom\nУстановка типизации библиотеки React Test Renderer: npm install --save @types/react-test-renderer\nУстановка типизации библиотеки UUID: npm install --save @types/uuid\n\nУстановка GitHub Pages: npm install gh-pages --save -dev\nУстановка React Test Renderer: npm i react-test-renderer@16.13.1 --save -dev\n\nПриложение требует Node.js не выше 16 версии, например, 16.20.2 подойдет. Потребуется установка Node Version Manager\n(nvm) для управления разными версиями NodeJS:\n1. Установка Node.js 16: nvm install 16\n2. Переключение на Node.js 16: nvm use 16\n3. Запуск приложения: npm start\n\nУстановка всех модулей (если необходимо): npm install\nЗапуск приложения: npm start\nЗапуск тестов: npm run test\n\nРазвертыванием приложения на GitHub Pages:\n1. В папке нашего React приложения в файле \"App.tsx\" заменяем компонент \"BrowseRouter\" на компонент \"HashRouter\".\n2. В папке нашего React приложения собираем билд нашего приложения, выполняя команду \"predeploy\": npm run build\n3. Разворачиваем билд нашего приложения в нашем репозитории \"demo-spa-source-code\" на ветке \"gh-pages\", выполняя в папке\nнашего React приложения команду \"deploy\": gh-pages -d build\n4. В папке нашего React приложения в файле \"App.tsx\" заменяем обратно компонент \"HashRouter\" на компонент\n\"BrowseRouter\".\n*/\n\n/*GitHub имеет примитивный хостинг GitHub Pages для статических страниц.\n\nНа GitHub Pages приложение разворачивается по такому пути: \"https://github-account-name.github.io/repository-name/\". Но\nпри переходе по компонентам, имя репозитория затирается путем для компонента (например, \"/profile\"). И если мы нажимаем\nF5, тогда GitHub не понимает нашего адреса и не находит наше приложение, так как считает, что \"/profile\" - это один из\nнаших репозиториев.\n\nЧтобы решить эту проблему, мы настраиваем компонент \"BrowseRouter\" в файле \"App.tsx\". Там, где мы используем компонент\n\"BrowserRouter\", мы добавляем \"<BrowserRouter basename={process.env.PUBLIC_URL}>\". Это говорит, что надо автоматически\nбрать URL из окружения. \"process\" - это глобальный объект из Node.js. \"env\" - это окружение, тоже берется из Node.js.\n\"PUBLIC_URL\" - если используется \"localhost\", то равняется \"пустоте\", если используется GitHub, то GitHub Pages укажет\nссылку на репозиторий. Но в итоге мы это не используем в нашем приложении, так как это все равно не решает указанную\nвыше проблему, поскольку GitHub пытается после нажатия F5 найти файл \"index.html\", например, в папке \"/profile\", про\nкоторую он не знает.\n\nИ для решения указанной проблемы мы используем компонент \"HashRouter\" вместо компонента \"BrowseRouter\". Компонент\n\"HashRouter\" использует якори - \"#\". Якори изначально использовались для перемещения по странице, но в дальнейшем стали\nиспользоваться для переключения страниц без изменения URL. Так делали до появления HistoryAPI в HTML5, поэтому компонент\n\"HashRouter\" не особо часто используется сегодня. Но в нашем случае он помогает, поскольку якори \"#\" и все, что идет\nпосле них, не будут считаться частью URL сайта и GitHub будет искать файл \"index.html\" там, где надо.\n\nКак развернуть приложение на GitHub Pages:\n1. Подключаемся, если не подключены, к нашему удаленному GitHub репозиторию, выполняя в папке нашего React приложения\nкоманду: git remote add origin https://github.com/AltyAlty/demo-spa-source-code.git\n2. На сайте GitHub в настройках нашего репозитория \"demo-spa-source-code\" переходим в раздел \"Pages\", там в пункте\n\"Source\" выбираем \"Deploy from a branch\", а в разделе \"Branch\" выбираем ветку \"master\" и папку \"/root\". Нажимаем \"Save\".\n3. В папке нашего React приложения устанавливаем GitHub Pages: npm install gh-pages --save -dev\n4. В папке нашего React приложения в файле \"package.json\" указываем домашнюю страницу. Для этого в верхний уровень\n(например, перед разделом \"dependencies\") добавляем: \"homepage\": \"URL, где будет развернуто наше приложение\". Например,\n\"homepage\": \"https://altyalty.github.io/demo-spa-source-code/\".\n5. В папке нашего React приложения в файле \"package.json\" добавляем скрипты в раздел \"scripts\":\n\"predeploy\": \"npm run build\"\n\"deploy\": \"gh-pages -d build\"\n6. С GitHub запрещено делать запросы к нашему серверу, поэтому на сайте API https://social-network.samuraijs.com/account\nв настройках указываем домен, на котором будет размещено наше приложение (без \"/\" в конце):\nhttps://github-account-name.github.io. Например: https://altyalty.github.io.\n7. В папке нашего React приложения в файле \"api.ts\" указываем наш API ключ, который можно получить на сайте API\nhttps://social-network.samuraijs.com/account.\n8. В папке нашего React приложения в файле \"App.tsx\" заменяем компонент \"BrowseRouter\" на компонент \"HashRouter\".\n9. В папке нашего React приложения собираем билд нашего приложения, выполняя команду \"predeploy\": npm run build\n10. На сайте GitHub в нашем репозитории \"demo-spa-source-code\" создаем ветку \"gh-pages\" и разворачиваем там билд нашего\nприложения, выполняя в папке нашего React приложения команду \"deploy\": gh-pages -d build\n11. На сайте GitHub в настройках нашего репозитория \"demo-spa-source-code\" переходим в раздел \"Pages\", там в пункте\n\"Source\" выбираем \"Deploy from a branch\", а в разделе \"Branch\" выбираем ветку \"gh-pages\" и папку \"/root\". Нажимаем\n\"Save\".\n12. Открываем наше развернутое приложения: https://altyalty.github.io/demo-spa-source-code/.\n12. В папке нашего React приложения в файле \"App.tsx\" заменяем обратно компонент \"HashRouter\" на компонент\n\"BrowseRouter\".\n\nВ итоге в репозитории \"demo-spa-source-code\" на ветке \"master\" находится исходный код нашего приложения, а на ветке\n\"gh-pages\" находится билд нашего приложения.\n\nТеперь перед каждым развертыванием нашего приложения делаем следующее:\n1. В папке нашего React приложения в файле \"App.tsx\" заменяем компонент \"BrowseRouter\" на компонент \"HashRouter\".\n2. В папке нашего React приложения собираем билд нашего приложения, выполняя команду \"predeploy\": npm run build\n3. Разворачиваем билд нашего приложения в нашем репозитории \"demo-spa-source-code\" на ветке \"gh-pages\", выполняя в папке\nнашего React приложения команду \"deploy\": gh-pages -d build\n4. В папке нашего React приложения в файле \"App.tsx\" заменяем обратно компонент \"HashRouter\" на компонент\n\"BrowseRouter\".\n\nПосле каждого запуска скрипта \"deploy\" нужно немного подождать, чтобы наше приложение успело обновиться на GitHub.\n\nДля добавления исходного кода нашего приложения в ветку \"master\" репозитория \"demo-spa-source-code\" выполняем команду:\ngit push -u origin master.*/\n\n/*Установленные модули:\nNode.js 16.20.2\nTypescript 4.3.5\nReact 17.0.2\nReact Router DOM 5.2.0\nRedux 4.1.0\nReact Redux 7.2.4\nRedux Thunk 2.3.0\nReselect 4.0.0\nRedux Form 8.3.7\nFormik 2.2.9\nAxios 0.21.1\nquerystring 0.2.1\nUUID 8.3.2\nAnt Design 4.16.9\nСlassnames 2.3.1\nJest 5.14.1\nReact Test Renderer 17.0.2\nGitHub Pages 3.2.3*/\n\n/*Протестированные компоненты:\n1. App\n2. Paginator\n3. ProfileStatus\n\nПротестированные редьюсеры:\n1. profileReducer\n2. usersReducer + thunks*/\n\n/*В \"index.js\" не должно быть обверток вокруг компонента \"App\", поэтому мы их перенесли в файл \"App.tsx\".\n\"index.js\" - этот файл является точкой входа для сборщика WebPack.\n\"index.html\" - этот файл является точкой входа нашего приложения.\n\"index.css\" - этот файл содержит общие стили для всего приложения.*/\n\n/*Это уже было здесь изначально, из темы \"Progressive Web Application\" (PWA).*/\nimport * as serviceWorker from './serviceWorker';\n/*Импортируем сам React, необходим везде, где мы что-то из него используем (например, JSX). WebPack уже встроен в\nReact.*/\nimport React from 'react';\n/*Импортируем ReactDOM для метода \"render()\", который отрисовывает DOM-дерево из React.*/\nimport ReactDOM from 'react-dom';\n/*Импортируем файл CSS.*/\nimport './index.css';\n/*Импортируем компонент \"AppMain\".*/\nimport AppMain from './App';\n\n/*В файле \"index.js\" мы указываем главный компонент \"AppMain\" (то есть компонент \"App\", обвернутый разными обвертками),\nкоторый будет отрисовываться.*/\nReactDOM.render(\n    /*\"StrictMode\" это специальный строгий режим из React, для избежания некоторых ошибок.*/\n    <React.StrictMode>\n        <AppMain/>\n    </React.StrictMode>,\n    /*JS будет отрисовывать приложение в элементе \"div\" с атрибутом \"id\" \"root\" в файле \"index.html\".*/\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();","export default __webpack_public_path__ + \"static/media/preloader.5f3f0496.gif\";","import React from 'react';\r\n/*Импортируем стили из CSS-модуля.*/\r\nimport styles from './Preloader.module.css';\r\n/*Импортируем из ассетов анимированное изображение, изображающее загрузку.*/\r\nimport preloader from '../../../assets/images/preloader.gif';\r\n\r\n/*Создаем тип для props.*/\r\ntype PropsType = {};\r\n\r\n/*\"Preloader\" это функциональный компонент, который создан в виде стрелочной функции. \"Preloader\" является\r\nкомпонентом-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах, пока идет\r\nкакой-то фоновой процесс (например, AJAX-запрос).\r\n\r\nКомпонент \"Preloader\" импортируется в файлах \"App.tsx\", \"ProfileInfo.tsx\", \"Users.tsx\", \"SearchUsersAreaResults.tsx\",\r\n\"UserInfo.tsx\" и \"WithSuspense.tsx\".\r\n\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти. React вызывает функциональный\r\nкомпонент, компонент делает свою работу (например, возвращает JSX), после чего компонент удаляется из памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Preloader(props) {тело}.\r\n\r\nУказываем при помощи \"React.FC<>\", что props в этом функциональном компоненте имеют тип \"PropsType\". Также указываем,\r\nчто экспортируем этот компонент не по default.*/\r\nexport const Preloader: React.FC<PropsType> = (props) => {\r\n    return (\r\n        <div className={styles.preloader}>\r\n            {/*Отрисовываем элемент \"img\" с изображением анимации загрузки.*/}\r\n            <img alt='' src={preloader}/>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\n/*Импортируем тип \"WrappedFieldMetaProps\", который мы нашли в файле декларации компонента \"Field\" и используем его для\r\nуказания типа созданного нами компонента \"FormControl\". Импортируем тип \"WrappedFieldProps\", который мы нашли в файле\r\nдекларации компонента \"Field\" и используем его для указания типа созданных нами компонентов \"Textarea\" и \"Input\".*/\r\nimport {Field, WrappedFieldMetaProps, WrappedFieldProps} from 'redux-form';\r\nimport styles from './FormsControls.module.css';\r\n/*Импортируем тип \"FieldValidatorType\".*/\r\nimport {FieldValidatorType} from '../../../utils/validators/validators';\r\n\r\n/*Типизируем props для компонента \"FormControl\".*/\r\ntype FormControlPropsType = {\r\n    /*Объект \"meta\" с мета-данными, приходящий к нам сверху из компонента \"Field\" из библиотеки Redux Form, должен иметь\r\n    тип \"WrappedFieldMetaProps\".*/\r\n    meta: WrappedFieldMetaProps\r\n};\r\n\r\n/*Следующий тип мы создаем специально, чтобы мы не могли допустить ошибок при указании свойства \"name\" в функции\r\n\"createField()\". Это свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы строим\r\nсвой generic, чтобы можно было уточнить функцию \"createField()\". Нужные нам имена свойств уже должны быть перечислены в\r\nкаком-то другом типе, чтобы мы при помощи \"keyof\" получали ключи из этого типа. Далее при помощи Extract (берется из\r\nTypescript) берем из этих ключей, только те, которые могут быть назначены как строка. И на основе этого создаем тип. Для\r\nбольшего количество деталей смотри реализацию функции \"createField()\" в этом файле.*/\r\nexport type GetValuesKeysType<T> = Extract<keyof T, string>;\r\n\r\n/*\"FormControl\" это функциональный компонент, который создан в виде стрелочной функции. \"FormControl\" является\r\nкомпонентом, который содержит общую логику для графического отображения срабатывания валидаторов независимо от типа\r\nэлемента.\r\n\r\nКомпонент \"FormControl\" используется в компонентах \"Textarea\" и \"Input\" в этом же файле.\r\n\r\nКомпонент \"FormControl\" получает на входе мета-данные, содержащие информацию касались ли мы элемента и есть ли\r\nкакая-либо ошибка (вроде, это все берется из библиотеки Redux Form, а текст ошибки, вроде, берется из того, что\r\nвозвращают валидаторы при срабатывании и передают это в компонент \"Field\", собственно от компонента \"Field\" этот\r\nкомпонент и будет получать эти данные при помощи замыкания), а также получает информацию о дочернем элементе.*/\r\nconst FormControl: React.FC<FormControlPropsType> =\r\n    ({meta: {touched, error}, children}) => {\r\n        /*Создаем специальную константу для удобства, которая содержит условие, что в мета-данных указано, что мы\r\n        касались элемента (\"meta.touched\") и что присутствует какая-то ошибка (\"meta.error\"). Только здесь может быть\r\n        проблема, если мы не касались какого-то поля, то нам разрешат отправить, например, пустой пост на странице\r\n        профиля. Этот объект \"meta\" с мета-данными придет к нам сверху из компонента \"Field\".*/\r\n        const hasError = touched && error;\r\n\r\n        return (\r\n            /*Этот компонент возвращает JSX, содержащий элемент \"div\", внутри которого будет меняться CSS в зависимости\r\n            от значения константы \"hasError\". То есть будет два варианта:\r\n            1. \"styles.formControl styles.error\"\r\n            2. \"styles.formControl\"*/\r\n            <div className={styles.formControl + ' ' + (hasError ? styles.error : '')}>\r\n                {/*Внутри отрисовываем еще один элемент \"div\". \"children\" это ключевое слово в React. При помощи этого\r\n                слова этот элемент \"div\" будет отрисовывать потомков, которые будут указаны в месте вызова компонента\r\n                \"FormControl\".*/}\r\n                <div>\r\n                    {children}\r\n                </div>\r\n\r\n                {/*Также внутри отрисовываем еще один элемент \"div\". В этом элементе будет отображаться элемент \"span\"\r\n                с текстом ошибки, указанного в валидаторе.*/}\r\n                <div>\r\n                    {hasError && <span>{error}</span>}\r\n                </div>\r\n            </div>\r\n        )\r\n    };\r\n\r\n/*Компонент \"Textarea\" это функциональный компонент, который создан в виде стрелочной функции. \"Textarea\" является\r\nкомпонентом, который используется для отрисовки элементов \"textarea\" в других местах, где в таких элементах требуется\r\nвалидация.\r\n\r\nВнутри компонента \"Textarea\" используются следующие компоненты:\r\n1. \"FormControl\" - компонент, который содержит общую логику для графического отображения срабатывания валидаторов\r\nнезависимо от типа элемента. Из этого же файла.\r\n\r\nКомпонент \"Textarea\" импортируется в файлах \"Dialogs.tsx\", \"MyPosts.tsx\" и \"ProfileDataReduxEditForm.tsx\".*/\r\nexport const Textarea: React.FC<WrappedFieldProps> = (props) => {\r\n    /*Таким образом при помощи деструктуризации мы создаем константы:\r\n    1. \"const input = props.input\" - здесь внутри есть \"input.value\", что является тем, что введено в поле, создается\r\n    компонентом \"Field\" из библиотеки Redux Form.\r\n    2. \"const meta = props.meta\" - это мета-данные, создаваемые компонентом \"Field\" из библиотеки Redux Form, внутри\r\n    которых есть \"touched\" или \"error\", используемые в компоненте \"FormControl\".\r\n    3. \"...restProps\" это остальные props (в виде объекта), которые в дальнейшем можно передавать как \"...restProps\",\r\n    например, там будет \"placeholder\" для элементов \"textarea\" или \"input\".*/\r\n    const {input, meta, ...restProps} = props;\r\n    /*Этот компонент возвращает компонент \"FormControl\", который получит props свыше и деструктуризирует их, а затем\r\n    передаст их дочерним элементам. А в качестве дочернего элемента этот компонент будет иметь элемент \"textarea\",\r\n    внутри которого будет при помощи деструктуризации передано:\r\n    1. \"input.value\" - то, что введено в поле.\r\n    2. остальные \"input.\" свойства.\r\n    3. и объект с остальными props.\r\n\r\n    То есть поскольку компонент \"Textarea\" будет использоваться в компоненте \"Field\" из библиотеки Redux Form (цепочка\r\n    будет такая: компонент \"Field\" -> компонент \"Textarea\" -> компонент \"FormControl\" -> элемент \"textarea\"), то значит,\r\n    что компонент \"FormControl\" получит \"сверху\" \"props.meta.touched\" и \"props.meta.error\" при помощи библиотеки Redux\r\n    Form, которые ему необходимы для работы. А также компонент \"FormControl\" получит информацию о своем дочернем\r\n    элементе \"textarea\", так как использует ключевое слово \"children\" из React, поэтому он сможет передать этому\r\n    дочернему элементу необходимые для него props, например \"placeholder\" (то есть при помощи замыкания будет доступ к\r\n    props из компонента \"Field\", компонента \"Textarea\" и компонента \"FormControl\").*/\r\n    return <FormControl {...props}><textarea {...input} {...restProps}/></FormControl>\r\n};\r\n\r\n/*Компонент \"Input\" это функциональный компонент, который создан в виде стрелочной функции. \"Input\" является\r\nкомпонентом, который используется для отрисовки элементов \"input\" в других местах, где в таких элементах требуется\r\nвалидация.\r\n\r\nВнутри компонента \"Input\" используются следующие компоненты:\r\n1. \"FormControl\" - компонент, который содержит общую логику для графического отображения срабатывания валидаторов\r\nнезависимо от типа элемента. Из этого же файла.\r\n\r\nКомпонент \"Input\" импортируется в файлах \"Login.tsx\" и \"ProfileDataReduxEditForm.tsx\".*/\r\nexport const Input: React.FC<WrappedFieldProps> = (props) => {\r\n    /*Таким образом при помощи деструктуризации мы создаем константы:\r\n    1. \"const input = props.input\" - здесь внутри есть \"input.value\", что является тем, что введено в поле, создается\r\n    компонентом \"Field\" из библиотеки Redux Form.\r\n    2. \"const meta = props.meta\" - это мета-данные, создаваемые компонентом \"Field\" из библиотеки Redux Form, внутри\r\n    которых есть \"touched\" или \"error\", используемые в компоненте \"FormControl\".\r\n    3. \"...restProps\" это остальные props (в виде объекта), которые в дальнейшем можно передавать как \"...restProps\",\r\n    например, там будет \"placeholder\" для элементов \"textarea\" или \"input\".*/\r\n    const {input, meta, ...restProps} = props;\r\n    /*Этот компонент возвращает компонент \"FormControl\", который получит props свыше и деструктуризирует их, а затем\r\n    передаст их дочерним элементам. А в качестве дочернего элемента этот компонент будет иметь элемент \"input\", внутри\r\n    которого будет при помощи деструктуризации передано:\r\n    1. \"input.value\" - то, что введено в поле;\r\n    2. остальные \"input.\" свойства;\r\n    3. и объект с остальными props;\r\n\r\n    То есть поскольку компонент \"Input\" будет использоваться в компоненте \"Field\" из библиотеки Redux Form (цепочка\r\n    будет такая: компонент \"Field\" -> компонент \"Input\" -> компонент \"FormControl\" -> элемент \"input\"), то значит, что\r\n    компонент \"FormControl\" получит \"сверху\" \"props.meta.touched\" и \"props.meta.error\" при помощи библиотеки Redux Form,\r\n    которые ему необходимы для работы. А также компонент \"FormControl\" получит информацию о своем дочернем элементе\r\n    \"input\", так как использует ключевое слово \"children\" из React, поэтому он сможет передать этому дочернему элементу\r\n    необходимые для него props, например \"placeholder\" (то есть при помощи замыкания будет доступ к props из компонента\r\n    \"Field\", компонента \"Input\" и компонента \"FormControl\").*/\r\n    return <FormControl {...props}><input {...input} {...restProps}/></FormControl>\r\n};\r\n\r\n/*Создаем функцию \"createField()\", которая принимает параметры и создает элементы формы. Функция \"createField()\"\r\nиспользуется для создания формы как аналог компонента \"Field\" из библиотеки Redux Form.\r\n\r\nФункция \"createField()\" импортируется в файлах \"Dialogs.tsx\", \"Login.tsx\", \"MyPosts.tsx\" и\r\n\"ProfileDataReduxEditForm.tsx\".\r\n\r\nУказываем, что функция \"createField()\" теперь обобщенная, то есть generic. Если бы мы описали эту функцию стрелочным\r\nсинтаксисом, то у нас так не получилось бы ее сделать generic. То есть теперь мы можем уточнять эту функцию при ее\r\nиспользовании, а точнее мы будем уточнять свойство \"name\", поэтому указываем придуманный нами тип \"FormKeysType\" здесь и\r\nв самом \"name\" дальше.\r\n\r\nПри помощи \"extends string\" указываем, что этот тип экстендится от типа строки (то есть должен совпадать со строкой),\r\nхотя и может быть более сложным. Последнее нам нужно, чтобы не было ошибки ниже в \"name={name}\", так как там по сути\r\nожидается строка.*/\r\nexport function createField<FormKeysType extends string>(\r\n    /*Текст \"placeholder\". Должен быть строкой или undefined, то есть отсутствовать вовсе, а не быть пустым.*/\r\n    placeholder: string | undefined,\r\n    /*Имя данных, которые будут вводиться в это поле. Имеют тип \"FormKeysType\", то есть здесь указываются какие-то\r\n    ключи, но какие именно мы должны указывать сами в каждой форме. Нам это нужно для того, чтобы проводить типизацию в\r\n    целях избежания ошибок при указании свойства \"name\" при использовании функции \"createField()\" в компонентах. Это\r\n    свойство важно для формирования имен свойств \"formData\", то есть данных формы.*/\r\n    name: FormKeysType,\r\n    /*Какой компонент отрисовываем (например, \"Textarea\" или \"Input\" из этого файла). Указали при помощи \"React.FC<>\",\r\n    что \"props\" в этих функциональных компонентах имеют тип \"WrappedFieldProps\".*/\r\n    component: React.FC<WrappedFieldProps>,\r\n    /*Валидаторы. Должны быть в виде массива элементов с типом \"FieldValidatorType\".*/\r\n    validators: Array<FieldValidatorType>,\r\n    /*Любые другие \"props\".*/\r\n    props = {},\r\n    /*Текст, который необходим некоторым элементам (например, \"Remember me?\" для чек-бокса \"Запомнить меня?\"). Должно\r\n    быть по умолчанию строкой.*/\r\n    text = ''\r\n) {\r\n    return (\r\n        /*В итоге функция создает отдельный элемент \"div\", в котором внутри есть компонент \"Field\" из библиотеки Redux\r\n        Form. Что из себя будет представлять этот компонент \"Field\" будет зависеть от параметров выше.*/\r\n        <div>\r\n            <Field\r\n                placeholder={placeholder}\r\n                name={name}\r\n                component={component}\r\n                validate={validators}\r\n                {...props}\r\n            /> {text}\r\n        </div>\r\n    )\r\n};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"formControl\":\"FormsControls_formControl__3Xme6\",\"error\":\"FormsControls_error__2IHCC\",\"formSummaryError\":\"FormsControls_formSummaryError__3CYVM\"};","/*Этот файл содержит валидаторы для полей и форм. Валидацию можно делать как для отдельного поля, так и для всей формы.\r\nМета-данные это дополнительные данные о данных. Библиотека Redux Form позволяет нам использовать валидаторы, встроенные\r\nв нее. В нашем приложении добавлена валидация на страницах профиля, диалогов и логина. При срабатывании указанных здесь\r\nвалидаторов submit формы не сработает. То, что возвращают валидаторы попадает в свойство \"error\", которое создается\r\nбиблиотекой Redux Form.*/\r\n\r\n/*Создаем тип для валидаторов. Валидатор должен быть функцией, которая принимает строковой параметр и возвращает\r\nстроковой параметр или undefined, то есть ничего.*/\r\nexport type FieldValidatorType = (value: string) => string | undefined;\r\n\r\n/*Это валидатор, который проверяет обязательное заполнение поля. При вызове этой функции в нее будет приходить то, что\r\nнаходится в поле. Указали, что этот валидатор имеет тип \"FieldValidatorType\".*/\r\nexport const required: FieldValidatorType = (value) => {\r\n    /*Здесь проверяем имеется ли какое-либо введенное значение в поле, если есть, то ничего не происходит.*/\r\n    if (value) return undefined;\r\n    /*Если никакого значение не указано в поле, то будет выводиться соответствующее информационное сообщение.*/\r\n    return 'Field is required';\r\n};\r\n\r\n/*Это валидатор, который проверяет не превышает ли введенный текст в поле максимального количества символов для этого\r\nполя. При вызове этой функции в нее будет приходить значение, которое обозначает максимальное количество символов для\r\nкакого-то поля, и то, что введено в поле. То есть здесь одна функция принимает числовой параметр и возвращает другую\r\nфункцию, то есть наш валидатор, которая имеет тип \"FieldValidatorType\".*/\r\nexport const maxLengthCreator = (maxLength: number): FieldValidatorType => (value) => {\r\n    /*Если длина текста в поле больше значения, которое обозначает максимальное количество символов для этого поля, то\r\n    будет выводиться соответствующее информационное сообщение.*/\r\n    if (value.length > maxLength) return `max length is ${maxLength} symbols`;\r\n    /*Если же длина текста в поле меньше или равна значению, которое обозначает максимальное количество символов для\r\n    этого поля, то ничего не происходит.*/\r\n    return undefined;\r\n};"],"sourceRoot":""}