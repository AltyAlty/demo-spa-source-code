{"version":3,"sources":["hoc/WithAuthRedirect.tsx","pages/ChatPage/ChatPage.module.css","redux/chat-selectors.ts","pages/ChatPage/Chat/ChatMessages/ChatMessage/ChatMessage.tsx","pages/ChatPage/Chat/ChatMessages/ChatMessages.tsx","pages/ChatPage/Chat/AddChatMessageForm/AddChatMessageForm.tsx","pages/ChatPage/Chat/Chat.tsx","pages/ChatPage/ChatPage.tsx"],"names":["mapStateToPropsForRedirect","state","isAuth","auth","withAuthRedirect","Component","connect","props","restProps","to","module","exports","getChatMessages","chat","chatMessages","getWSStatus","WSStatus","ChatMessage","React","memo","chatMessage","className","styles","userId","src","photo","avatarSource","alt","chatMessageUserName","userName","chatMessageText","message","ChatMessages","useSelector","chatMessagesAnchorRef","useRef","useState","isAutoScrollActive","setAutoScroll","useEffect","current","scrollIntoView","behavior","onScroll","event","element","currentTarget","Math","abs","scrollHeight","scrollTop","clientHeight","map","m","index","id","ref","AddChatMessageForm","setChatMessage","dispatch","useDispatch","placeholder","onChange","e","value","onClick","sendChatMessage","disabled","Chat","startGettingChatMessages","stopGettingChatMessages","wsError"],"mappings":"mNAeMA,EAA6B,SAACC,GAAD,MAA0D,CAEzFC,OAAQD,EAAME,KAAKD,SAiBhB,SAASE,EAA+BC,GAgC3C,OAAOC,YACNN,EADMM,EAtBP,SAA2BC,GAGvB,IAAOL,EAAwBK,EAAxBL,OAAWM,EAAlB,YAA+BD,EAA/B,GAIA,OAAKL,EAKE,cAACG,EAAD,eAAeG,IALF,cAAC,IAAD,CAAUC,GAAI,iB,oBClD1CC,EAAOC,QAAU,CAAC,aAAe,+BAA+B,YAAc,8BAA8B,oBAAsB,sCAAsC,gBAAkB,kCAAkC,QAAU,4B,6ECMzNC,EAAkB,SAACX,GAA0B,OAAOA,EAAMY,KAAKC,cAG/DC,EAAc,SAACd,GAA0B,OAAOA,EAAMY,KAAKG,U,iDCQ3DC,EAAkDC,IAAMC,MAAK,YAAoB,IAAlBC,EAAiB,EAAjBA,YACxE,OACI,sBAAKC,UAAWC,IAAOF,YAAvB,UAEI,eAAC,IAAD,CAASX,GAAI,YAAcW,EAAYG,OAAvC,UAGI,qBAAKC,IAA2B,OAAtBJ,EAAYK,MAAiBL,EAAYK,MAAQC,IAAcC,IAAI,KAG7E,uBAAMN,UAAWC,IAAOM,oBAAxB,UACKR,EAAYS,SAAW,IAD5B,SACuCT,EAAYG,OADnD,WAMJ,sBAAMF,UAAWC,IAAOQ,gBAAxB,SACKV,EAAYW,gBCdhBC,EAAyB,WAGlC,IAAMlB,EAAemB,YAAYrB,GAG3BsB,EAAwBC,iBAAuB,MAKrD,EAA4CC,oBAAkB,GAA9D,mBAAOC,EAAP,KAA2BC,EAA3B,KAmDA,OAZAC,qBAAU,WAAO,IAAD,EAKJF,IAAoB,UAAAH,EAAsBM,eAAtB,SAA+BC,eAAe,CAACC,SAAU,cAIrF,CAAC5B,IAID,sBAAKO,UAAWC,IAAOR,aAAc6B,SA/Cd,SAACC,GAExB,IAAMC,EAAUD,EAAME,cAuBlBC,KAAKC,IAAKH,EAAQI,aAAeJ,EAAQK,UAAaL,EAAQM,cAAgB,KAC7Ed,GAAsBC,GAAc,GAErCD,GAAsBC,GAAc,IAmBxC,UAGKxB,EAAasC,KAAI,SAACC,EAAGC,GAAJ,OAAc,cAACrC,EAAD,CAAwBG,YAAaiC,GAAnBA,EAAEE,OAGpD,qBAAKC,IAAKtB,QC/ETuB,EAA+B,WAKxC,MAAsCrB,mBAAS,IAA/C,mBAAOhB,EAAP,KAAoBsC,EAApB,KAGM1C,EAAWiB,YAAYlB,GACvB4C,EAAWC,cAYjB,OACI,gCACI,8BAEI,0BACIC,YAAa,qBAGbC,SAAU,SAACC,GAAD,OAAOL,EAAeK,EAAEjB,cAAckB,QAKhDA,MAAO5C,MAIf,8BAMI,wBAAQ6C,QA7BG,WACd7C,IACLuC,EAASO,YAAgB9C,IACzBsC,EAAe,MA0B0BS,SAAuB,UAAbnD,EAA3C,wBCnCHoD,EAAiB,WAG1B,IAAMpD,EAAWiB,YAAYlB,GACvB4C,EAAWC,cAgBjB,OAZArB,qBAAU,WAKF,OAJAoB,EAASU,eAIF,WAAQV,EAASW,kBAI5B,IAIA,gCAIkB,UAAbtD,GAAwB,qBAAKK,UAAWC,IAAOiD,QAAvB,4FAIzB,qCACI,cAAC,EAAD,IACA,cAAC,EAAD,W,SCxBDnE,uBAbY,WACvB,OACI,8BAEI,cAAC,EAAD","file":"static/js/5.3aac292c.chunk.js","sourcesContent":["import React, {ComponentType} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {Redirect} from 'react-router-dom';\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from '../redux/redux-store';\r\n\r\n/*Создаем тип для функции \"mapStateToPropsForRedirect()\".*/\r\ntype MapStateToPropsForRedirectType = {\r\n    /*Свойство, которое указывает залогинен ли пользователь, должно быть булева типа.*/\r\n    isAuth: boolean\r\n};\r\n\r\n/*Здесь мы таким образом создаем props необходимые для работы редиректа. Будем их подключать при помощи функции\r\n\"connect()\". На входе функция \"mapStateToPropsForRedirect()\" принимает state с типом \"AppStateType\", а на выходе выдает\r\nданные с типом \"MapStateToPropsForRedirectType\".*/\r\nconst mapStateToPropsForRedirect = (state: AppStateType): MapStateToPropsForRedirectType => ({\r\n    /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    isAuth: state.auth.isAuth\r\n});\r\n\r\n/*HOC \"withAuthRedirect()\" - это HOC, который добавляет редирект в наш проект.\r\n\r\nЭтот HOC, в качестве параметра принимает какой-либо компонент \"Component\". Не используем здесь синтаксис стрелочной\r\nфункции, чтобы можно было уточнить props как \"WrappedProps\", как мы это сделали здесь. Этот HOC принимает какой-то\r\ngeneric компонент \"Component\", который ожидает props c типом \"WrappedProps\".\r\n\r\nКомпонент \"Component\" должен быть типа \"ComponentType\", то есть быть каким-то компонентом из React.\r\n\r\nУточняем, что внутри ожидаются props c типом \"WrappedProps\", то есть те же props компонента \"Component\", который мы\r\nбудем передавать в этот HOC, так как наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\".\r\nНо при этом наш HOC будет использовать свойство \"isAuth\" из функции \"mapStateToPropsForRedirect()\" для своей внутренней\r\nработы.\r\n\r\nHOC \"withAuthRedirect()\" импортируется в файлах \"DialogsContainer.tsx\" и \"ChatPage.tsx\".*/\r\nexport function withAuthRedirect<WrappedProps>(Component: ComponentType<WrappedProps>) {\r\n    /*После получения компонента \"Component\" в качестве параметра, создается другой функциональный компонент\r\n    \"RedirectComponent\". Это обертка для компонента \"Component\", поэтому props компонента \"RedirectComponent\" должны\r\n    быть типа \"WrappedProps\", так как эти props должны не потеряться и быть переданы в компонент \"Component\", и типа\r\n    \"MapStateToPropsForRedirectType\", так как для работы компонента \"RedirectComponent\" необходимо свойство \"isAuth\" из\r\n    функции \"mapStateToPropsForRedirect()\". Но свойство \"isAuth\" мы не должны передавать в компонент \"Component\".\r\n\r\n    Но для функции \"connect()\" и для внутренней работы компонента \"RedirectComponent\" важно знать только props типа\r\n    \"MapStateToPropsForRedirectType\", поэтому в итоге мы убираем \"WrappedProps\" здесь и оставляем только\r\n    \"MapStateToPropsForRedirectType\" в качестве типа для props компонента \"RedirectComponent\".*/\r\n    function RedirectComponent(props: MapStateToPropsForRedirectType) {\r\n        /*Здесь мы выделяем \"props.isAuth\" в переменную \"isAuth\", а остальные свойства props оставляем в объекте\r\n        \"restProps\" при помощи деструктуризации.*/\r\n        const {isAuth, ...restProps} = props;\r\n        /*Внутри этого функционального компонента \"RedirectComponent\" указано, что если пользователь не залогинен, то\r\n        происходит при помощи \"Redirect\" из библиотеки React Router DOM редирект по пути \"/login/\", где находится форма\r\n        для логинизации, вместо отрисовки переданного в HOC компонента \"Component\".*/\r\n        if (!isAuth) return <Redirect to={'/login/'}/>\r\n        /*Если же пользователь оказался залогиненным, то мы попадем в этот return. В этом случае возвращается компонент\r\n        \"Component\", переданный в HOC, при помощи деструктуризации снабженный \"restProps\", которые должны восприниматься\r\n        как props типа \"WrappedProps\", то есть теми же props, что у него были изначально, так как выше мы убрали\r\n        свойство \"isAuth\" из них.*/\r\n        return <Component {...restProps as WrappedProps}/>\r\n    };\r\n\r\n    /*Далее в свою очередь функциональный компонент \"RedirectComponent\" оборачивается при помощи функции \"connect()\",\r\n    чтобы получить необходимые props для проверки залогинен ли пользователь или нет. Метод \"connect()\" вернет итоговый\r\n    компонент. Поскольку функция \"connect()\" является generic, то ее можно уточнить: первым в \"<>\" указан тип для\r\n    функции \"MapStateToProps()\", вторым для функции \"MapDispatchToProps()\", третьим для \"собственных props\" компонента,\r\n    четвертым для state. Эти параметры мы узнали перейдя в файл декларации функции \"connect()\".\r\n\r\n    Сам HOC \"withAuthRedirect()\" в итоге возвращает получившийся итоговый компонент.*/\r\n    return connect<MapStateToPropsForRedirectType, {}, WrappedProps, AppStateType>\r\n    (mapStateToPropsForRedirect)(RedirectComponent);\r\n};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"chatMessages\":\"ChatPage_chatMessages__N2RIB\",\"chatMessage\":\"ChatPage_chatMessage___bsIl\",\"chatMessageUserName\":\"ChatPage_chatMessageUserName__bxndp\",\"chatMessageText\":\"ChatPage_chatMessageText__DpVVY\",\"wsError\":\"ChatPage_wsError__31Og4\"};","/*Здесь содержатся селекторы для данных из файла \"chat-reducer.ts\".*/\r\n\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from './redux-store';\r\n\r\n/*Это созданный нами без библиотеки Reselect селектор. Он возвращает информацию о сообщениях из чата для вывода их в\r\nнашем приложении.*/\r\nexport const getChatMessages = (state: AppStateType) => { return state.chat.chatMessages};\r\n/*Это созданный нами без библиотеки \"reselect\" селектор. Он возвращает статус готовности WebSocket-канала для отправки\r\nинформации по нему.*/\r\nexport const getWSStatus = (state: AppStateType) => { return state.chat.WSStatus};","import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\nimport styles from '../../../ChatPage.module.css';\r\n/*Импортируем из ассетов проекта аватар пользователя.*/\r\nimport avatarSource from '../../../../../assets/images/user.png';\r\n/*Импортируем тип \"ChatMessageAPIType\".*/\r\nimport {ChatMessageAPIType} from '../../../../../api/chat-api';\r\n\r\n/*Создаем тип для props компонента \"ChatMessage\".*/\r\ntype ChatMessageComponentType = {\r\n    /*Данные о сообщении из чата должны быть типа \"ChatMessageAPIType\".*/\r\n    chatMessage: ChatMessageAPIType\r\n};\r\n\r\n/*\"ChatMessage\" это функциональный компонент, который создан в виде стрелочной функции. \"ChatMessage\" является\r\nкомпонентом, который отвечает за типовое отображение сообщения в чате.\r\n\r\nКомпонент \"ChatMessage\" импортируется в файле \"ChatMessages.tsx\".*/\r\nexport const ChatMessage: React.FC<ChatMessageComponentType> = React.memo(({chatMessage}) => {\r\n    return (\r\n        <div className={styles.chatMessage}>\r\n            {/*Создаем маршрут для пути перехода на страницу выбранного пользователя. Отрисуется компонент \"Profile\".*/}\r\n            <NavLink to={'/profile/' + chatMessage.userId}>\r\n                {/*Отображаем аватар пользователя, если его нет, то подгружаем дефолтный аватар из проекта\r\n                приложения.*/}\r\n                <img src={chatMessage.photo !== null ? chatMessage.photo : avatarSource} alt=''/>\r\n\r\n                {/*При помощи элемента \"span\" выводим имя и ID пользователя.*/}\r\n                <span className={styles.chatMessageUserName}>\r\n                    {chatMessage.userName + ' '} (id: {chatMessage.userId}):\r\n                </span>\r\n            </NavLink>\r\n\r\n            {/*При помощи элемента \"span\" выводим сообщение пользователя в чат.*/}\r\n            <span className={styles.chatMessageText}>\r\n                {chatMessage.message}\r\n            </span>\r\n        </div>\r\n    )\r\n});","/*Refs дают возможность получить доступ к DOM-узлам или React-элементам. Ситуациями, когда использование рефов\r\nоправдано, являются управление фокусом, выделение текста, воспроизведение медиа, императивный вызов анимаций, интеграция\r\nсо сторонними DOM-библиотеками. Рефы прикрепляются к React-элементам через атрибут \"ref\".\r\n\r\nХук \"useRef()\" возвращает изменяемый ref-объект, свойство \"current\" которого инициализируется переданным аргументом, то\r\nесть \"initialValue\". Возвращенный объект будет сохраняться в течение всего времени жизни компонента.*/\r\nimport React, {useEffect, useRef, useState} from 'react';\r\nimport {useSelector} from 'react-redux';\r\n/*Импортируем селектор \"getChatMessages()\".*/\r\nimport {getChatMessages} from '../../../../redux/chat-selectors';\r\nimport styles from '../../ChatPage.module.css';\r\n/*Импортируем компонент \"ChatMessage\".*/\r\nimport {ChatMessage} from './ChatMessage/ChatMessage';\r\n\r\n/*\"ChatMessages\" это функциональный компонент, который создан в виде стрелочной функции. \"ChatMessages\" является\r\nкомпонентом, который отображает сообщения чата.\r\n\r\nВнутри компонента \"ChatMessages\" используются следующие компоненты:\r\n1. \"ChatMessage\" - компонент, который отвечает за типовое отображение сообщения в чате. Импортирован.\r\n\r\nКомпонент \"ChatMessages\" импортируется в файле \"Chat.tsx\".*/\r\nexport const ChatMessages: React.FC = () => {\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getChatMessages()\", получаем информацию о сообщениях из\r\n    чата для вывода их в нашем приложении.*/\r\n    const chatMessages = useSelector(getChatMessages);\r\n    /*При помощи хука \"useRef()\" создаем реф типа \"HTMLDivElement\", то есть элемент \"div\", который изначально равен\r\n    null.*/\r\n    const chatMessagesAnchorRef = useRef<HTMLDivElement>(null);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать активна ли автопрокрутка чата в какой-то момент или нет\r\n    (изначально активна). Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый\r\n    элемент (то есть указывать активна ли автопрокрутка чата в какой-то момент или нет).*/\r\n    const [isAutoScrollActive, setAutoScroll] = useState<boolean>(true);\r\n\r\n    /*Создаем специальную callback-функцию, которая будет вызываться снизу в корневом элементе \"div\" при срабатывании\r\n    события \"onScroll\", то есть в момент прокрутки нашего чата. На входе принимает событие типа\r\n    \"React.UIEvent<HTMLDivElement, UIEvent>\".*/\r\n    const scrollEventHandler = (event: React.UIEvent<HTMLDivElement, UIEvent>) => {\r\n        /*Получаем свойство \"currentTarget\" полученного события.*/\r\n        const element = event.currentTarget;\r\n\r\n        /*Свойство \"scrollHeight\" это измерение высоты контента в элементе, включая содержимое, невидимое из-за\r\n        прокрутки. Значение свойства \"scrollHeight\" равно минимальному значению свойства \"clientHeight\", которое\r\n        потребуется элементу для того, чтобы поместить все содержимое в видимую область, не используя вертикальную\r\n        полосу прокрутки. Оно включает в себя \"padding\" элемента, но не его \"margin\".\r\n\r\n        Свойство \"scrollTop\" считывает или устанавливает количество пикселей, прокрученных от верха элемента. Свойство\r\n        \"scrollTop\" измеряет дистанцию от верха элемента до верхней точки видимого контента. Когда контент элемента не\r\n        создает вертикальную прокрутку, его свойство \"scrollTop\" равно 0.\r\n\r\n        Свойство \"clientHeight\" - это свойство, доступное только для чтения. Для элементов без CSS-стилей, или элементов\r\n        каркаса строчной разметки - значение равно 0. Для остальных элементов - значение равно внутренней высоте\r\n        элемента в пикселях, включая пространство между содержимым элемента и его границей (\"padding\"), но исключая\r\n        высоту полосы горизонтальной прокрутки, и ширину отступа от границы элемента до родительского элемента\r\n        (\"margin\"). Значение свойства \"clientHeight\" может быть вычислено по формуле:\r\n        \"CSS height\" + \"CSS padding\" - \"высота горизонтального скролла (если присутствует)\".\r\n\r\n        Здесь мы сначала высчитываем высоту того, что ниже верхней границы контента, который мы видим в чате, по модулю\r\n        при помощи функции \"Math.abs()\". Далее вычисляем высоту контента, находящийся ниже нижней границы контента,\r\n        который мы видим в чате. И если это полученное значение меньше 200 пикселей и автопрокрутка чата отключена, то\r\n        мы включаем автопрокрутку. Если же полученное значение больше 200 пикселей и автопрокрутка чата включена, то мы\r\n        выключаем автопрокрутку, чтобы чат постоянно не прокручивался вниз, когда мы что-то читаем сверху чата.*/\r\n        if (Math.abs((element.scrollHeight - element.scrollTop) - element.clientHeight) < 200) {\r\n            !isAutoScrollActive && setAutoScroll(true);\r\n        } else {\r\n            isAutoScrollActive && setAutoScroll(false);\r\n        }\r\n    };\r\n\r\n    /*Используем хук \"useEffect()\", чтобы при получении новых сообщений автоматически прокручивать вниз, чтобы было\r\n    видно новое сообщение.*/\r\n    useEffect(() => {\r\n            /*Метод \"scrollIntoView()\" прокручивает текущий контейнер родителя элемента так, чтобы этот элемент, на\r\n            котором был вызван метод \"scrollIntoView()\" был видим пользователю. Если автопрокрутка включена, то у рефа\r\n            \"chatMessagesAnchorRef\" вызывается метод \"scrollIntoView()\", чтобы чат прокручивался до элемента с этим\r\n            рефом. Параметр \"behavior\" в данном случае определяет плавную анимацию прокрутки.*/\r\n            if (isAutoScrollActive) chatMessagesAnchorRef.current?.scrollIntoView({behavior: 'smooth'});\r\n        },\r\n        /*Второй параметр это сообщения для чата из глобального state. Если эти данные будут меняться, то будет\r\n        срабатывать каждый раз все то, что указано в первом параметре.*/\r\n        [chatMessages]\r\n    );\r\n\r\n    return (\r\n        <div className={styles.chatMessages} onScroll={scrollEventHandler}>\r\n            {/*Мапим массив с сообщениями из чата, чтобы в итоге отрисовать каждое сообщение, используя компонент\r\n            \"ChatMessage\". Внутрь этого компонента передаем информацию о сообщении через атрибут \"chatMessage\".*/}\r\n            {chatMessages.map((m, index) => <ChatMessage key={m.id} chatMessage={m}/>)}\r\n            {/*После всех сообщений чата отрисовываем специальный элемент \"div\", который содержит атрибут \"ref\". Это нам\r\n            нужно, чтобы реализовать прокрутку в самый низ чата.*/}\r\n            <div ref={chatMessagesAnchorRef}></div>\r\n        </div>\r\n    )\r\n};","import React, {useState} from 'react';\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*Импортируем TC \"sendChatMessage()\".*/\r\nimport {sendChatMessage} from '../../../../redux/chat-reducer';\r\n/*Импортируем селектор \"getWSStatus()\".*/\r\nimport {getWSStatus} from '../../../../redux/chat-selectors';\r\n\r\n/*\"AddChatMessageForm\" это функциональный компонент, который создан в виде стрелочной функции. \"AddChatMessageForm\"\r\nявляется компонентом, который отвечает за отображение формы для добавления сообщения в чат.\r\n\r\nКомпонент \"AddChatMessageForm\" импортируется в файле \"Chat.tsx\".*/\r\nexport const AddChatMessageForm: React.FC = () => {\r\n    /*При помощи деструктуризирующего присваивания создали две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать введенный текст сообщения для чата (изначально пустой).\r\n    Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть\r\n    указывать текст сообщения для чата).*/\r\n    const [chatMessage, setChatMessage] = useState('');\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getWSStatus()\", получаем статус готовности\r\n    WebSocket-канала для отправки информации по нему.*/\r\n    const WSStatus = useSelector(getWSStatus);\r\n    const dispatch = useDispatch();\r\n\r\n    /*Создаем специальную callback-функцию \"addChatMessage()\", которая будет вызываться при нажатии на кнопку для\r\n    отправки сообщения в чат, проверять есть ли введенный текст, и если есть, то будет отправлять этот текст в\r\n    WebSocket-канал (если таковой имеется) при помощи TC \"sendChatMessage()\", а после отправки будет занулять введенный\r\n    текст сообщения в форме.*/\r\n    const addChatMessage = () => {\r\n        if (!chatMessage) return;\r\n        dispatch(sendChatMessage(chatMessage));\r\n        setChatMessage('');\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <div>\r\n                {/*Отрисовываем элемент \"textarea\" для ввода текста сообщения для чата.*/}\r\n                <textarea\r\n                    placeholder={'Enter your message'}\r\n                    /*При изменении этого поля будет вызываться функция \"setChatMessage()\" из хука \"useState()\" выше для\r\n                    получения введенного текста в поле.*/\r\n                    onChange={(e) => setChatMessage(e.currentTarget.value)}\r\n                    /*Используя атрибут \"value\", указываем, что в этом поле отображается текст, введенный нами и\r\n                    прошедший через FLUX-круговорот, благодаря хуку \"useState()\" (то есть текст в поле меняется в ответ\r\n                    на изменения переменной \"chatMessage\", меняющейся функцией \"setChatMessage()\", которая в свою\r\n                    очередь вызывается каждый раз, когда мы что-то меняем в поле для ввода текста).*/\r\n                    value={chatMessage}>\r\n                </textarea>\r\n            </div>\r\n\r\n            <div>\r\n                {/*Отрисовываем элемент \"button\". При нажатии на кнопку будет срабатывать функция \"addChatMessage()\",\r\n                которую мы создали выше, с целью отправки введенного сообщения в WebSocket-канал, и для дальнейшей\r\n                очистки этого текста сообщения после отправки этого сообщения. Также поскольку есть вероятность того,\r\n                что мы попробуем отправить сообщение раньше, чем установится WebSocket-канал, то мы отключаем кнопку на\r\n                случай если этот канал еще не в готовом состоянии для отправки информации по нему.*/}\r\n                <button onClick={addChatMessage} disabled={WSStatus !== 'ready'}>\r\n                    Send\r\n                </button>\r\n            </div>\r\n        </div>\r\n    )\r\n};","import React, {useEffect} from 'react';\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*Импортируем TC \"startGettingChatMessages()\" и \"stopGettingChatMessages()\".*/\r\nimport {startGettingChatMessages, stopGettingChatMessages} from '../../../redux/chat-reducer';\r\n/*Импортируем селектор \"getWSStatus()\".*/\r\nimport {getWSStatus} from '../../../redux/chat-selectors';\r\nimport styles from '../ChatPage.module.css';\r\n/*Импортируем компонент \"ChatMessages\".*/\r\nimport {ChatMessages} from './ChatMessages/ChatMessages';\r\n/*Импортируем компонент \"AddChatMessageForm\".*/\r\nimport {AddChatMessageForm} from './AddChatMessageForm/AddChatMessageForm';\r\n\r\n/*\"Chat\" это функциональный компонент, который создан в виде стрелочной функции. \"Chat\" является компонентом, который\r\nсодержит в себе компоненты, отвечающие за вывод сообщений из чата и формы для добавления сообщения в чат.\r\n\r\nВнутри компонента \"Chat\" используются следующие компоненты:\r\n1. \"ChatMessages\" - компонент, который отображает сообщения чата. Импортирован.\r\n2. \"AddChatMessageForm\" - компонент, который отвечает за отображение формы для добавления сообщения в чат. Импортирован.\r\n\r\nКомпонент \"Chat\" импортируется в файле \"ChatPage.tsx\".*/\r\nexport const Chat: React.FC = () => {\r\n    /*При помощи хука \"useSelector()\", передав в него селектор \"getWSStatus()\", получаем статус готовности\r\n    WebSocket-канала для отправки информации по нему.*/\r\n    const WSStatus = useSelector(getWSStatus);\r\n    const dispatch = useDispatch();\r\n\r\n    /*Используем хук \"useEffect()\", чтобы при отрисовке компонента инициализировать WebSocket-канал и начать получать по\r\n    нему сообщения для чата при помощи TC \"startGettingChatMessages()\".*/\r\n    useEffect(() => {\r\n            dispatch(startGettingChatMessages());\r\n            /*Когда мы выходим из этого компонента, мы должны закрывать WebSocket-канал и останавливать получение\r\n            информации по сообщениям для чата, которые приходят через этот WebSocket-канал, при помощи TC\r\n            \"stopGettingChatMessages()\". Это называется cleanup-функцией.*/\r\n            return () => { dispatch(stopGettingChatMessages()) };\r\n        },\r\n        /*Второй параметр это пустой массив, так как мы хотим, чтобы все, что есть в первом параметре срабатывало только\r\n        один раз после отрисовки компонента.*/\r\n        []\r\n    );\r\n\r\n    return (\r\n        <div>\r\n            {/*Если статус готовности WebSocket-канала для отправки информации по нему равен \"error\", то отрисуются\r\n            элемент \"div\" с сообщением об ошибке вместе с компонентами \"ChatMessages\" и \"AddChatMessageForm\", иначе\r\n            отрисуются только эти два компонента.*/}\r\n            {WSStatus === 'error' && <div className={styles.wsError}>\r\n                Some error occurred. Please refresh the page or check your Internet-connection\r\n            </div>}\r\n\r\n            <>\r\n                <ChatMessages/>\r\n                <AddChatMessageForm/>\r\n            </>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\n/*Импортируем компонент \"Chat\".*/\r\nimport {Chat} from './Chat/Chat';\r\n/*Импортируем созданный нами HOC \"withAuthRedirect()\".*/\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect';\r\n\r\n/*\"ChatPage\" это функциональный компонент, который создан в виде стрелочной функции. \"ChatPage\" является компонентом,\r\nкоторый собирает компоненты для реализации чата в нашем приложении.\r\n\r\nВнутри компонента \"ChatPage\" используются следующие компоненты:\r\n1. \"Chat\" - компонент, который содержит в себе компоненты, отвечающие за вывод сообщений из чата и формы для добавления\r\nсообщения в чат. Импортирован.\r\n\r\nКомпонент \"ChatPage\" оборачивается HOC-ом \"withAuthRedirect()\" в этом же файле.*/\r\nconst ChatPage: React.FC = () => {\r\n    return (\r\n        <div>\r\n            {/*Отрисовываем компонент \"Chat\".*/}\r\n            <Chat/>\r\n        </div>\r\n    )\r\n};\r\n\r\n/*При помощи HOC \"withAuthRedirect()\" оборачиваем компонент \"ChatPage\" и добавляем ему логику по редиректу.\r\n\r\nЭтот компонент экспортируется по default и используется в нашем приложении под именем \"ChatPage\". Компонент\r\n\"ChatPage\" импортируется в файле \"App.tsx\".*/\r\nexport default withAuthRedirect(ChatPage);"],"sourceRoot":""}