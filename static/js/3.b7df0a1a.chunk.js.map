{"version":3,"sources":["components/Profile/ProfileInfo/ProfileInfo.module.css","components/Profile/MyPosts/MyPosts.module.css","components/Profile/MyPosts/Post/Post.module.css","assets/images/profilelogo.jpg","components/Profile/ProfileInfo/ProfileStatus/ProfileStatusWithHooks.tsx","components/Profile/ProfileInfo/ProfileDataReduxEditForm/ProfileDataReduxEditForm.tsx","components/Profile/ProfileInfo/ProfileData/Contact/Contact.tsx","components/Profile/ProfileInfo/ProfileData/ProfileData.tsx","components/Profile/ProfileInfo/ProfileInfo.tsx","components/Profile/MyPosts/Post/Post.tsx","components/Profile/MyPosts/MyPosts.tsx","components/Profile/MyPosts/MyPostsContainer.tsx","components/Profile/Profile.tsx","components/Profile/ProfileContainer.tsx"],"names":["module","exports","ProfileStatusWithHooks","isOwner","updateUserStatus","props","useState","editMode","setEditMode","status","setStatus","useEffect","onDoubleClick","onChange","event","currentTarget","value","onFocus","target","select","autoFocus","onBlur","console","error","ProfileDataReduxEditForm","reduxForm","form","handleSubmit","profile","onSubmit","className","styles","formSummaryError","createField","Input","Object","keys","contacts","map","key","style","contact","type","Textarea","Contact","contactTitle","contactValue","ProfileData","activateEditMode","onClick","fullName","aboutMe","lookingForAJob","lookingForAJobDescription","ProfileInfo","saveUserPhoto","saveProfile","Preloader","profileImage","src","profileLogoSource","alt","descriptionBlock","photos","large","userPhoto","files","length","initialValues","formData","then","Post","avatar","message","likes","item","maxLength10","maxLengthCreator","AddPostReduxForm","required","MyPosts","React","memo","postsData","addPost","postsElements","p","id","likesCount","postsBlock","newPostText","posts","connect","state","profilePage","profileAC","Profile","MyPostsContainer","ProfileContainerNoWraps","userID","this","match","params","authUserID","history","push","getUserProfile","getUserStatus","refreshProfile","prevProps","prevState","Component","compose","auth","withRouter"],"mappings":"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","file":"static/js/3.b7df0a1a.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"descriptionBlock\":\"ProfileInfo_descriptionBlock__1wft1\",\"profileImage\":\"ProfileInfo_profileImage__1RG9q\",\"userPhoto\":\"ProfileInfo_userPhoto__3q1vo\",\"contact\":\"ProfileInfo_contact__2do_T\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"postsBlock\":\"MyPosts_postsBlock__3Trbx\",\"posts\":\"MyPosts_posts__3oCLp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"item\":\"Post_item__2Vzv3\"};","export default __webpack_public_path__ + \"static/media/profilelogo.de89eaed.jpg\";","import React, {useState, useEffect, ChangeEvent} from 'react';\r\n\r\ntype PropsType = {\r\n    /*Данные статуса пользователя, полученные с сервера, должны быть строкой или иметь тип null, то есть быть пустыми.*/\r\n    status: string | null\r\n    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент\r\n    отображается на странице профиля, должно быть булева типа.*/\r\n    isOwner: boolean\r\n    /*TC для изменения данных по статусу пользователя на странице профиля должен быть функцией, которая принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n    updateUserStatus: (status: string) => void\r\n};\r\n\r\n/*\"ProfileStatusWithHooks\" это функциональный компонент, который создан в виде стрелочной функции.\r\n\"ProfileStatusWithHooks\" является компонентом, который предоставляет реализацию статуса пользователя на странице\r\nпользователя. Статус пользователя представляет собой поле статуса как в ВК, на который можно нажать и активировать поле\r\nдля ввода статуса, а если убрать фокус с этого поля, то будет просто текст.\r\n\r\nКомпонент \"ProfileStatusWithHooks\" импортируется в файле \"ProfileInfo.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"isOwner\" - свойство, показывающее является ли залогиненный пользователь владельцем профиля.\r\n2. \"updateUserStatus\" - TC для изменения данных по статусу пользователя на странице профиля.\r\n\r\nНе указываем здесь свойства \"status\", а при помощи деструктуризации \"...props\" прокидываем это свойство в этот\r\nкомпонент, так как в самом компоненте уже используется своя переменная с именем \"status\".*/\r\nexport const ProfileStatusWithHooks: React.FC<PropsType> = ({isOwner, updateUserStatus, ...props}) => {\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать включен или выключен режим редактирования статуса\r\n    (изначально false). Вторая переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый\r\n    элемент (то есть включать или выключать режим редактирования статуса).*/\r\n    const [editMode, setEditMode] = useState(false);\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет хранить значение статуса (изначально берется из props). Вторая\r\n    переменная будет хранить функцию из хука \"useState()\", которая будет изменять первый элемент (то есть редактировать\r\n    статус).*/\r\n    const [status, setStatus] = useState(props.status);\r\n\r\n    /*Поскольку хук \"useState()\" содержит массив с двумя элементами, то аналог мог бы быть следующим*/\r\n    // const stateWithSetState = useState(false);\r\n    // const editMode = stateWithSetState[0];\r\n    // const setEditMode = stateWithSetState[1];\r\n\r\n    /*Используем хук \"useEffect()\", чтобы избежать бага, когда не успевал загружаться статус с сервера во время первого\r\n    редактирования после загрузки компонента. Когда после загрузки страницы мы входили в режим редактирования статуса,\r\n    то поле было пустым, так как локальный \"status\", созданный при помощи хука \"useState()\", был пустым, поскольку\r\n    иногда компонент загружался раньше, чем получался статус с сервера. То есть отображалось пустое поле, так как\r\n    изначально это пустое поле указано в статусе в нашем BLL. И это пустое поле подхватывалось нашим \"status\" раньше\r\n    данных о статусе, полученных из запроса на сервер. Поэтому сейчас мы отслеживаем изменения статуса в глобальном\r\n    state и при каждом таком изменении вызываем функцию \"setStatus()\", то есть теперь получение запоздавших данных о\r\n    статусе с сервера будет триггерить изменение локального \"status\".*/\r\n\r\n    useEffect(\r\n        /*Первый параметр это функция для редактирования статуса при помощи хука \"useState()\".*/\r\n        () => { setStatus(props.status) },\r\n        /*Второй параметр это значение статуса из глобального state. Если это значение будет меняться, то будет\r\n        срабатывать каждый раз функция из первого параметра.*/\r\n        [props.status]\r\n    );\r\n\r\n    /*Создаем функцию, которая при вызове активирует режим редактирования статуса.*/\r\n    const activateEditMode = () => { setEditMode(true); };\r\n\r\n    /*Создаем функцию, которая при вызове деактивирует режим редактирования статуса и обновляет значение статуса в\r\n    глобальном state при помощи TC \"updateUserStatus()\" для изменения статуса пользователя на странице профиля.*/\r\n    const deactivateEditMode = () => {\r\n        setEditMode(false);\r\n\r\n        /*Здесь делаем дополнительную проверку на наличие статуса для целей типизации.*/\r\n        if (status) {\r\n            updateUserStatus(status);\r\n        } else {\r\n            /*Если же статус отсутствует, то выводим ошибку в консоль.*/\r\n            console.error('Status should exist');\r\n        }\r\n    };\r\n\r\n    /*Создаем специальную функцию \"onUserStatusChange()\", которая будет вызываться при изменении поля \"input\", брать\r\n    текущее значение содержимого этого поля и сохранять его в локальный state при помощи хука \"useState()\". Для события\r\n    \"event\" указываем тип \"ChangeEvent<HTMLInputElement>\"*/\r\n    const onUserStatusChange = (event: ChangeEvent<HTMLInputElement>) => { setStatus(event.currentTarget.value) };\r\n    /*Создаем специальную функцию \"handleFocus()\" для автоматического выделения текста в поле статуса пользователя. Для\r\n    события \"event\" указали тип \"ChangeEvent<HTMLInputElement>\"*/\r\n    const handleFocus = (event: ChangeEvent<HTMLInputElement>) => { event.target.select() };\r\n\r\n    return (\r\n        <div>\r\n            {/*Если режим редактирования статуса пользователя отключен и мы являемся владельцем страницы, то отрисуется\r\n            элемент \"div\", внутри которого будет элемент \"span\", содержащий обработчик события \"onDoubleClick\" -\r\n            двойного нажатия по элементу. При срабатывании этого события активируется callback-функция\r\n            \"activateEditMode()\", чтобы активировать режим редактирования статуса пользователя. Внутри элемента \"span\"\r\n            будет отображаться текущее значение статуса пользователя из props, а при его отсутствии будет надпись \"Enter\r\n            your status\". Если мы же не являемся владельцем профиля, то мы не сможем перейти в режим редактирования,\r\n            только увидеть сам статус. Здесь есть небольшая проблема - после ввода нового статуса какое-то время будет\r\n            отображен старый статус, пока не завершится запрос на сервер на изменение этого статуса. Одним из вариантов\r\n            решений этой проблемы может быть добавление компонента-заглушки \"Preloader\" на время пока идет запрос.*/}\r\n            {!editMode &&\r\n                <div>\r\n                    {isOwner\r\n                        ? <div><b>Status</b>: <span\r\n                            onDoubleClick={activateEditMode}>{props.status || 'Enter your status'}</span></div>\r\n                        : <span>{props.status || ''}</span>\r\n                    }\r\n                </div>\r\n            }\r\n\r\n            {/*Если режим редактирования статуса пользователя включен, то отрисуется элемент \"div\", внутри которого\r\n            будет элемент \"input\", содержащий обработчик события \"onBlur\" - потери фокуса с элемента . При срабатывании\r\n            этого события активируется callback-функция \"deactivateEditMode()\", чтобы деактивировать режим\r\n            редактирования статуса пользователя и сохранить новый статус в глобальном state. Также у элемента \"input\"\r\n            указан атрибут \"autoFocus\" для автоматического фокуса на элементе. Внутри элемента \"input\" благодаря\r\n            атрибуту \"value\" из локального state при помощи хука \"useState()\" будет отображаться текущее значение\r\n            статуса пользователя. Также внутри элемента \"input\" содержится обработчик события \"onFocus\" - появления\r\n            фокуса на элементе, при срабатывании которого активируется callback-функция \"handleFocus()\", чтобы\r\n            автоматически выделить текст статуса пользователя. Еще внутри элемента \"input\" содержится обработчик события\r\n            \"onChange\" - изменения поля \"input\", при срабатывании которого активируется callback-функция\r\n            \"onUserStatusChange()\", чтобы брать текущее значение содержимого этого поля и сохранять его в локальный\r\n            state при помощи хука \"useState()\".*/}\r\n            {editMode &&\r\n                <div>\r\n                    <input onChange={onUserStatusChange}\r\n                           onFocus={handleFocus}\r\n                           autoFocus={true}\r\n                           onBlur={deactivateEditMode}\r\n                        /*Поскольку в нашей типизации указано, что статус может быть null, то тут нам пришлось\r\n                        указать, чтобы он всегда воспринимался как строка при помощи \"as string\".*/\r\n                           value={status as string}/>\r\n                </div>\r\n            }\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*В данном файле работа с библиотекой Redux Form происходит следующим образом:\r\n1. callback-функция \"handleSubmit()\" указана в компоненте \"ProfileDataEditForm\".\r\n2. оборачиваем компонент \"ProfileDataEditForm\" функцией \"reduxForm()\" в компоненте \"ProfileDataReduxEditForm\", тем самым\r\nпредоставляя callback-функцию \"handleSubmit()\" для компонента \"ProfileDataEditForm\".\r\n3. компонент \"ProfileDataReduxEditForm\" указывается в компоненте \"ProfileInfo\" в файле \"ProfileInfo.tsx\", куда в событие\r\n\"onSubmit\" будет попадать объект с данными, сформированный в событии \"onSubmit\" при помощи callback-функции\r\n\"handleSubmit()\" в компоненте \"ProfileDataEditForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback-функция \"handleSubmit()\" в компоненте\r\n\"ProfileDataEditForm\", которая собирает все данные из формы и помещает их в объект. Потом внутри callback-функции\r\n\"handleSubmit()\" вызывается нами созданная callback-функция \"onSubmit()\" (доступна из контейнерного компонента\r\n\"ProfileDataReduxEditForm\") из компонента \"ProfileInfo\" в файле \"ProfileInfo.tsx\". В компонент \"ProfileInfo\" в файле\r\n\"ProfileInfo.tsx\" передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в\r\nкомпонент \"ProfileDataReduxEditForm\", из которого перенаправляются в глобальный state в виде объекта под именем\r\n\"editProfile\".\r\n\r\nВ компонент \"ProfileDataEditForm\" внедряются некие дополнительные props (например, та же callback-функция\r\n\"handleSubmit()\") ХОКом, который образуется при помощи компонента \"ProfileDataReduxEditForm\". Эти props содержатся под\r\nименем \"InjectedFormProps\". Эти \"InjectedFormProps\" также содержат добавленные нами props. Поэтому мы импортировали\r\n\"InjectedFormProps\" из библиотеки Redux Form, чтобы типизировать такие props в компоненте \"ProfileDataEditForm\".*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\nimport style from '../ProfileInfo.module.css';\r\nimport styles from '../../../common/FormsControls/FormsControls.module.css';\r\n/*Импортируем созданный нами компонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию.\r\nТакже импортируем созданный нами компонент \"Input\" для создания элемента \"input\" с возможностью указывать валидацию.\r\nТакже импортируем функцию \"createField()\", которая принимает параметры и создает элементы формы. Мы ее используем для\r\nсоздания формы в компоненте \"ProfileDataEditForm\". Дополнительно импортируем оттуда тип \"GetValuesKeysType\".*/\r\nimport {createField, GetValuesKeysType, Input, Textarea} from '../../../common/FormsControls/FormsControls';\r\n/*Импортируем тип \"ProfileType\".*/\r\nimport {ProfileType} from '../../../../types/types';\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"ProfileDataEditForm\".*/\r\ntype ProfileDataEditFormOwnPropsType = {\r\n    /*Информация о профиле пользователя, полученная с сервера должна быть типа \"PostType\" или иметь тип null, то есть\r\n    быть пустой. Тип \"PostType\" был создан нами и импортирован сюда. Не указываем здесь any или пустой объект, так как\r\n    сверху этому компоненту приходит \"profile\" из компонента \"ProfileInfo\" из файла \"ProfileInfo.tsx\".*/\r\n    profile: ProfileType\r\n};\r\n\r\n/*Создаем тип для props компонента \"ProfileDataEditForm\", которые будут использоваться в \"formData\" для компонента\r\n\"ProfileInfo\" в файле \"ProfileInfo.tsx\". В \"formData\" находятся данные по пользователю в виде объекта с типом\r\n\"ProfileType\".*/\r\nexport type ProfileDataEditFormValuesType = ProfileType;\r\n\r\n/*Следующий тип мы создаем специально, чтобы мы не могли допустить ошибок при указании свойства \"name\" в функции\r\n\"createField()\". Это свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы\r\nиспользуем созданный нами и импортированный сюда вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже\r\nперечислены в типе \"ProfileDataEditFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы\r\nключей из типа \"ProfileDataEditFormValuesType\".*/\r\ntype ProfileDataEditFormValuesKeysType = GetValuesKeysType<ProfileDataEditFormValuesType>;\r\n\r\n/*\"ProfileDataEditForm\" это функциональный компонент, который создан в виде стрелочной функции. \"ProfileDataEditForm\"\r\nявляется компонентом, который представляет собой форму для редактирования профиля пользователя на странице профиля в\r\nвиде заготовки для оборачивания ее функцией \"reduxForm()\".\r\n\r\nВнутри компонента \"ProfileDataEditForm\" используются следующие компоненты:\r\n1. \"Input\" - компонент, который используется для отрисовки элементов \"input\" в других местах, где в таких элементах\r\nтребуется валидация. Импортирован.\r\n2. \"Textarea\" - компонент, который используется для отрисовки элементов \"textarea\" в других местах, где в таких\r\nэлементах требуется валидация. Импортирован.\r\n\r\nКомпонент \"ProfileDataEditForm\" используется в компоненте \"ProfileDataReduxEditForm\" в этом же файле и оборачивается\r\nфункцией \"reduxForm()\", тем самым получая callback-функцию \"handleSubmit()\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"handleSubmit\" - callback-функция \"handleSubmit()\".\r\n2. \"profile\" - Данные профиля пользователя для страницы профиля.\r\n3. \"error\" - Свойство, содержащее текст ошибки (если была). Свойство \"error\" будет в объекте props благодаря библиотеке\r\nRedux Form, в него подцепится значение из TC \"saveProfile()\".\r\n\r\nУказываем при помощи \"React.FC<>\", что props в этом функциональном компоненте имеют тип\r\n\"InjectedFormProps<ProfileDataEditFormValuesType, ProfileDataEditFormOwnPropsType> & ProfileDataEditFormOwnPropsType>\".\r\n\r\nТакая комбинация получилась следующим образом:\r\n1. \"InjectedFormProps<ProfileDataEditFormValuesType, ProfileDataEditFormOwnPropsType>\" - здесь мы уточняем внедренные\r\nХОКом, который образуется при помощи компонента \"ProfileDataReduxEditForm\", \"InjectedFormProps\".\r\n\"ProfileDataEditFormValuesType\" указывает, что приходит из этого ХОКа, а \"ProfileDataEditFormOwnPropsType\" указывает,\r\nчто приходит со стороны - \"profile\".\r\n2. \"& ProfileDataEditFormOwnPropsType\" - также этот компонент содержит некие свои \"собственные props\", которые не\r\nприходят от ХОКа выше - тот же \"profile\".\r\n\r\nЭто мы делаем на основании файла декларации \"InjectedFormProps\". Там указано, что первым параметром принимаются\r\n\"formData\" - то есть какие именно данные собирает форма в компоненте, оборачиваемый функцией \"reduxForm()\" (то есть\r\nкомпонент \"ProfileDataEditForm\"), и \"собственные props\" этого компонента \"ProfileDataEditForm\", непреходящие от ХОКа\r\nвыше (так нужно для внутренней работы \"InjectedFormProps\"). А вторым параметром принимаются еще раз некие свои\r\n\"собственные props\", которые не приходят от ХОКа выше (так уже надо для работы самого этого компонента\r\n\"ProfileDataEditForm\"). Третьим параметром принимается вид ошибки формы с типом строки, но в данном случае мы этого не\r\nуказываем.\r\n\r\nТолько все эти три параметра указываются как бы вместе как единый параметр, а не через запятую как три разных параметра.\r\nВОЗМОЖНО, это потому, что \"InjectedFormProps\" является объектом (как единое целое состоит из разных свойств, которые\r\nможно типизировать суммой разных типов), а та же функция \"reduxForm()\" является функцией (принимает последовательность\r\nпараметров, где каждый параметр нужно отдельно типизировать).*/\r\nconst ProfileDataEditForm:\r\n    React.FC<InjectedFormProps<ProfileDataEditFormValuesType, ProfileDataEditFormOwnPropsType>\r\n        & ProfileDataEditFormOwnPropsType> = ({handleSubmit, profile, error}) => {\r\n    return (\r\n        /*Здесь в элементе \"form\" в событии \"onSubmit\" указываем callback-функцию \"handleSubmit()\".*/\r\n        <form onSubmit={handleSubmit}>\r\n            {/*Создаем специальный элемент \"div\", внутри которого будет находиться элемент \"button\", используемы как\r\n            кнопка для сабмита данных введенных в форму.*/}\r\n            <div>\r\n                <button>save</button>\r\n            </div>\r\n\r\n            {/*Если произошла какая-то ошибка, то выведем ее в отдельном элементе \"div\". Свойство \"error\" будет в\r\n            объекте props благодаря библиотеке Redux Form, в него подцепится значение из TC \"saveProfile()\".*/}\r\n            {error && <div className={styles.formSummaryError}>{error}</div>}\r\n\r\n            {/*Этот элемент \"div\" содержит поле для ввода полного имени пользователя.*/}\r\n            <div>\r\n                <b>1. Full Name</b>:\r\n                {/*Создаем поле для ввода полного имени пользователя на основе импортированной функции \"createField()\".\r\n                Уточняем здесь функцию \"createField()\", что она имеет тип \"ProfileDataEditFormValuesKeysType\", созданный\r\n                нами выше.*/}\r\n                {createField<ProfileDataEditFormValuesKeysType>(\r\n                    'Full Name',\r\n                    'fullName',\r\n                    Input,\r\n                    []\r\n                )}\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит поле для ввода информации о пользователе \"Обо мне\".*/}\r\n            <div>\r\n                <b>2. About Me</b>:\r\n                {/*Создали поле для ввода информации о пользователе \"Обо мне\" на основе импортированной функции\r\n                \"createField()\".*/}\r\n                {createField<ProfileDataEditFormValuesKeysType>(\r\n                    'About Me',\r\n                    'aboutMe',\r\n                    Input,\r\n                    []\r\n                )}\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит поля для ввода контактов пользователя. Создаются эти поля аналогично как это\r\n            делается в компоненте \"ProfileData\" из файла \"ProfileData.tsx\". При помощи метода \"keys()\" глобального\r\n            объекта \"Object\" мы можем проитерироваться по ключам переданного объекта \"profile.contacts\". Возьмутся все\r\n            ключи \"key\" и завернутся в массив строк. А далее мы мапим этот массив, чтобы отрисовать JSX с однотипным\r\n            полями контактов при помощи небольшого куска JSX (в компоненте \"ProfileData\" из файла \"ProfileData.tsx\" для\r\n            такого JSX мы создавали вспомогательную компоненту \"Contact\" в файле \"Contact.tsx\").*/}\r\n            <div>\r\n                <b>3. Contacts</b>: {Object\r\n                .keys(profile.contacts)\r\n                .map(key => {\r\n                    return (\r\n                        /*Отрисовываем элемент \"div\", который представляет собой типовое поле для указания контакта.*/\r\n                        <div key={key} className={style.contact}>\r\n                            {/*Внутри этот элемент \"div\" будет представлять собой следующее:\r\n                            \"Текст заголовка поля контакта\": \"Текст со значением самого контакта\". Первое будет браться\r\n                            из ключа \"key\". Второе будет создаваться на основе импортированной функции \"createField()\".\r\n                            \"name\" во втором будет получаться так: к тексту \"contacts.\" будет прибавляться текст ключа\r\n                            (например, \"github\"), что в итоге будет давать правильную структуру контактов (например,\r\n                            \"contacts.github\") для составления объекта с контактами, который сможет понять сервер при\r\n                            получении объекта с данным по профилю пользователя. Здесь отсутствует уточнение типа у\r\n                            функции \"createField()\", поэтому в дальнейшем его необходимо добавить здесь.*/}\r\n                            <b>{key}: {createField(\r\n                                key,\r\n                                'contacts.' + key,\r\n                                Input,\r\n                                []\r\n                            )}</b>\r\n                        </div>\r\n                    )\r\n                })}\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит поле для указания ищет ли в данный момент работу пользователь.*/}\r\n            <div>\r\n                <b>4. Is looking for a job?</b>\r\n                {/*Создаем поле для указания ищет ли в данный момент работу пользователь на основе импортированной\r\n                функции \"createField()\".*/}\r\n                {createField<ProfileDataEditFormValuesKeysType>(\r\n                    '',\r\n                    'lookingForAJob',\r\n                    Input,\r\n                    [],\r\n                    {type: 'checkbox'}\r\n                )}\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит поле для ввода работы, которую ищет пользователь.*/}\r\n            <div>\r\n                <b>Which one?</b>\r\n                {/*Создали поле для ввода работы, которую ищет пользователь, на основе импортированной функции\r\n                \"createField()\".*/}\r\n                {createField<ProfileDataEditFormValuesKeysType>(\r\n                    'Which one?',\r\n                    'lookingForAJobDescription',\r\n                    Textarea,\r\n                    []\r\n                )}\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n/*Компонент \"ProfileDataReduxEditForm\" является отдельным контейнерным компонентом, цель которого в этом же файле\r\nобернуть компонент \"ProfileDataEditForm\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\".\r\nИменно компонент \"ProfileDataReduxEditForm\" будет заниматься общением с глобальным state.\r\n\r\nВнутри компонента \"ProfileDataReduxEditForm\" используются следующие компоненты:\r\n1. \"ProfileDataEditForm\" - компонент, который представляет собой форму для редактирования профиля пользователя на\r\nстранице профиля в виде заготовки для оборачивания ее функцией \"reduxForm()\". Из этого же файла.\r\n\r\nКомпонент \"ProfileDataReduxEditForm\" импортируется в файле \"ProfileInfo.tsx\" и используется в компоненте \"ProfileInfo\".\r\n\r\nФункция \"reduxForm()\" является generic, поэтому мы ее уточняем. В файле декларации функции \"reduxForm()\" указано, что он\r\nпринимает следующие данные:\r\n1. \"formData\" - какие именно данные собирает форма в компоненте (то есть в компоненте \"ProfileDataEditForm\"),\r\nоборачиваемым функцией \"reduxForm()\";\r\n2. \"собственные props\" компонента (то есть компонента \"ProfileDataEditForm\"), которого оборачиваем функцией\r\n\"reduxForm()\";\r\n3. вид ошибки формы с типом строки, но в данном случае мы этого не указываем.*/\r\nexport const ProfileDataReduxEditForm = reduxForm<ProfileDataEditFormValuesType, ProfileDataEditFormOwnPropsType>({\r\n    /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный state.*/\r\n    form: 'editProfile'\r\n})(ProfileDataEditForm);","import React from 'react';\r\nimport styles from '../../ProfileInfo.module.css';\r\n\r\n/*Создаем тип для props компонента \"ContactPropsType\".*/\r\ntype ContactPropsType = {\r\n    /*Текст заголовка контакта должен быть строкой.*/\r\n    contactTitle: string\r\n    /*Значение контакта должен быть строкой.*/\r\n    contactValue: string\r\n};\r\n\r\n/*\"Contact\" это функциональный компонент, который создан в виде стрелочной функции. \"Contact\" является компонентом,\r\nкоторый содержит заготовку для полей контактов пользователя, используемых в маппинге для отрисовки однотипного JSX.\r\n\r\nКомпонент \"Contact\" импортируется в файле \"ProfileData.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"contactTitle\" - текст заголовка контакта.\r\n2. \"contactValue\" - значение контакта.*/\r\nexport const Contact: React.FC<ContactPropsType> = ({contactTitle, contactValue}) => {\r\n    /*Внутри этого элемента \"div\" будет следующее отображение:\r\n    \"Текст заголовка поля контакта\": \"Текст со значением самого контакта\".*/\r\n    return <div className={styles.contact}><b>{contactTitle}</b>: {contactValue}</div>\r\n};","import React from 'react';\r\n/*Импортируем компонент \"Contact\".*/\r\nimport {Contact} from './Contact/Contact';\r\n/*Импортируем типы \"ContactsType\" и \"ProfileType\".*/\r\nimport {ContactsType, ProfileType} from '../../../../types/types';\r\n\r\n/*Создаем тип для props компонента \"ProfileData\".*/\r\ntype ProfileDataPropsType = {\r\n    /*Информация о профиле пользователя, полученная с сервера должна быть типа \"ProfileType\" или иметь тип null, то есть\r\n    быть пустой.*/\r\n    profile: ProfileType\r\n    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент\r\n    отображается на странице профиля, должно быть булева типа.*/\r\n    isOwner: boolean\r\n    /*Функция, при вызове активирующая режим редактирования профиля пользователя, должна быть функцией, которая ничего\r\n    не принимает и не возвращает. Это функция создается в компоненте \"ProfileInfo\" и передается в компонент\r\n    \"ProfileData\".*/\r\n    activateEditMode: () => void\r\n};\r\n\r\n/*\"ProfileData\" это функциональный компонент, который создан в виде стрелочной функции. \"ProfileData\" является\r\nкомпонентом, который занимается отображением данных профиля пользователя и содержит интерфейс для перехода в режим\r\nредактирования этой информации.\r\n\r\nВнутри компонента \"ProfileData\" используются следующие компоненты:\r\n1. \"Contact\" - компонент, который содержит заготовку для полей контактов пользователя, используемых в маппинге для\r\nотрисовки однотипного JSX. Импортирован.\r\n\r\nКомпонент \"ProfileData\" импортируется в файле \"ProfileInfo.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"profile\" - данные профиля пользователя для страницы профиля.\r\n2. \"isOwner\" - свойство, показывающее является ли залогиненный пользователь владельцем профиля, в данный момент\r\nотображаемый на странице профиля.\r\n3. \"activateEditMode\" - функция, которая при вызове активирует режим редактирования профиля пользователя.*/\r\nexport const ProfileData: React.FC<ProfileDataPropsType> = ({profile, isOwner, activateEditMode}) => {\r\n    return (\r\n        <div>\r\n            {/*Если пользователь является владельцем открытого профиля, то отображаем элемент \"div\", внутри которого\r\n            есть элемент \"button\", для отображения кнопки перехода в режим редактирования данных профиля, для чего\r\n            указана callback-функция \"activateEditMode()\" на событии при нажатии.*/}\r\n            {isOwner && <div>\r\n                <button onClick={activateEditMode}>Edit</button>\r\n            </div>}\r\n\r\n            {/*Этот элемент \"div\" содержит полное имя пользователя, которое берется из props.*/}\r\n            <div><b>1. Full Name</b>: {profile.fullName}</div>\r\n\r\n            {/*Этот элемент \"div\" содержит информацию о пользователе \"Обо мне\", которая берется из props.*/}\r\n            <div><b>2. About Me</b>: {profile.aboutMe}</div>\r\n\r\n            {/*Этот элемент \"div\" содержит контакты пользователя, которые берутся из props. Создаются следующим\r\n            образом. При помощи метода \"keys()\" глобального объекта \"Object\" мы можем проитерироваться по ключам\r\n            переданного объекта \"profile.contacts\". Возьмутся все ключи \"key\" и завернутся в массив строк. А далее мы\r\n            мапим этот массив, чтобы отрисовать однотипный JSX с полями контактов при помощи компонента \"Contact\".*/}\r\n            <div>\r\n                <b>3. Contacts</b>: {\r\n                Object\r\n                    .keys(profile.contacts)\r\n                    .map(key => {\r\n                        return <Contact\r\n                            key={key}\r\n                            /*Заголовок поля контакта.*/\r\n                            contactTitle={key}\r\n                            /*Значение поля контакта в соответствии с заголовком. Здесь указываем\r\n                            \"as keyof ContactsType\", чтобы TypeScript понял, что это данные из свойств типа\r\n                            \"ContactsType\".*/\r\n                            contactValue={profile.contacts[key as keyof ContactsType]}\r\n                        />\r\n                    })\r\n            }\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит информацию о том ищет ли в данный момент работу пользователь. Если свойство\r\n            \"lookingForAJob\", которое берется из props, является true, то отрисуется элемент \"span\" с текстом \"Yes\",\r\n            иначе отрисуется элемент \"span\" с текстом \"No\".*/}\r\n            <div><b>4. Is looking for a job?</b> {profile.lookingForAJob ? <span>Yes</span> : <span>No</span>}</div>\r\n\r\n            {/*Если свойство \"lookingForAJob\" из props, является true, то отрисуется элемент \"div\" с текстом из свойства\r\n            \"lookingForAJobDescription\", означающее работу, которую ищет пользователь.*/}\r\n            {profile.lookingForAJob && <div><b>Which one?</b> {profile.lookingForAJobDescription}</div>}\r\n        </div>\r\n    )\r\n};","import styles from './ProfileInfo.module.css';\r\n/*Импортируем из ассетов аватар на случай, если у пользователя нет фото.*/\r\nimport userPhoto from '../../../assets/images/user.png';\r\n/*Импортируем из ассетов лого для страницы профиля.*/\r\nimport profileLogoSource from '../../../assets/images/profilelogo.jpg';\r\n/*Импортируем компонент \"Preloader\".*/\r\nimport {Preloader} from '../../common/Preloader/Preloader';\r\n/*Импортируем компонент \"ProfileStatusWithHooks\". Является аналогом компонента \"ProfileStatus\", сделанного без хуков.*/\r\nimport {ProfileStatusWithHooks} from './ProfileStatus/ProfileStatusWithHooks';\r\n/*Импортируем компонент \"ProfileStatus\". Является аналогом компонента \"ProfileStatusWithHooks\", сделанного на хуках. На\r\nданный момент компонент \"ProfileStatus\" не работает корректно.*/\r\nimport {ProfileStatus} from './ProfileStatus/ProfileStatus';\r\n/*Импортируем компонент \"ProfileDataReduxEditForm\" и тип \"ProfileDataFormValuesType\".*/\r\nimport {\r\n    ProfileDataEditFormValuesType,\r\n    ProfileDataReduxEditForm\r\n} from './ProfileDataReduxEditForm/ProfileDataReduxEditForm';\r\n/*Импортируем компонент \"ProfileData\".*/\r\nimport {ProfileData} from './ProfileData/ProfileData';\r\n/*Импортируем \"ChangeEvent\" для типизации событий.*/\r\nimport React, {ChangeEvent, useState} from 'react';\r\n/*Импортируем тип \"ProfileType\".*/\r\nimport {ProfileType} from '../../../types/types';\r\n\r\n/*Создаем общий тип для всех props компонента \"ProfileInfo\". Все это нужно для указания типа props в функциональном\r\nкомпоненте \"ProfileInfo\".*/\r\ntype ProfileInfoPropsType = {\r\n    /*Информация о профиле пользователя, полученная с сервера должна быть типа \"ProfileType\" или иметь тип null, то есть\r\n    быть пустой.*/\r\n    profile: ProfileType | null\r\n    /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип null, то есть быть пустыми.*/\r\n    status: string | null\r\n    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент\r\n    отображается на странице профиля, должно быть булева типа.*/\r\n    isOwner: boolean\r\n    /*TC для изменения данных по статусу пользователя на странице профиля должен быть функцией, которая принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n    updateUserStatus: (status: string) => void\r\n    /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении должен быть\r\n    функцией, принимающей объект с фото пользователя, которое имеет тип \"File\" из TypeScript и ничего не возвращает.*/\r\n    saveUserPhoto: (photoFile: File) => void\r\n    /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем\r\n    приложении должен быть функцией, которая принимает объект типа \"ProfileType\" и возвращает какой-либо промис, так как\r\n    мы здесь используем метод \"then()\" вместе с этим TC.*/\r\n    saveProfile: (profile: ProfileType) => Promise<any>\r\n};\r\n\r\n/*\"ProfileInfo\" это функциональный компонент, который создан в виде стрелочной функции. \"ProfileInfo\" является\r\nкомпонентом, который содержит информацию о пользователе.\r\n\r\nВнутри компонента \"ProfileInfo\" используются следующие компоненты:\r\n1. \"Preloader\" - компонент-заглушкой, который используется, чтобы воспроизводить анимацию загрузки в других компонентах,\r\nпока идет какой-то фоновой процесс (например, AJAX-запрос). Импортирован.\r\n2. \"ProfileStatusWithHooks\" - компонент, который предоставляет реализацию статуса пользователя на странице пользователя.\r\nРаботает на хуках. Импортирован.\r\n3. \"ProfileStatus\" - компонент, который предоставляет реализацию статуса пользователя на странице пользователя. Работает\r\nне на хуках. На данный момент не работает корректно и не используется (используем компонент \"ProfileStatusWithHooks\").\r\nИмпортирован.\r\n4. \"ProfileDataReduxEditForm\" - контейнерный компонентом, цель которого обернуть компонент \"ProfileDataEditForm\" в файле\r\n\"ProfileDataReduxEditForm.tsx\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\".\r\nИмпортирован.\r\n5. \"ProfileData\" - компонент, который занимается отображением данных профиля пользователя и содержит интерфейс для\r\nперехода в режим редактирования этой информации. Импортирован.\r\n\r\nКомпонент \"ProfileInfo\" импортируется в файле \"Profile.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"isOwner\" - свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент\r\nотображается на странице профиля.\r\n2. \"profile\" - данные профиля пользователя для страницы профиля.\r\n3. \"status\" - данные статуса пользователя для страницы профиля.\r\n4. \"updateUserStatus\" - TC для изменения статуса пользователя на странице профиля.\r\n5. \"saveUserPhoto\" - TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем\r\nприложении.\r\n6. \"saveProfile\" - TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в\r\nнашем приложении.*/\r\nexport const ProfileInfo: React.FC<ProfileInfoPropsType> = ({\r\n                                                                isOwner,\r\n                                                                profile,\r\n                                                                status,\r\n                                                                updateUserStatus,\r\n                                                                saveUserPhoto,\r\n                                                                saveProfile\r\n                                                            }) => {\r\n    /*При помощи деструктуризирующего присваивания создаем две переменные. Первая переменная будет хранить первый\r\n    элемент из хука \"useState()\", этот элемент будет означать включен или выключен режим редактирования профиля\r\n    пользователя (изначально false). Вторая переменная будет хранить функцию из хука \"useState()\", которая будет\r\n    изменять первый элемент (то есть включать или выключать режим редактирования профиля пользователя).*/\r\n    const [editMode, setEditMode] = useState(false);\r\n    /*Создаем функцию, которая при вызове активирует режим редактирования профиля пользователя.*/\r\n    const activateEditMode = () => { setEditMode(true) };\r\n    /*Если данные профиля пользователя отсутствуют, то отрисовываем компонент-заглушку \"Preloader\".*/\r\n    if (!profile) return <Preloader/>;\r\n    /*Создаем функцию, которая при вызове сначала проверяет, что массив файлов с фото пользователя не пустой, и если он\r\n    не пустой, то потом отправляет первый файл из этого массива в TC \"saveUserPhoto()\" для загрузки фото пользователя на\r\n    сервер и дальнейшего его отображения в нашем приложении. Эта функция будет срабатывать как callback-функция, когда\r\n    пользователь выбирает изображение. Для события \"event\" указали тип \"ChangeEvent<HTMLInputElement>\".*/\r\n    const onUserPhotoSelected = (event: ChangeEvent<HTMLInputElement>) => {\r\n        /*Здесь указали \"?\", чтобы не было ошибки связанной с типизацией, поскольку \"files\" может не быть. Вместо этого\r\n        можно было написать так \"if (event.target.files && event.target.files.length)\", такая проверка тоже бы\r\n        удовлетворила TypeScript.*/\r\n        if (event.target.files?.length) saveUserPhoto(event.target.files[0]);\r\n    };\r\n\r\n    /*Создаем callback-функцию, которая при вызове совершает сабмит данных, то есть собирает данные формы и вызывает TC\r\n    \"saveProfile()\" для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в\r\n    нашем приложении, передав ему эти данные. Далее идет ожидание промиса. При успешном выполнении промиса\r\n    деактивируется режим редактирования профиля пользователя. Если от сервера придет ошибка, то промис будет отклонен и\r\n    режим редактирования профиля пользователя не будет деактивирован (так работает этот TC \"saveProfile()\"). Если здесь\r\n    использовать ключевые слова async/await вместо ключевого then, то работать не будет.\r\n\r\n    Эта callback-функция получает указанные данные на входе в объекте \"formData\" с типом \"ProfileDataFormValuesType\".\r\n    Стоит здесь также отметить, что такое использование ключевого слова then в компонентах не желательно, поэтому в\r\n    дальнейшем нужно найти другое решение.*/\r\n    const onSubmit = (formData: ProfileDataEditFormValuesType) => {\r\n        saveProfile(formData).then(() => { setEditMode(false) });\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            {/*Этот элемент \"div\" содержит изображение из шапки страницы профиля.*/}\r\n            <div className={styles.profileImage}>\r\n                {/*Отрисовываем элемент \"img\", который содержит изображение из шапки страницы профиля.*/}\r\n                <img src={profileLogoSource} alt=''/>\r\n            </div>\r\n\r\n            {/*Этот элемент \"div\" содержит данные профиля пользователя на странице профиля.*/}\r\n            <div className={styles.descriptionBlock}>\r\n                {/*Отрисовываем элемент \"img\", в котором будет отображаться фото пользователя, а если данных по фото\r\n                пользователя от сервера получено не было, то отобразится аватар из ассетов проекта.*/}\r\n                <img src={profile.photos.large || userPhoto} className={styles.userPhoto} alt=''/>\r\n\r\n                {/*Если пользователь является владельцем открытого в данным момент профиля, то отрисуется элемент\r\n                \"input\" с атрибутом \"type\" равным \"file\", что позволит загрузить файл. Так этот элемент \"input\" будет\r\n                содержать callback-функцию \"onUserPhotoSelected()\", которая будет срабатывать при событии \"onChange\",\r\n                которая будет загружать фото пользователя.*/}\r\n                {isOwner && <input type={'file'} onChange={onUserPhotoSelected}/>}\r\n\r\n                {/*Отрисовываем компонент \"ProfileStatusWithHooks\" и передаем ему через props необходимые для его работы\r\n                данные.*/}\r\n                <ProfileStatusWithHooks\r\n                    /*Данные статуса пользователя для страницы профиля.*/\r\n                    status={status}\r\n                    /*TC для изменения статуса пользователя на странице профиля.*/\r\n                    updateUserStatus={updateUserStatus}\r\n                    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный\r\n                    момент отображается на странице профиля.*/\r\n                    isOwner={isOwner}\r\n                />\r\n\r\n                {/*Если режим редактирования включен, то отрисуется компонент \"ProfileDataReduxEditForm\", получив\r\n                стартовые значения \"initialValues\" (взято из библиотеки Redux Form) для полей формы. Эти данные\r\n                автоматически раскидаются по полям в зависимости от их имен, чтобы при переходе в режим редактирования\r\n                профиля поля не были пустыми, если они уже имели какую-то информацию. При подтверждении формы в\r\n                компоненте \"ProfileDataReduxEditForm\" сработает callback-функция \"onSubmit()\" для сабмита данных. Также\r\n                передаем в компонент \"ProfileDataReduxEditForm\" объект с данными профиля пользователя \"profile\" для\r\n                маппинга этого объекта и создания полей для редактирования контактов пользователя.\r\n\r\n                Если же режим редактирования выключен, то отрисуется компонент \"ProfileData\" для отображения профиля\r\n                пользователя. В него мы передаем объект с данными профиля пользователя \"profile\", и свойство \"isOwner\",\r\n                так как нам нужно знать является ли пользователь владельцем открытого в данный момент профиля, поскольку\r\n                только владелец своего профиля должен иметь право его редактировать. Также в этот компонент мы передаем\r\n                callback-функцию \"activateEditMode()\" для активации режима редактирования профиля пользователя.\r\n\r\n                Здесь есть проблема, когда мы быстро переключаемся с чужого профиля на свой профиль - в этот момент\r\n                сразу же появляется кнопка для редактирования профиля, и если ее сразу нажать, то в полях будут данные\r\n                чужого профиля, а не своего, так как данные нашего профиля не успели еще подгрузиться.*/}\r\n                {editMode\r\n                    ? <ProfileDataReduxEditForm initialValues={profile} onSubmit={onSubmit} profile={profile}/>\r\n                    : <ProfileData profile={profile} isOwner={isOwner} activateEditMode={activateEditMode}/>\r\n                }\r\n            </div>\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\nimport styles from './Post.module.css';\r\n\r\ntype PropsType = {\r\n    /*ID поста должно быть числом. Мы это здесь не используем, но указываем, так как передаем этот ID в компоненте\r\n    \"MyPosts\" в компонент \"Post\" при использовании функции \"map()\".*/\r\n    id: number\r\n    /*Текст поста должен быть строкой.*/\r\n    message: string\r\n    /*Количество лайков должно быть числом.*/\r\n    likes: number\r\n    /*Путь к аватару пользователя должен быть строкой.*/\r\n    avatar: string\r\n};\r\n\r\n/*\"Post\" это функциональный компонент, который создан в виде стрелочной функции. \"Post\" является компонентом, который\r\nописывает, как должны выглядеть посты пользователя в его профиле.\r\n\r\nКомпонент \"Post\" импортируется в файле \"MyPosts.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"avatar\" - путь к аватару пользователя.\r\n2. \"message\" - текст поста.\r\n3. \"likes\" - количество лайков.*/\r\nexport const Post: React.FC<PropsType> = ({avatar, message, likes}) => {\r\n    return (\r\n        /*Этот элемент \"div\" представляет собой типовое отображение постов пользователя в его профиле, которое будет\r\n        отрисовываться в компоненте \"MyPosts\" при помощи метода \"map()\".*/\r\n        <div className={styles.item}>\r\n            {/*Пост пользователя в его профиле содержит аватар пользователя, ссылка на который берется из параметров\r\n            props.*/}\r\n            <img src={avatar} alt=''/>\r\n            {/*Также пост пользователя в его профиле содержит текст этого поста, которое берется из параметров props.*/}\r\n            {message}\r\n            {/*А также пост пользователя в его профиле содержит количество лайков у этого поста, которое берется из\r\n            параметров props.*/}\r\n            <div><span>likes: {likes}</span></div>\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*В данном файле работа с библиотекой Redux Form происходит следующим образом:\r\n1. callback-функция \"handleSubmit()\" указана в компоненте \"AddPostForm\".\r\n2. оборачиваем компонент \"AddPostForm\" функцией \"reduxForm()\" в компоненте \"AddPostReduxForm\", тем самым\r\nпредоставляя callback-функцию \"handleSubmit()\" для компонента \"AddPostForm\".\r\n3. компонент \"AddPostReduxForm\" указывается в компоненте \"MyPosts\", куда в событие \"onSubmit\" будет попадать объект\r\nс данными, сформированный в событии \"onSubmit\" при помощи callback-функции \"handleSubmit()\" в компоненте\r\n\"AddPostForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback-функция \"handleSubmit()\" в компоненте\r\n\"AddPostForm\", которая собирает все данные из формы и помещает их в объект. Потом внутри callback-функции\r\n\"handleSubmit()\" вызывается нами созданная callback-функция \"addNewPost()\" (доступна из контейнерного компонента\r\n\"AddPostReduxForm\") из компонента \"MyPosts\". В компонент \"MyPosts\" передается указанный объект с данными и собираются\r\nв одном месте, потом эти данные передаются в компонент \"AddPostReduxForm\", из которого перенаправляются в глобальный\r\nstate в виде объекта под именем \"profileAddPostForm\".\r\n\r\nВ компонент \"AddPostForm\" внедряются некие дополнительные props (например, та же callback-функция \"handleSubmit()\")\r\nХОКом, который образуется при помощи компонента \"AddPostReduxForm\". Эти props содержатся под именем\r\n\"InjectedFormProps\". Эти \"InjectedFormProps\" также содержат добавленные нами props. Поэтому мы импортировали\r\n\"InjectedFormProps\" из библиотеки Redux Form, чтобы типизировать такие props в компоненте \"AddPostForm\".*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\nimport styles from './MyPosts.module.css';\r\n/*Импортируем компонент \"Post\".*/\r\nimport {Post} from './Post/Post';\r\n/*Импортируем созданный нами компонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию.\r\nТакже импортируем функцию \"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для\r\nсоздания формы в компоненте \"AddPostForm\". Дополнительно импортируем тип \"GetValuesKeysType\".*/\r\nimport {createField, GetValuesKeysType, Textarea} from '../../common/FormsControls/FormsControls';\r\n/*Импортируем валидаторы для полей форм.*/\r\nimport {maxLengthCreator, required} from '../../../utils/validators/validators';\r\n/*Импортируем тип \"PostType\".*/\r\nimport {PostType} from '../../../types/types';\r\n\r\n/*Создаем общий тип для всех props компонента \"MyPosts\".*/\r\ntype MyPostsPropsType = {\r\n    /*Данные о постах на странице пользователя должны быть массивом с элементами с типом \"PostType\".*/\r\n    postsData: Array<PostType>\r\n    /*AC для добавления нового поста на странице профиля, который принимает строковой параметр и ничего не возвращает.*/\r\n    addPost: (newMessageText: string) => void\r\n};\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"AddPostForm\". Указываем пустой объект, так как компонент \"AddPostForm\"\r\nне содержит \"собственных props\".*/\r\ntype AddPostFormOwnPropsType = {};\r\n\r\n/*Создаем тип для \"props\" компонента \"AddPostForm\", которые будут использоваться в \"formData\" для компонента\r\n\"MyPosts\".*/\r\ntype AddPostFormValuesType = {\r\n    /*Текст нового поста на странице профиля, который должен быть строкой.*/\r\n    newPostText: string\r\n};\r\n\r\n/*Следующий тип мы создаем специально, чтобы мы не могли допустить ошибок при указании свойства \"name\" в функции\r\n\"createField()\". Это свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы\r\nиспользуем вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"AddPostFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"AddPostFormValuesType\".*/\r\ntype AddPostFormValuesKeysType = GetValuesKeysType<AddPostFormValuesType>;\r\n\r\n/*Создаем валидатор, который проверяет не введено ли больше 10 символов в поле.*/\r\nconst maxLength10 = maxLengthCreator(10);\r\n\r\n/*\"AddPostForm\" это функциональный компонент, который создан в виде стрелочной функции. \"AddPostForm\" является\r\nкомпонентом, который представляет собой форму для добавления постов в профиле пользователя в виде заготовки для\r\nоборачивания ее функцией \"reduxForm()\".\r\n\r\nВнутри компонента \"AddPostForm\" используются следующие компоненты:\r\n1. \"Textarea\" - компонент, который используется для отрисовки элементов \"textarea\" в других местах, где в таких\r\nэлементах требуется валидация. Импортирован.\r\n\r\nКомпонент \"AddPostForm\" используется в компоненте \"AddPostReduxForm\" в этом же файле и оборачивается функцией\r\n\"reduxForm()\", тем самым получая callback-функцию \"handleSubmit()\".\r\n\r\nУказываем при помощи \"React.FC<>\", что props в этом функциональном компоненте имеют тип\r\n\"InjectedFormProps<AddPostFormValuesType, AddPostFormOwnPropsType> & AddPostFormOwnPropsType>\".\r\n\r\nТакая комбинация получилась следующим образом:\r\n1. \"InjectedFormProps<AddPostFormValuesType, AddPostFormOwnPropsType>\" - здесь мы уточняем внедренные ХОКом, который\r\nобразуется при помощи компонента \"AddPostReduxForm\", \"InjectedFormProps\". \"AddPostFormValuesType\" указывает, что\r\nприходит из этого ХОКа, а \"AddPostFormOwnPropsType\" указывает, что приходит со стороны - в нашем случае ничего.\r\n2. \"& AddPostFormOwnPropsType\" - также этот компонент содержит некие свои \"собственные props\", которые не приходят от\r\nХОКа выше.\r\n\r\nЭто мы делаем на основании файла декларации \"InjectedFormProps\". Там указано, что первым параметром принимаются\r\n\"formData\" - то есть какие именно данные собирает форма в компоненте, оборачиваемый функцией \"reduxForm()\" (то есть\r\nкомпонент \"AddPostForm\"), и \"собственные props\" этого компонента \"AddPostForm\", непреходящие от ХОКа выше (так нужно для\r\nвнутренней работы \"InjectedFormProps\"). А вторым параметром принимаются еще раз некие свои \"собственные props\", которые\r\nне приходят от ХОКа выше (так уже надо для работы самого этого компонента \"AddPostForm\"). Третьим параметром принимается\r\nвид ошибки формы с типом строки, но в данном случае мы этого не указываем.\r\n\r\nТолько все эти три параметра указываются как бы вместе как единый параметр, а не через запятую как три разных параметра.\r\nВОЗМОЖНО, это потому, что \"InjectedFormProps\" является объектом (как единое целое состоит из разных свойств, которые\r\nможно типизировать суммой разных типов), а та же функция \"reduxForm()\" является функцией (принимает последовательность\r\nпараметров, где каждый параметр нужно отдельно типизировать).*/\r\nconst AddPostForm:\r\n    React.FC<InjectedFormProps<AddPostFormValuesType, AddPostFormOwnPropsType> & AddPostFormOwnPropsType> =\r\n    ({handleSubmit}) => {\r\n        return (\r\n            /*Здесь в элементе \"form\" в событии \"onSubmit\" указываем callback-функцию \"handleSubmit()\".*/\r\n            <form onSubmit={handleSubmit}>\r\n                {/*Создаем элемент \"div\", в котором создаем поле для ввода текста для нового поста пользователя на\r\n                странице профиля при помощи импортированной функции \"createField\".*/}\r\n                <div>\r\n                    {/*Создаем поле для ввода нового поста пользователя на странице профиля на основе импортированной\r\n                    функции \"createField()\". Уточняем здесь функцию \"createField()\", что она имеет тип\r\n                    \"AddPostFormValuesKeysType\", созданный нами выше.*/}\r\n                    {createField<AddPostFormValuesKeysType>(\r\n                        'Enter your message',\r\n                        'newPostText',\r\n                        Textarea,\r\n                        [required, maxLength10]\r\n                    )}\r\n                </div>\r\n\r\n                {/*Создаем специальный элемент \"div\", внутри которого будет находиться элемент \"button\", используемый\r\n                как кнопка для сабмита данных введенных в форму.*/}\r\n                <div>\r\n                    <button>Add post</button>\r\n                </div>\r\n            </form>\r\n        )\r\n    };\r\n\r\n/*Компонент \"AddPostReduxForm\" является отдельным контейнерным компонентом, цель которого в этом же файле обернуть\r\nкомпонент \"AddPostForm\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\". Именно компонент\r\n\"AddPostReduxForm\" будет заниматься общением с глобальным state.\r\n\r\nВнутри компонента \"AddPostReduxForm\" используются следующие компоненты:\r\n1. \"AddPostForm\" - компонент, который представляет собой форму для добавления постов в профиле пользователя в виде\r\nзаготовки для оборачивания ее функцией \"reduxForm()\". Из этого же файла.\r\n\r\nКомпонент \"AddPostReduxForm\" используется в компоненте \"MyPosts\" в этом же файле.\r\n\r\nФункция \"reduxForm()\" является generic, поэтому мы ее уточняем. В файле декларации функции \"reduxForm()\" указано, что он\r\nпринимает следующие данные:\r\n1. \"formData\" - какие именно данные собирает форма в компоненте (то есть в компоненте \"AddPostForm\"), оборачиваемым\r\nфункцией \"reduxForm()\";\r\n2. \"собственные props\" компонента (то есть компонента \"AddPostForm\"), которого оборачиваем функцией \"reduxForm()\";\r\n3. вид ошибки формы с типом строки, но в данном случае мы этого не указываем.*/\r\nconst AddPostReduxForm = reduxForm<AddPostFormValuesType, AddPostFormOwnPropsType>({\r\n    /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный state.*/\r\n    form: 'profileAddPostForm'\r\n})(AddPostForm);\r\n\r\n/*\"MyPosts\" это функциональный компонент, который создан в виде стрелочной функции. \"MyPosts\" является компонентом,\r\nкоторый отображает посты на странице профиля пользователя.\r\n\r\nВнутри компонента \"MyPosts\" используются следующие компоненты:\r\n1. \"Post\" - компонент, который описывает, как должны выглядеть посты пользователя в его профиле. Импортирован.\r\n2. \"AddPostReduxForm\" - отдельный контейнерный компонентом, цель которого в этом же файле обернуть компонент\r\n\"AddPostForm\" функцией \"reduxForm()\", чтобы предоставить callback-функцию \"handleSubmit()\". Из этого же файла.\r\n\r\nКомпонент \"MyPosts\" импортируется в файле \"MyPostsContainer.tsx\".\r\n\r\nИзначально это был классовый компонент и он отрисовывался несколько лишних раз. Но, вроде, если использовать функцию\r\n\"connect()\", то лишних отрисовок не будет. В любом случае, мы делаем этот компонент функциональным, чтобы избежать этих\r\nлишних перерисовок. Для этого мы и используем \"React.memo()\" (вроде это HOC), содержащий оптимизацию этих перерисовок,\r\nдля оборачивания нашего функционального компонента.\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"postsData\" - данные о постах на странице пользователя.\r\n2. \"addPost\" - AC для добавления нового поста на странице профиля.*/\r\nexport const MyPosts: React.FC<MyPostsPropsType> = React.memo(({postsData, addPost}) => {\r\n    /*Массив \"postsElements\" содержит посты пользователя в его профиле.*/\r\n    const postsElements = postsData.map(p => <Post id={p.id}\r\n                                                   message={p.message}\r\n                                                   likes={p.likesCount}\r\n                                                   avatar={p.avatar}\r\n                                                   key={p.id}/>);\r\n\r\n    /*Создаем специальную callback-функцию \"addNewPost()\", который будет вызываться при срабатывании события \"onSubmit\"\r\n    в форме. Эта callback-функция будет собирать все данные формы (текст нового поста пользователя на странице профиля)\r\n    в одном месте. Эти данные будут отдаваться AC \"addPost()\" для добавления нового поста пользователя на странице\r\n    профиля. Эта callback-функция получает указанные данные на входе в объекте \"formData\" с типом\r\n    \"AddPostFormValuesType\".*/\r\n    const addNewPost = (formData: AddPostFormValuesType) => {\r\n        /*Здесь мы вызываем AC \"addPost()\", полученный из props, и передаем ему текст нового поста пользователя на\r\n        странице профиля.*/\r\n        addPost(formData.newPostText);\r\n        /*После вывода поста зануляем поле для ввода текста.*/\r\n        formData.newPostText = '';\r\n    };\r\n\r\n    return (\r\n        /*Этот элемент \"div\" из себя представляет блок с постами пользователя.*/\r\n        <div className={styles.postsBlock}>\r\n            {/*При помощи элемента \"h3\" создаем заголовок для блока постов пользователя.*/}\r\n            <h3>My posts</h3>\r\n            {/*Здесь в событии \"onSubmit\" будет приходить объект с данными из callback-функции \"handleSubmit()\" из\r\n            компонента \"AddPostForm\", который обернут компонентом \"AddPostReduxForm\". Далее будет вызываться при этом\r\n            событии нами созданная callback-функция \"addNewPost()\", в которую будет передаваться этот объект с данными.\r\n            После этого эти данные будут отправляться в часть глобального state, которую обрабатывает библиотека Redux\r\n            Form, с целью осуществления работы нашей формы логина. Но теперь после отправки поста окно для ввода текста\r\n            поста не будет очищаться, так как библиотека Redux Form хоть и осуществляет FLUX-круговорот, но очистку не\r\n            осуществляет.*/}\r\n            <AddPostReduxForm onSubmit={addNewPost}/>\r\n            {/*Отрисовываем посты пользователя.*/}\r\n            <div className={styles.posts}>{postsElements}</div>\r\n        </div>\r\n    );\r\n});","import {connect} from 'react-redux';\r\n/*Импортируем объект \"profileAC\", что использовать оттуда АC \"addPostActionCreator()\".*/\r\nimport {profileAC} from '../../../redux/profile-reducer';\r\n/*Импортируем компонент \"MyPosts\".*/\r\nimport {MyPosts} from './MyPosts';\r\n/*Импортируем тип \"PostType\".*/\r\nimport {PostType} from '../../../types/types';\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from '../../../redux/redux-store';\r\n\r\ntype MapStateToPropsType = {\r\n    /*Данные о постах на странице пользователя должны быть массивом с элементами с типом \"PostType\".*/\r\n    postsData: Array<PostType>\r\n};\r\n\r\ntype MapDispatchToPropsType = {\r\n    /*AC для добавления нового поста на странице профиля, который принимает строковой параметр и ничего не возвращает.*/\r\n    addPost: (newMessageText: string) => void\r\n};\r\n\r\n/*При помощи функции \"mapStateToProps()\" указываются данные из state, которые необходимо передать в компонент\r\n\"MyPosts\".*/\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => {\r\n    return {\r\n        /*Данные о постах на странице пользователя.*/\r\n        postsData: state.profilePage.postsData\r\n    }\r\n};\r\n\r\n/*\"MyPostsContainer\" это не классовый компонент и не функциональный компонент. \"MyPostsContainer\" является контейнерным\r\nкомпонентом для компонента \"MyPosts\".\r\n\r\nВнутри компонента \"MyPostsContainer\" используются следующие компоненты:\r\n1. \"MyPosts\" - Импортирован.\r\n\r\nЭтот компонент экспортируется по default и используется в нашем приложении под именем \"MyPostsContainer\". Компонент\r\n\"MyPostsContainer\" импортируется в файле \"Profile.tsx\".\r\n\r\nВ отличие от классового компонента, компонент такого типа не имеет методов жизненного цикла классового компонента. В\r\nэтом компоненте мы просто создаем функции \"mapStateToProps()\" и \"mapDispatchToProps()\", тем самым формируя props для\r\nпрезентационной компоненты \"MyPosts\". Поэтому нам не нужно создавать классовый компонент для этого. Таким же образом\r\nработает компонент \"DialogsContainer\".\r\n\r\nПри помощи функции \"connect()\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL компоненту\r\n\"MyPosts\". Поскольку функция \"connect()\" является generic, то ее можно уточнить: первым в \"<>\" указан тип для функции\r\n\"MapStateToProps()\", вторым для функции \"MapDispatchToProps()\", третьим для \"собственных props\" компонента, четвертым\r\nдля state. Эти параметры мы узнали перейдя в файл декларации функции \"connect()\".*/\r\nexport default connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps,\r\n    {addPost: profileAC.addPost}\r\n)(MyPosts);","import React from 'react';\r\nimport styles from './Profile.module.css';\r\n/*Импортируем компонент \"ProfileInfo\".*/\r\nimport {ProfileInfo} from './ProfileInfo/ProfileInfo';\r\n/*Импортируем компонент \"MyPostsContainer\".*/\r\nimport MyPostsContainer from './MyPosts/MyPostsContainer';\r\n/*Импортируем тип \"ProfileType\".*/\r\nimport {ProfileType} from '../../types/types';\r\n\r\ntype PropsType = {\r\n    /*Информация о профиле пользователя, полученная с сервера должна быть типа \"ProfileType\" или иметь тип null, то есть\r\n    быть пустой.*/\r\n    profile: ProfileType | null\r\n    /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип null, то есть быть пустыми.*/\r\n    status: string | null\r\n    /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент\r\n    отображается на странице профиля, должно быть булева типа.*/\r\n    isOwner: boolean\r\n    /*TC для изменения данных по статусу пользователя на странице профиля должен быть функцией, которая принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n    updateUserStatus: (status: string) => void\r\n    /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении должен быть\r\n    функцией, принимающей объект с фото пользователя, которое имеет тип \"File\" из TypeScript, и ничего не\r\n    возвращающей.*/\r\n    saveUserPhoto: (photoFile: File) => void\r\n    /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем\r\n    приложении должен быть функцией, которая принимает объект типа \"ProfileType\" и возвращает какой-либо промис, так как\r\n    мы в компоненте \"ProfileInfo\" используем метод \"then()\" вместе с этим TC.*/\r\n    saveProfile: (profile: ProfileType) => Promise<any>\r\n};\r\n\r\n/*\"Profile\" это функциональный компонент, который создан в виде стрелочной функции. \"Profile\" является компонентом,\r\nкоторый отображает профиль пользователя целиком.\r\n\r\nВнутри компонента \"Profile\" используются следующие компоненты:\r\n1. \"ProfileInfo\" - компонент, который содержит информацию о пользователе. Импортирован.\r\n2. \"MyPostsContainer\" - контейнерный компонент для компонента \"MyPosts\". Импортирован.\r\n\r\nКомпонент \"Profile\" импортируется в файле \"ProfileContainer.tsx\".\r\n\r\nПри помощи деструктуризации props указываем какие именно props мы получаем:\r\n1. \"profile\" - данные профиля пользователя для страницы профиля.\r\n2. \"status\" - данные статуса пользователя для страницы профиля.\r\n3. \"updateUserStatus\" - TC для изменения статуса пользователя на странице профиля.\r\n4. \"isOwner\" - свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный момент\r\nотображается на странице профиля.\r\n5. \"saveUserPhoto\" - TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем\r\nприложении.\r\n6. \"saveProfile\" - TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в\r\nнашем приложении.*/\r\nexport const Profile: React.FC<PropsType> = ({\r\n                                                 profile,\r\n                                                 status,\r\n                                                 updateUserStatus,\r\n                                                 isOwner,\r\n                                                 saveUserPhoto,\r\n                                                 saveProfile\r\n                                             }) => {\r\n    return (\r\n        <div>\r\n            {/*Далее отрисовываем компонент \"ProfileInfo\" и передаем ему через props необходимые для него данные.*/}\r\n            <ProfileInfo\r\n                /*Данные профиля пользователя для страницы профиля.*/\r\n                profile={profile}\r\n                /*Данные статуса пользователя для страницы профиля.*/\r\n                status={status}\r\n                /*TC для изменения статуса пользователя на странице профиля.*/\r\n                updateUserStatus={updateUserStatus}\r\n                /*Свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный\r\n                момент отображается на странице профиля.*/\r\n                isOwner={isOwner}\r\n                /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем\r\n                приложении.*/\r\n                saveUserPhoto={saveUserPhoto}\r\n                /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в\r\n                нашем приложении.*/\r\n                saveProfile={saveProfile}\r\n            />\r\n\r\n            {/*А также отрисовываем компонент \"MyPostsContainer\" помимо компонента \"ProfileInfo\".*/}\r\n            <MyPostsContainer/>\r\n        </div>\r\n    );\r\n};","import React, {ComponentType} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {compose} from 'redux';\r\n/*Импортируем TC \"getUserProfile()\", \"getUserStatus()\", \"saveProfile()\", \"saveUserPhoto()\" и \"updateUserStatus()\".*/\r\nimport {getUserProfile, getUserStatus, saveProfile, saveUserPhoto, updateUserStatus} from '../../redux/profile-reducer';\r\n/*Импортируем компонент \"Profile\".*/\r\nimport {Profile} from './Profile';\r\n/*Импортируем тип \"RouteComponentProps\".*/\r\nimport {RouteComponentProps, withRouter} from 'react-router-dom';\r\n/*Импортируем тип \"ProfileType\".*/\r\nimport {ProfileType} from '../../types/types';\r\n/*Импортируем тип \"AppStateType\".*/\r\nimport {AppStateType} from '../../redux/redux-store';\r\n\r\ntype MapStateToPropsType = {\r\n    /*Информация о профиле пользователя, полученная с сервера должна быть типа \"ProfileType\" или иметь тип null, то есть\r\n    быть пустой.*/\r\n    profile: ProfileType | null\r\n    /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип null, то есть быть пустыми.*/\r\n    status: string | null\r\n    /*ID залогиненного пользователя должен быть число или иметь тип null, то есть быть пустым.*/\r\n    authUserID: number | null\r\n};\r\n\r\ntype MapDispatchToPropsType = {\r\n    /*TC для запроса и установки данных по профилю пользователя на странице профиля должен быть функцией, которая\r\n    принимает числовой параметр и ничего не возвращает.*/\r\n    getUserProfile: (userID: number) => void\r\n    /*TC для запроса и установки данных по статусу пользователя на странице профиля должен быть функцией, которая\r\n    принимает числовой параметр и ничего не возвращает.*/\r\n    getUserStatus: (userID: number) => void\r\n    /*TC для изменения данных по статусу пользователя на странице профиля должен быть функцией, которая принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n    updateUserStatus: (status: string) => void\r\n    /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении должен быть\r\n    функцией, принимающей объект с фото пользователя, которое имеет тип \"File\" из TypeScript, и ничего не\r\n    возвращающей.*/\r\n    saveUserPhoto: (photoFile: File) => void\r\n    /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем\r\n    приложении должен быть функцией, которая принимает объект типа \"ProfileType\" и возвращает что угодно с типом any,\r\n    так как пока неизвестно как это здесь типизировать, поскольку мы в файле \"ProfileInfo.tsx\" используем метод \"then()\"\r\n    вместе с этим TC. В самом файле \"ProfileInfo.tsx\" этот TC типизирован как функция, которая возвращает\r\n    \"Promise<any>\", но если здесь указать также, то будет конфликт в типизации функции \"connect()\", то есть здесь можно\r\n    указать тоже \"Promise<any>\", если избавиться от типизации в функции \"connect()\".*/\r\n    saveProfile: (profile: ProfileType) => any\r\n};\r\n\r\n/*Создали отдельный тип для объекта \"params\" из объекта \"match\" из HOC \"withRouter()\" из библиотеки React Router DOM.\r\nУказали \"string\", так как все, что находится в этом объекте \"params\", является \"string\" (так устроен HOC\r\n\"withRouter()\").*/\r\ntype ProfileWithRouterParamsTypes = {\r\n    userID: string\r\n};\r\n\r\n/*Создаем общий тип для всех props путем комбинации двух созданных выше типов и типа \"RouteComponentProps\" из библиотеки\r\nReact Router DOM. Последний тип мы указали, так как этот компонент хочет получить объект \"match\" из функции\r\n\"withRouter()\". \"RouteComponentProps\" это тип для отдельного вида props из функции \"withRouter()\". В этом типе\r\n\"RouteComponentProps\" мы уточнили какие свойства объекта \"params\" из объекта \"match\" из функции \"withRouter()\" должны\r\nсодержаться внутри при помощи типа \"ProfileWithRouterParamsTypes\", который создали выше. Все это нужно для указания типа\r\nprops в классовом компоненте.*/\r\ntype PropsType = MapStateToPropsType & MapDispatchToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>;\r\n\r\n/*\"ProfileContainerNoWraps\" это классовый компонент. \"ProfileContainerNoWraps\" является контейнерным компонентом для\r\nкомпонента \"Profile\".\r\n\r\nВнутри компонента \"ProfileContainerNoWraps\" используются следующие компоненты:\r\n1. \"Profile\" - компонент, который отображает профиль пользователя целиком. Импортирован.\r\n\r\nКомпонент \"ProfileContainerNoWraps\" оборачивается функциями \"compose()\" и \"connect()\" в этом же файле.*/\r\nclass ProfileContainerNoWraps extends React.Component<PropsType/*, StateType*/> {\r\n    /*Создаем специальный метод, который содержит необходимый функционал для обновления страницы профиля.*/\r\n    refreshProfile() {\r\n        /*Получаем ID пользователя. HOC \"withRouter()\" хранит некий объект, к которому можно обратиться как к\r\n        \"match.params.userID\", чтобы получить значения дополнения \":userID\" к пути \"/profile/\", как это указано у нас в\r\n        компоненте \"App\". Добавляем здесь \"+\" для преобразования строкового значения \"this.props.match.params.userID\" в\r\n        числовое в целях типизации. Также указываем явно тип \"number | null\" у \"userID\" для типизации.*/\r\n        let userID: number | null = +this.props.match.params.userID;\r\n\r\n        /*Если не удалось получить ID пользователя, то*/\r\n        if (!userID) {\r\n            /*пытаемся его получить от пользователя, под которым залогинены.*/\r\n            userID = this.props.authUserID;\r\n            /*А если же и после этого не удалось получить ID пользователя, то нас перенаправляет на страницу\r\n            логирования. Желательно так не использовать метод \"push()\" в компонентах, поэтому в дальнейшем это нужно\r\n            заменить на что-то другое.*/\r\n            if (!userID) this.props.history.push('/login/');\r\n        }\r\n\r\n        /*Делаем вывод ошибки в консоль, если ID пользователя отсутствует. Но по идее не должно быть ситуаций, когда ID\r\n        пользователя полностью отсутствует, возможно надо что-то изменить в проекте, чтобы не допускались такие\r\n        случаи.*/\r\n        if (!userID) {\r\n            console.error('ID should exist in URI params or in state');\r\n            /*Если же мы все-таки получили ID пользователя, то делаем следующее:*/\r\n        } else {\r\n            /*Вызываем TC \"getUserProfile()\" для получения данных профиля пользователя и их установки на странице\r\n            профиля. Без проверки на наличие ID пользователя в целях типизации пришлось бы указать, чтобы \"userID\"\r\n            воспринимался как число при помощи \"as number\".*/\r\n            this.props.getUserProfile(userID);\r\n            /*Вызываем TC \"getUserStatus()\" для получения данных статуса пользователя и их установки на странице\r\n            профиля. Без проверки на наличие ID пользователя в целях типизации пришлось бы указать, чтобы \"userID\"\r\n            воспринимался как число при помощи \"as number\".*/\r\n            this.props.getUserStatus(userID);\r\n        }\r\n    };\r\n\r\n    /*Это метод жизненного цикла классового компонента. Он вызывается в момент первой отрисовки (монтирования)\r\n    компонента.*/\r\n    componentDidMount() {\r\n        /*Вызываем метод \"refreshProfile()\".*/\r\n        this.refreshProfile();\r\n    };\r\n\r\n    /*Это метод жизненного цикла классового компонента. Он вызывается в момент обновления (изменения props или state)\r\n    компонента. Указываем тип для предыдущих props - \"prevProps\" в виде типа \"PropsType\", а для предыдущего state в виде\r\n    типа \"MapStateToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>\", так как мы еще используем данные из\r\n    HOC \"withRouter()\".*/\r\n    componentDidUpdate\r\n    (prevProps: PropsType, prevState: MapStateToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>) {\r\n        /*Проверяем изменился ли ID пользователя в props. Эта проверка нужна для избежания бесконечного цикла запросов\r\n        новых props методом \"refreshProfile()\": изначально срабатывает метод \"refreshProfile()\" из метода\r\n        \"componentDidMount()\", получаем новые props, в свою очередь это триггерит метод \"refreshProfile()\" из метода\r\n        \"componentDidUpdate()\", снова получаем новые props и снова триггерим метод \"refreshProfile()\" из метода\r\n        \"componentDidUpdate()\" и так до бесконечности.*/\r\n        if (this.props.match.params.userID !== prevProps.match.params.userID) {\r\n            /*Если изменился, то вызываем метод \"refreshProfile()\".*/\r\n            this.refreshProfile();\r\n        }\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            /*Отрисовываем компонент \"Profile\" и передаем ему через props необходимые для него данные. Здесь используем\r\n            spread-оператор \"...\", который из всех props создает атрибуты для компонента.*/\r\n            <Profile {...this.props}\r\n                /*Это свойство, показывающее является ли залогиненный пользователь владельцем профиля, который в данный\r\n                момент отображается на странице профиля. Будет равно true, если в данных URL не было найдено значения\r\n                дополнения \":userID\" к пути \"/profile/\", как это указано у нас в компоненте \"App\", то есть пользователь\r\n                совершил переход просто на \"/profile/\", желая попасть на свою страницу, а не на чью-то другую. Это\r\n                свойство нужно, чтобы интерфейс для редактирования информации в профиле появлялся только на собственной\r\n                странице пользователя. Хотя тут есть проблема, когда мы переходим на свой профиль при помощи своего ID и\r\n                не имеем упомянутого интерфейса. Далее передается в компонент \"ProfileInfo\".*/\r\n                     isOwner={!this.props.match.params.userID}\r\n            />\r\n        )\r\n    }\r\n};\r\n\r\n/*При помощи функции \"mapStateToProps()\" указываются данные из state, которые необходимо передать в компонент\r\n\"ProfileContainerNoWraps\".*/\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => ({\r\n    /*Данные профиля пользователя для страницы профиля. Далее передается в компонент \"ProfileInfo\".*/\r\n    profile: state.profilePage.profile,\r\n    /*Данные статуса пользователя для страницы профиля. Далее передается в компонент \"ProfileInfo\".*/\r\n    status: state.profilePage.status,\r\n    /*ID залогиненного пользователя.*/\r\n    authUserID: state.auth.id\r\n});\r\n\r\n/*При помощи функции \"compose()\" объединяем HOC \"withRouter()\" и функцию \"connect()\", возвращая итоговую версию\r\nкомпонента \"ProfileContainerNoWraps\". Здесь мы уточняем тип только одним параметром, так как согласно файлу декларации\r\nфункции \"compose()\" (раздел \"rest\"), нам нужно уточнить только такой компонент, свойства props которого не будут\r\nпереданы в этот компонент функциями, переданными внутрь функции \"compose()\", то есть HOC-ом \"withRouter()\" и функцией\r\n\"connect()\", а это никакие свойства, так как мы не передаем извне ничего в компонент \"ProfileContainerNoWraps\".\r\n\r\nПолучившийся итоговый компонент экспортируется по default и используется в нашем приложении под именем\r\n\"ProfileContainer\". Компонент \"ProfileContainer\" импортируется в файле \"App.tsx\".*/\r\nexport default compose<ComponentType>(\r\n    /*При помощи функции \"connect()\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\r\n    компоненту \"ProfileContainerNoWraps\" в этом файле. Поскольку функция \"connect()\" является generic, то ее можно\r\n    уточнить: первым в \"<>\" указан тип для функции \"MapStateToProps()\", вторым для функции \"MapDispatchToProps()\",\r\n    третьим для \"собственных props\" компонента, четвертым для state. Эти параметры мы узнали перейдя в файл декларации\r\n    функции \"connect()\".*/\r\n    connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps, {\r\n        /*TC для получения данных профиля пользователя и их установки на странице профиля.*/\r\n        getUserProfile,\r\n        /*TC для получения данных статуса пользователя и их установки на странице профиля.*/\r\n        getUserStatus,\r\n        /*TC для изменения статуса пользователя на странице профиля.*/\r\n        updateUserStatus,\r\n        /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении.*/\r\n        saveUserPhoto,\r\n        /*TC для отправки новых данных профиля пользователя на странице профиля и их дальнейшего отображения в нашем\r\n        приложении.*/\r\n        saveProfile\r\n    }),\r\n    /*Так же при помощи HOC \"withRouter()\" передаем в этот контейнерный компонент данные из URL.*/\r\n    withRouter\r\n)(ProfileContainerNoWraps);"],"sourceRoot":""}